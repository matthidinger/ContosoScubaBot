(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["swc"] = factory();
	else
		root["swc"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var win = window;
	var ns = win.SkypeWebControl = win.SkypeWebControl || {};
	win.ko = __webpack_require__(1);
	win.DOMPurify = __webpack_require__(4);
	win.ES6Promise = __webpack_require__(5);
	!win.Promise && win.ES6Promise && win.ES6Promise.polyfill();
	if (!Element.prototype.matches) {
	    Element.prototype.matches =
	        Element.prototype.matchesSelector ||
	            Element.prototype.mozMatchesSelector ||
	            Element.prototype.msMatchesSelector ||
	            Element.prototype.oMatchesSelector ||
	            Element.prototype.webkitMatchesSelector ||
	            function (s) {
	                var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length;
	                while (--i >= 0 && matches.item(i) !== this) { }
	                return i > -1;
	            };
	}
	win.ariaTelemetry = __webpack_require__(8);
	var button_bootstrapper_1 = __webpack_require__(9);
	var chat_bootstrapper_1 = __webpack_require__(34);
	var assets_1 = __webpack_require__(43);
	var api_1 = __webpack_require__(44);
	var chat_1 = __webpack_require__(45);
	function initialize(options) {
	    if (!options) {
	        throw new Error('Options must be defined');
	    }
	    else if (!options.connectPageUrl) {
	        throw new Error('connectPageUrl must be defined');
	    }
	    ns.EcsConfig = {
	        connectPageUrl: options.connectPageUrl,
	        ariaTenantId: '%%%ARIATENANT%%%',
	        version: '%%%VERSION%%%'
	    };
	    ns.Assets = ns.Assets || {};
	    ns.Assets.SVG = assets_1.default;
	    ns.API = ns.API || api_1.default;
	    ns.API.registerEvent('createControl', function (element) {
	        ns.ChatContent = new chat_1.default(element);
	    });
	    ns.SDK = ns.SDK || {};
	    ns.SDK.Chat = new chat_bootstrapper_1.default();
	    ns.SDK.Chat.init(true);
	    ns.SDK.Button = new button_bootstrapper_1.default();
	}
	exports.initialize = initialize;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*!
	 * Knockout JavaScript library v3.4.1
	 * (c) The Knockout.js team - http://knockoutjs.com/
	 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
	 */
	
	(function(){
	var DEBUG=true;
	(function(undefined){
	    // (0, eval)('this') is a robust way of getting a reference to the global object
	    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
	    var window = this || (0, eval)('this'),
	        document = window['document'],
	        navigator = window['navigator'],
	        jQueryInstance = window["jQuery"],
	        JSON = window["JSON"];
	(function(factory) {
	    // Support three module loading scenarios
	    if ("function" === 'function' && __webpack_require__(3)['amd']) {
	        // [1] AMD anonymous module
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (true) {
	        // [2] CommonJS/Node.js
	        factory(module['exports'] || exports);  // module.exports is for Node.js
	    } else {
	        // [3] No module loader (plain <script> tag) - put directly in global namespace
	        factory(window['ko'] = {});
	    }
	}(function(koExports, amdRequire){
	// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
	// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
	var ko = typeof koExports !== 'undefined' ? koExports : {};
	// Google Closure Compiler helpers (used only to make the minified file smaller)
	ko.exportSymbol = function(koPath, object) {
	    var tokens = koPath.split(".");
	
	    // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
	    // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
	    var target = ko;
	
	    for (var i = 0; i < tokens.length - 1; i++)
	        target = target[tokens[i]];
	    target[tokens[tokens.length - 1]] = object;
	};
	ko.exportProperty = function(owner, publicName, object) {
	    owner[publicName] = object;
	};
	ko.version = "3.4.1";
	
	ko.exportSymbol('version', ko.version);
	// For any options that may affect various areas of Knockout and aren't directly associated with data binding.
	ko.options = {
	    'deferUpdates': false,
	    'useOnlyNativeEvents': false
	};
	
	//ko.exportSymbol('options', ko.options);   // 'options' isn't minified
	ko.utils = (function () {
	    function objectForEach(obj, action) {
	        for (var prop in obj) {
	            if (obj.hasOwnProperty(prop)) {
	                action(prop, obj[prop]);
	            }
	        }
	    }
	
	    function extend(target, source) {
	        if (source) {
	            for(var prop in source) {
	                if(source.hasOwnProperty(prop)) {
	                    target[prop] = source[prop];
	                }
	            }
	        }
	        return target;
	    }
	
	    function setPrototypeOf(obj, proto) {
	        obj.__proto__ = proto;
	        return obj;
	    }
	
	    var canSetPrototype = ({ __proto__: [] } instanceof Array);
	    var canUseSymbols = !DEBUG && typeof Symbol === 'function';
	
	    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
	    var knownEvents = {}, knownEventTypesByEventName = {};
	    var keyEventTypeName = (navigator && /Firefox\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';
	    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
	    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
	    objectForEach(knownEvents, function(eventType, knownEventsForType) {
	        if (knownEventsForType.length) {
	            for (var i = 0, j = knownEventsForType.length; i < j; i++)
	                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
	        }
	    });
	    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406
	
	    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
	    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
	    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
	    // If there is a future need to detect specific versions of IE10+, we will amend this.
	    var ieVersion = document && (function() {
	        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');
	
	        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
	        while (
	            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
	            iElems[0]
	        ) {}
	        return version > 4 ? version : undefined;
	    }());
	    var isIe6 = ieVersion === 6,
	        isIe7 = ieVersion === 7;
	
	    function isClickOnCheckableElement(element, eventType) {
	        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
	        if (eventType.toLowerCase() != "click") return false;
	        var inputType = element.type;
	        return (inputType == "checkbox") || (inputType == "radio");
	    }
	
	    // For details on the pattern for changing node classes
	    // see: https://github.com/knockout/knockout/issues/1597
	    var cssClassNameRegex = /\S+/g;
	
	    function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {
	        var addOrRemoveFn;
	        if (classNames) {
	            if (typeof node.classList === 'object') {
	                addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];
	                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
	                    addOrRemoveFn.call(node.classList, className);
	                });
	            } else if (typeof node.className['baseVal'] === 'string') {
	                // SVG tag .classNames is an SVGAnimatedString instance
	                toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);
	            } else {
	                // node.className ought to be a string.
	                toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);
	            }
	        }
	    }
	
	    function toggleObjectClassPropertyString(obj, prop, classNames, shouldHaveClass) {
	        // obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.
	        var currentClassNames = obj[prop].match(cssClassNameRegex) || [];
	        ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
	            ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);
	        });
	        obj[prop] = currentClassNames.join(" ");
	    }
	
	    return {
	        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],
	
	        arrayForEach: function (array, action) {
	            for (var i = 0, j = array.length; i < j; i++)
	                action(array[i], i);
	        },
	
	        arrayIndexOf: function (array, item) {
	            if (typeof Array.prototype.indexOf == "function")
	                return Array.prototype.indexOf.call(array, item);
	            for (var i = 0, j = array.length; i < j; i++)
	                if (array[i] === item)
	                    return i;
	            return -1;
	        },
	
	        arrayFirst: function (array, predicate, predicateOwner) {
	            for (var i = 0, j = array.length; i < j; i++)
	                if (predicate.call(predicateOwner, array[i], i))
	                    return array[i];
	            return null;
	        },
	
	        arrayRemoveItem: function (array, itemToRemove) {
	            var index = ko.utils.arrayIndexOf(array, itemToRemove);
	            if (index > 0) {
	                array.splice(index, 1);
	            }
	            else if (index === 0) {
	                array.shift();
	            }
	        },
	
	        arrayGetDistinctValues: function (array) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++) {
	                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
	                    result.push(array[i]);
	            }
	            return result;
	        },
	
	        arrayMap: function (array, mapping) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++)
	                result.push(mapping(array[i], i));
	            return result;
	        },
	
	        arrayFilter: function (array, predicate) {
	            array = array || [];
	            var result = [];
	            for (var i = 0, j = array.length; i < j; i++)
	                if (predicate(array[i], i))
	                    result.push(array[i]);
	            return result;
	        },
	
	        arrayPushAll: function (array, valuesToPush) {
	            if (valuesToPush instanceof Array)
	                array.push.apply(array, valuesToPush);
	            else
	                for (var i = 0, j = valuesToPush.length; i < j; i++)
	                    array.push(valuesToPush[i]);
	            return array;
	        },
	
	        addOrRemoveItem: function(array, value, included) {
	            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
	            if (existingEntryIndex < 0) {
	                if (included)
	                    array.push(value);
	            } else {
	                if (!included)
	                    array.splice(existingEntryIndex, 1);
	            }
	        },
	
	        canSetPrototype: canSetPrototype,
	
	        extend: extend,
	
	        setPrototypeOf: setPrototypeOf,
	
	        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,
	
	        objectForEach: objectForEach,
	
	        objectMap: function(source, mapping) {
	            if (!source)
	                return source;
	            var target = {};
	            for (var prop in source) {
	                if (source.hasOwnProperty(prop)) {
	                    target[prop] = mapping(source[prop], prop, source);
	                }
	            }
	            return target;
	        },
	
	        emptyDomNode: function (domNode) {
	            while (domNode.firstChild) {
	                ko.removeNode(domNode.firstChild);
	            }
	        },
	
	        moveCleanedNodesToContainerElement: function(nodes) {
	            // Ensure it's a real array, as we're about to reparent the nodes and
	            // we don't want the underlying collection to change while we're doing that.
	            var nodesArray = ko.utils.makeArray(nodes);
	            var templateDocument = (nodesArray[0] && nodesArray[0].ownerDocument) || document;
	
	            var container = templateDocument.createElement('div');
	            for (var i = 0, j = nodesArray.length; i < j; i++) {
	                container.appendChild(ko.cleanNode(nodesArray[i]));
	            }
	            return container;
	        },
	
	        cloneNodes: function (nodesArray, shouldCleanNodes) {
	            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
	                var clonedNode = nodesArray[i].cloneNode(true);
	                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
	            }
	            return newNodesArray;
	        },
	
	        setDomNodeChildren: function (domNode, childNodes) {
	            ko.utils.emptyDomNode(domNode);
	            if (childNodes) {
	                for (var i = 0, j = childNodes.length; i < j; i++)
	                    domNode.appendChild(childNodes[i]);
	            }
	        },
	
	        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
	            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
	            if (nodesToReplaceArray.length > 0) {
	                var insertionPoint = nodesToReplaceArray[0];
	                var parent = insertionPoint.parentNode;
	                for (var i = 0, j = newNodesArray.length; i < j; i++)
	                    parent.insertBefore(newNodesArray[i], insertionPoint);
	                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
	                    ko.removeNode(nodesToReplaceArray[i]);
	                }
	            }
	        },
	
	        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {
	            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
	            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
	            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
	            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
	            // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
	            //
	            // Rules:
	            //   [A] Any leading nodes that have been removed should be ignored
	            //       These most likely correspond to memoization nodes that were already removed during binding
	            //       See https://github.com/knockout/knockout/pull/440
	            //   [B] Any trailing nodes that have been remove should be ignored
	            //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
	            //       See https://github.com/knockout/knockout/pull/1903
	            //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
	            //       and include any nodes that have been inserted among the previous collection
	
	            if (continuousNodeArray.length) {
	                // The parent node can be a virtual element; so get the real parent node
	                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;
	
	                // Rule [A]
	                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)
	                    continuousNodeArray.splice(0, 1);
	
	                // Rule [B]
	                while (continuousNodeArray.length > 1 && continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)
	                    continuousNodeArray.length--;
	
	                // Rule [C]
	                if (continuousNodeArray.length > 1) {
	                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
	                    // Replace with the actual new continuous node set
	                    continuousNodeArray.length = 0;
	                    while (current !== last) {
	                        continuousNodeArray.push(current);
	                        current = current.nextSibling;
	                    }
	                    continuousNodeArray.push(last);
	                }
	            }
	            return continuousNodeArray;
	        },
	
	        setOptionNodeSelectionState: function (optionNode, isSelected) {
	            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
	            if (ieVersion < 7)
	                optionNode.setAttribute("selected", isSelected);
	            else
	                optionNode.selected = isSelected;
	        },
	
	        stringTrim: function (string) {
	            return string === null || string === undefined ? '' :
	                string.trim ?
	                    string.trim() :
	                    string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
	        },
	
	        stringStartsWith: function (string, startsWith) {
	            string = string || "";
	            if (startsWith.length > string.length)
	                return false;
	            return string.substring(0, startsWith.length) === startsWith;
	        },
	
	        domNodeIsContainedBy: function (node, containedByNode) {
	            if (node === containedByNode)
	                return true;
	            if (node.nodeType === 11)
	                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
	            if (containedByNode.contains)
	                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
	            if (containedByNode.compareDocumentPosition)
	                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
	            while (node && node != containedByNode) {
	                node = node.parentNode;
	            }
	            return !!node;
	        },
	
	        domNodeIsAttachedToDocument: function (node) {
	            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
	        },
	
	        anyDomNodeIsAttachedToDocument: function(nodes) {
	            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
	        },
	
	        tagNameLower: function(element) {
	            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
	            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
	            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
	            return element && element.tagName && element.tagName.toLowerCase();
	        },
	
	        catchFunctionErrors: function (delegate) {
	            return ko['onError'] ? function () {
	                try {
	                    return delegate.apply(this, arguments);
	                } catch (e) {
	                    ko['onError'] && ko['onError'](e);
	                    throw e;
	                }
	            } : delegate;
	        },
	
	        setTimeout: function (handler, timeout) {
	            return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);
	        },
	
	        deferError: function (error) {
	            setTimeout(function () {
	                ko['onError'] && ko['onError'](error);
	                throw error;
	            }, 0);
	        },
	
	        registerEventHandler: function (element, eventType, handler) {
	            var wrappedHandler = ko.utils.catchFunctionErrors(handler);
	
	            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
	            if (!ko.options['useOnlyNativeEvents'] && !mustUseAttachEvent && jQueryInstance) {
	                jQueryInstance(element)['bind'](eventType, wrappedHandler);
	            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
	                element.addEventListener(eventType, wrappedHandler, false);
	            else if (typeof element.attachEvent != "undefined") {
	                var attachEventHandler = function (event) { wrappedHandler.call(element, event); },
	                    attachEventName = "on" + eventType;
	                element.attachEvent(attachEventName, attachEventHandler);
	
	                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
	                // so to avoid leaks, we have to remove them manually. See bug #856
	                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
	                    element.detachEvent(attachEventName, attachEventHandler);
	                });
	            } else
	                throw new Error("Browser doesn't support addEventListener or attachEvent");
	        },
	
	        triggerEvent: function (element, eventType) {
	            if (!(element && element.nodeType))
	                throw new Error("element must be a DOM node when calling triggerEvent");
	
	            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
	            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
	            // IE doesn't change the checked state when you trigger the click event using "fireEvent".
	            // In both cases, we'll use the click method instead.
	            var useClickWorkaround = isClickOnCheckableElement(element, eventType);
	
	            if (!ko.options['useOnlyNativeEvents'] && jQueryInstance && !useClickWorkaround) {
	                jQueryInstance(element)['trigger'](eventType);
	            } else if (typeof document.createEvent == "function") {
	                if (typeof element.dispatchEvent == "function") {
	                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
	                    var event = document.createEvent(eventCategory);
	                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
	                    element.dispatchEvent(event);
	                }
	                else
	                    throw new Error("The supplied element doesn't support dispatchEvent");
	            } else if (useClickWorkaround && element.click) {
	                element.click();
	            } else if (typeof element.fireEvent != "undefined") {
	                element.fireEvent("on" + eventType);
	            } else {
	                throw new Error("Browser doesn't support triggering events");
	            }
	        },
	
	        unwrapObservable: function (value) {
	            return ko.isObservable(value) ? value() : value;
	        },
	
	        peekObservable: function (value) {
	            return ko.isObservable(value) ? value.peek() : value;
	        },
	
	        toggleDomNodeCssClass: toggleDomNodeCssClass,
	
	        setTextContent: function(element, textContent) {
	            var value = ko.utils.unwrapObservable(textContent);
	            if ((value === null) || (value === undefined))
	                value = "";
	
	            // We need there to be exactly one child: a text node.
	            // If there are no children, more than one, or if it's not a text node,
	            // we'll clear everything and create a single text node.
	            var innerTextNode = ko.virtualElements.firstChild(element);
	            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
	                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
	            } else {
	                innerTextNode.data = value;
	            }
	
	            ko.utils.forceRefresh(element);
	        },
	
	        setElementName: function(element, name) {
	            element.name = name;
	
	            // Workaround IE 6/7 issue
	            // - https://github.com/SteveSanderson/knockout/issues/197
	            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
	            if (ieVersion <= 7) {
	                try {
	                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
	                }
	                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
	            }
	        },
	
	        forceRefresh: function(node) {
	            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
	            if (ieVersion >= 9) {
	                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
	                var elem = node.nodeType == 1 ? node : node.parentNode;
	                if (elem.style)
	                    elem.style.zoom = elem.style.zoom;
	            }
	        },
	
	        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
	            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
	            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
	            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
	            if (ieVersion) {
	                var originalWidth = selectElement.style.width;
	                selectElement.style.width = 0;
	                selectElement.style.width = originalWidth;
	            }
	        },
	
	        range: function (min, max) {
	            min = ko.utils.unwrapObservable(min);
	            max = ko.utils.unwrapObservable(max);
	            var result = [];
	            for (var i = min; i <= max; i++)
	                result.push(i);
	            return result;
	        },
	
	        makeArray: function(arrayLikeObject) {
	            var result = [];
	            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
	                result.push(arrayLikeObject[i]);
	            };
	            return result;
	        },
	
	        createSymbolOrString: function(identifier) {
	            return canUseSymbols ? Symbol(identifier) : identifier;
	        },
	
	        isIe6 : isIe6,
	        isIe7 : isIe7,
	        ieVersion : ieVersion,
	
	        getFormFields: function(form, fieldName) {
	            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
	            var isMatchingField = (typeof fieldName == 'string')
	                ? function(field) { return field.name === fieldName }
	                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
	            var matches = [];
	            for (var i = fields.length - 1; i >= 0; i--) {
	                if (isMatchingField(fields[i]))
	                    matches.push(fields[i]);
	            };
	            return matches;
	        },
	
	        parseJson: function (jsonString) {
	            if (typeof jsonString == "string") {
	                jsonString = ko.utils.stringTrim(jsonString);
	                if (jsonString) {
	                    if (JSON && JSON.parse) // Use native parsing where available
	                        return JSON.parse(jsonString);
	                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
	                }
	            }
	            return null;
	        },
	
	        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
	            if (!JSON || !JSON.stringify)
	                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
	            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
	        },
	
	        postJson: function (urlOrForm, data, options) {
	            options = options || {};
	            var params = options['params'] || {};
	            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
	            var url = urlOrForm;
	
	            // If we were given a form, use its 'action' URL and pick out any requested field values
	            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
	                var originalForm = urlOrForm;
	                url = originalForm.action;
	                for (var i = includeFields.length - 1; i >= 0; i--) {
	                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
	                    for (var j = fields.length - 1; j >= 0; j--)
	                        params[fields[j].name] = fields[j].value;
	                }
	            }
	
	            data = ko.utils.unwrapObservable(data);
	            var form = document.createElement("form");
	            form.style.display = "none";
	            form.action = url;
	            form.method = "post";
	            for (var key in data) {
	                // Since 'data' this is a model object, we include all properties including those inherited from its prototype
	                var input = document.createElement("input");
	                input.type = "hidden";
	                input.name = key;
	                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
	                form.appendChild(input);
	            }
	            objectForEach(params, function(key, value) {
	                var input = document.createElement("input");
	                input.type = "hidden";
	                input.name = key;
	                input.value = value;
	                form.appendChild(input);
	            });
	            document.body.appendChild(form);
	            options['submitter'] ? options['submitter'](form) : form.submit();
	            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
	        }
	    }
	}());
	
	ko.exportSymbol('utils', ko.utils);
	ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
	ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
	ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
	ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
	ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
	ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
	ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
	ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
	ko.exportSymbol('utils.extend', ko.utils.extend);
	ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
	ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
	ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
	ko.exportSymbol('utils.postJson', ko.utils.postJson);
	ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
	ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
	ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
	ko.exportSymbol('utils.range', ko.utils.range);
	ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
	ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
	ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);
	ko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);
	ko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);
	ko.exportSymbol('utils.setTextContent', ko.utils.setTextContent);
	ko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly
	
	if (!Function.prototype['bind']) {
	    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
	    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
	    Function.prototype['bind'] = function (object) {
	        var originalFunction = this;
	        if (arguments.length === 1) {
	            return function () {
	                return originalFunction.apply(object, arguments);
	            };
	        } else {
	            var partialArgs = Array.prototype.slice.call(arguments, 1);
	            return function () {
	                var args = partialArgs.slice(0);
	                args.push.apply(args, arguments);
	                return originalFunction.apply(object, args);
	            };
	        }
	    };
	}
	
	ko.utils.domData = new (function () {
	    var uniqueId = 0;
	    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
	    var dataStore = {};
	
	    function getAll(node, createIfNotFound) {
	        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
	        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
	        if (!hasExistingDataStore) {
	            if (!createIfNotFound)
	                return undefined;
	            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
	            dataStore[dataStoreKey] = {};
	        }
	        return dataStore[dataStoreKey];
	    }
	
	    return {
	        get: function (node, key) {
	            var allDataForNode = getAll(node, false);
	            return allDataForNode === undefined ? undefined : allDataForNode[key];
	        },
	        set: function (node, key, value) {
	            if (value === undefined) {
	                // Make sure we don't actually create a new domData key if we are actually deleting a value
	                if (getAll(node, false) === undefined)
	                    return;
	            }
	            var allDataForNode = getAll(node, true);
	            allDataForNode[key] = value;
	        },
	        clear: function (node) {
	            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
	            if (dataStoreKey) {
	                delete dataStore[dataStoreKey];
	                node[dataStoreKeyExpandoPropertyName] = null;
	                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
	            }
	            return false;
	        },
	
	        nextKey: function () {
	            return (uniqueId++) + dataStoreKeyExpandoPropertyName;
	        }
	    };
	})();
	
	ko.exportSymbol('utils.domData', ko.utils.domData);
	ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully
	
	ko.utils.domNodeDisposal = new (function () {
	    var domDataKey = ko.utils.domData.nextKey();
	    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
	    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document
	
	    function getDisposeCallbacksCollection(node, createIfNotFound) {
	        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
	        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
	            allDisposeCallbacks = [];
	            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
	        }
	        return allDisposeCallbacks;
	    }
	    function destroyCallbacksCollection(node) {
	        ko.utils.domData.set(node, domDataKey, undefined);
	    }
	
	    function cleanSingleNode(node) {
	        // Run all the dispose callbacks
	        var callbacks = getDisposeCallbacksCollection(node, false);
	        if (callbacks) {
	            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
	            for (var i = 0; i < callbacks.length; i++)
	                callbacks[i](node);
	        }
	
	        // Erase the DOM data
	        ko.utils.domData.clear(node);
	
	        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
	        ko.utils.domNodeDisposal["cleanExternalData"](node);
	
	        // Clear any immediate-child comment nodes, as these wouldn't have been found by
	        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
	        if (cleanableNodeTypesWithDescendants[node.nodeType])
	            cleanImmediateCommentTypeChildren(node);
	    }
	
	    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
	        var child, nextChild = nodeWithChildren.firstChild;
	        while (child = nextChild) {
	            nextChild = child.nextSibling;
	            if (child.nodeType === 8)
	                cleanSingleNode(child);
	        }
	    }
	
	    return {
	        addDisposeCallback : function(node, callback) {
	            if (typeof callback != "function")
	                throw new Error("Callback must be a function");
	            getDisposeCallbacksCollection(node, true).push(callback);
	        },
	
	        removeDisposeCallback : function(node, callback) {
	            var callbacksCollection = getDisposeCallbacksCollection(node, false);
	            if (callbacksCollection) {
	                ko.utils.arrayRemoveItem(callbacksCollection, callback);
	                if (callbacksCollection.length == 0)
	                    destroyCallbacksCollection(node);
	            }
	        },
	
	        cleanNode : function(node) {
	            // First clean this node, where applicable
	            if (cleanableNodeTypes[node.nodeType]) {
	                cleanSingleNode(node);
	
	                // ... then its descendants, where applicable
	                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
	                    // Clone the descendants list in case it changes during iteration
	                    var descendants = [];
	                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
	                    for (var i = 0, j = descendants.length; i < j; i++)
	                        cleanSingleNode(descendants[i]);
	                }
	            }
	            return node;
	        },
	
	        removeNode : function(node) {
	            ko.cleanNode(node);
	            if (node.parentNode)
	                node.parentNode.removeChild(node);
	        },
	
	        "cleanExternalData" : function (node) {
	            // Special support for jQuery here because it's so commonly used.
	            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
	            // so notify it to tear down any resources associated with the node & descendants here.
	            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == "function"))
	                jQueryInstance['cleanData']([node]);
	        }
	    };
	})();
	ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
	ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
	ko.exportSymbol('cleanNode', ko.cleanNode);
	ko.exportSymbol('removeNode', ko.removeNode);
	ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
	ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
	ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
	(function () {
	    var none = [0, "", ""],
	        table = [1, "<table>", "</table>"],
	        tbody = [2, "<table><tbody>", "</tbody></table>"],
	        tr = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
	        select = [1, "<select multiple='multiple'>", "</select>"],
	        lookup = {
	            'thead': table,
	            'tbody': table,
	            'tfoot': table,
	            'tr': tbody,
	            'td': tr,
	            'th': tr,
	            'option': select,
	            'optgroup': select
	        },
	
	        // This is needed for old IE if you're *not* using either jQuery or innerShiv. Doesn't affect other cases.
	        mayRequireCreateElementHack = ko.utils.ieVersion <= 8;
	
	    function getWrap(tags) {
	        var m = tags.match(/^<([a-z]+)[ >]/);
	        return (m && lookup[m[1]]) || none;
	    }
	
	    function simpleHtmlParse(html, documentContext) {
	        documentContext || (documentContext = document);
	        var windowContext = documentContext['parentWindow'] || documentContext['defaultView'] || window;
	
	        // Based on jQuery's "clean" function, but only accounting for table-related elements.
	        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly
	
	        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
	        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
	        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
	        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.
	
	        // Trim whitespace, otherwise indexOf won't work as expected
	        var tags = ko.utils.stringTrim(html).toLowerCase(), div = documentContext.createElement("div"),
	            wrap = getWrap(tags),
	            depth = wrap[0];
	
	        // Go to html and back, then peel off extra wrappers
	        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
	        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
	        if (typeof windowContext['innerShiv'] == "function") {
	            // Note that innerShiv is deprecated in favour of html5shiv. We should consider adding
	            // support for html5shiv (except if no explicit support is needed, e.g., if html5shiv
	            // somehow shims the native APIs so it just works anyway)
	            div.appendChild(windowContext['innerShiv'](markup));
	        } else {
	            if (mayRequireCreateElementHack) {
	                // The document.createElement('my-element') trick to enable custom elements in IE6-8
	                // only works if we assign innerHTML on an element associated with that document.
	                documentContext.appendChild(div);
	            }
	
	            div.innerHTML = markup;
	
	            if (mayRequireCreateElementHack) {
	                div.parentNode.removeChild(div);
	            }
	        }
	
	        // Move to the right depth
	        while (depth--)
	            div = div.lastChild;
	
	        return ko.utils.makeArray(div.lastChild.childNodes);
	    }
	
	    function jQueryHtmlParse(html, documentContext) {
	        // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
	        if (jQueryInstance['parseHTML']) {
	            return jQueryInstance['parseHTML'](html, documentContext) || []; // Ensure we always return an array and never null
	        } else {
	            // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
	            var elems = jQueryInstance['clean']([html], documentContext);
	
	            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
	            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
	            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
	            if (elems && elems[0]) {
	                // Find the top-most parent element that's a direct child of a document fragment
	                var elem = elems[0];
	                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
	                    elem = elem.parentNode;
	                // ... then detach it
	                if (elem.parentNode)
	                    elem.parentNode.removeChild(elem);
	            }
	
	            return elems;
	        }
	    }
	
	    ko.utils.parseHtmlFragment = function(html, documentContext) {
	        return jQueryInstance ?
	            jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible
	            simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.
	    };
	
	    ko.utils.setHtml = function(node, html) {
	        ko.utils.emptyDomNode(node);
	
	        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
	        html = ko.utils.unwrapObservable(html);
	
	        if ((html !== null) && (html !== undefined)) {
	            if (typeof html != 'string')
	                html = html.toString();
	
	            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
	            // for example <tr> elements which are not normally allowed to exist on their own.
	            // If you've referenced jQuery we'll use that rather than duplicating its code.
	            if (jQueryInstance) {
	                jQueryInstance(node)['html'](html);
	            } else {
	                // ... otherwise, use KO's own parsing logic.
	                var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);
	                for (var i = 0; i < parsedNodes.length; i++)
	                    node.appendChild(parsedNodes[i]);
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
	ko.exportSymbol('utils.setHtml', ko.utils.setHtml);
	
	ko.memoization = (function () {
	    var memos = {};
	
	    function randomMax8HexChars() {
	        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
	    }
	    function generateRandomId() {
	        return randomMax8HexChars() + randomMax8HexChars();
	    }
	    function findMemoNodes(rootNode, appendToArray) {
	        if (!rootNode)
	            return;
	        if (rootNode.nodeType == 8) {
	            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
	            if (memoId != null)
	                appendToArray.push({ domNode: rootNode, memoId: memoId });
	        } else if (rootNode.nodeType == 1) {
	            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
	                findMemoNodes(childNodes[i], appendToArray);
	        }
	    }
	
	    return {
	        memoize: function (callback) {
	            if (typeof callback != "function")
	                throw new Error("You can only pass a function to ko.memoization.memoize()");
	            var memoId = generateRandomId();
	            memos[memoId] = callback;
	            return "<!--[ko_memo:" + memoId + "]-->";
	        },
	
	        unmemoize: function (memoId, callbackParams) {
	            var callback = memos[memoId];
	            if (callback === undefined)
	                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
	            try {
	                callback.apply(null, callbackParams || []);
	                return true;
	            }
	            finally { delete memos[memoId]; }
	        },
	
	        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
	            var memos = [];
	            findMemoNodes(domNode, memos);
	            for (var i = 0, j = memos.length; i < j; i++) {
	                var node = memos[i].domNode;
	                var combinedParams = [node];
	                if (extraCallbackParamsArray)
	                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
	                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
	                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
	                if (node.parentNode)
	                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
	            }
	        },
	
	        parseMemoText: function (memoText) {
	            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
	            return match ? match[1] : null;
	        }
	    };
	})();
	
	ko.exportSymbol('memoization', ko.memoization);
	ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
	ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
	ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
	ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
	ko.tasks = (function () {
	    var scheduler,
	        taskQueue = [],
	        taskQueueLength = 0,
	        nextHandle = 1,
	        nextIndexToProcess = 0;
	
	    if (window['MutationObserver']) {
	        // Chrome 27+, Firefox 14+, IE 11+, Opera 15+, Safari 6.1+
	        // From https://github.com/petkaantonov/bluebird * Copyright (c) 2014 Petka Antonov * License: MIT
	        scheduler = (function (callback) {
	            var div = document.createElement("div");
	            new MutationObserver(callback).observe(div, {attributes: true});
	            return function () { div.classList.toggle("foo"); };
	        })(scheduledProcess);
	    } else if (document && "onreadystatechange" in document.createElement("script")) {
	        // IE 6-10
	        // From https://github.com/YuzuJS/setImmediate * Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola * License: MIT
	        scheduler = function (callback) {
	            var script = document.createElement("script");
	            script.onreadystatechange = function () {
	                script.onreadystatechange = null;
	                document.documentElement.removeChild(script);
	                script = null;
	                callback();
	            };
	            document.documentElement.appendChild(script);
	        };
	    } else {
	        scheduler = function (callback) {
	            setTimeout(callback, 0);
	        };
	    }
	
	    function processTasks() {
	        if (taskQueueLength) {
	            // Each mark represents the end of a logical group of tasks and the number of these groups is
	            // limited to prevent unchecked recursion.
	            var mark = taskQueueLength, countMarks = 0;
	
	            // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
	            for (var task; nextIndexToProcess < taskQueueLength; ) {
	                if (task = taskQueue[nextIndexToProcess++]) {
	                    if (nextIndexToProcess > mark) {
	                        if (++countMarks >= 5000) {
	                            nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could be causing the recursion
	                            ko.utils.deferError(Error("'Too much recursion' after processing " + countMarks + " task groups."));
	                            break;
	                        }
	                        mark = taskQueueLength;
	                    }
	                    try {
	                        task();
	                    } catch (ex) {
	                        ko.utils.deferError(ex);
	                    }
	                }
	            }
	        }
	    }
	
	    function scheduledProcess() {
	        processTasks();
	
	        // Reset the queue
	        nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
	    }
	
	    function scheduleTaskProcessing() {
	        ko.tasks['scheduler'](scheduledProcess);
	    }
	
	    var tasks = {
	        'scheduler': scheduler,     // Allow overriding the scheduler
	
	        schedule: function (func) {
	            if (!taskQueueLength) {
	                scheduleTaskProcessing();
	            }
	
	            taskQueue[taskQueueLength++] = func;
	            return nextHandle++;
	        },
	
	        cancel: function (handle) {
	            var index = handle - (nextHandle - taskQueueLength);
	            if (index >= nextIndexToProcess && index < taskQueueLength) {
	                taskQueue[index] = null;
	            }
	        },
	
	        // For testing only: reset the queue and return the previous queue length
	        'resetForTesting': function () {
	            var length = taskQueueLength - nextIndexToProcess;
	            nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
	            return length;
	        },
	
	        runEarly: processTasks
	    };
	
	    return tasks;
	})();
	
	ko.exportSymbol('tasks', ko.tasks);
	ko.exportSymbol('tasks.schedule', ko.tasks.schedule);
	//ko.exportSymbol('tasks.cancel', ko.tasks.cancel);  "cancel" isn't minified
	ko.exportSymbol('tasks.runEarly', ko.tasks.runEarly);
	ko.extenders = {
	    'throttle': function(target, timeout) {
	        // Throttling means two things:
	
	        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
	        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
	        target['throttleEvaluation'] = timeout;
	
	        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
	        //     so the target cannot change value synchronously or faster than a certain rate
	        var writeTimeoutInstance = null;
	        return ko.dependentObservable({
	            'read': target,
	            'write': function(value) {
	                clearTimeout(writeTimeoutInstance);
	                writeTimeoutInstance = ko.utils.setTimeout(function() {
	                    target(value);
	                }, timeout);
	            }
	        });
	    },
	
	    'rateLimit': function(target, options) {
	        var timeout, method, limitFunction;
	
	        if (typeof options == 'number') {
	            timeout = options;
	        } else {
	            timeout = options['timeout'];
	            method = options['method'];
	        }
	
	        // rateLimit supersedes deferred updates
	        target._deferUpdates = false;
	
	        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
	        target.limit(function(callback) {
	            return limitFunction(callback, timeout);
	        });
	    },
	
	    'deferred': function(target, options) {
	        if (options !== true) {
	            throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.')
	        }
	
	        if (!target._deferUpdates) {
	            target._deferUpdates = true;
	            target.limit(function (callback) {
	                var handle;
	                return function () {
	                    ko.tasks.cancel(handle);
	                    handle = ko.tasks.schedule(callback);
	                    target['notifySubscribers'](undefined, 'dirty');
	                };
	            });
	        }
	    },
	
	    'notify': function(target, notifyWhen) {
	        target["equalityComparer"] = notifyWhen == "always" ?
	            null :  // null equalityComparer means to always notify
	            valuesArePrimitiveAndEqual;
	    }
	};
	
	var primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };
	function valuesArePrimitiveAndEqual(a, b) {
	    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
	    return oldValueIsPrimitive ? (a === b) : false;
	}
	
	function throttle(callback, timeout) {
	    var timeoutInstance;
	    return function () {
	        if (!timeoutInstance) {
	            timeoutInstance = ko.utils.setTimeout(function () {
	                timeoutInstance = undefined;
	                callback();
	            }, timeout);
	        }
	    };
	}
	
	function debounce(callback, timeout) {
	    var timeoutInstance;
	    return function () {
	        clearTimeout(timeoutInstance);
	        timeoutInstance = ko.utils.setTimeout(callback, timeout);
	    };
	}
	
	function applyExtenders(requestedExtenders) {
	    var target = this;
	    if (requestedExtenders) {
	        ko.utils.objectForEach(requestedExtenders, function(key, value) {
	            var extenderHandler = ko.extenders[key];
	            if (typeof extenderHandler == 'function') {
	                target = extenderHandler(target, value) || target;
	            }
	        });
	    }
	    return target;
	}
	
	ko.exportSymbol('extenders', ko.extenders);
	
	ko.subscription = function (target, callback, disposeCallback) {
	    this._target = target;
	    this.callback = callback;
	    this.disposeCallback = disposeCallback;
	    this.isDisposed = false;
	    ko.exportProperty(this, 'dispose', this.dispose);
	};
	ko.subscription.prototype.dispose = function () {
	    this.isDisposed = true;
	    this.disposeCallback();
	};
	
	ko.subscribable = function () {
	    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);
	    ko_subscribable_fn.init(this);
	}
	
	var defaultEvent = "change";
	
	// Moved out of "limit" to avoid the extra closure
	function limitNotifySubscribers(value, event) {
	    if (!event || event === defaultEvent) {
	        this._limitChange(value);
	    } else if (event === 'beforeChange') {
	        this._limitBeforeChange(value);
	    } else {
	        this._origNotifySubscribers(value, event);
	    }
	}
	
	var ko_subscribable_fn = {
	    init: function(instance) {
	        instance._subscriptions = {};
	        instance._versionNumber = 1;
	    },
	
	    subscribe: function (callback, callbackTarget, event) {
	        var self = this;
	
	        event = event || defaultEvent;
	        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;
	
	        var subscription = new ko.subscription(self, boundCallback, function () {
	            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);
	            if (self.afterSubscriptionRemove)
	                self.afterSubscriptionRemove(event);
	        });
	
	        if (self.beforeSubscriptionAdd)
	            self.beforeSubscriptionAdd(event);
	
	        if (!self._subscriptions[event])
	            self._subscriptions[event] = [];
	        self._subscriptions[event].push(subscription);
	
	        return subscription;
	    },
	
	    "notifySubscribers": function (valueToNotify, event) {
	        event = event || defaultEvent;
	        if (event === defaultEvent) {
	            this.updateVersion();
	        }
	        if (this.hasSubscriptionsForEvent(event)) {
	            try {
	                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)
	                for (var a = this._subscriptions[event].slice(0), i = 0, subscription; subscription = a[i]; ++i) {
	                    // In case a subscription was disposed during the arrayForEach cycle, check
	                    // for isDisposed on each subscription before invoking its callback
	                    if (!subscription.isDisposed)
	                        subscription.callback(valueToNotify);
	                }
	            } finally {
	                ko.dependencyDetection.end(); // End suppressing dependency detection
	            }
	        }
	    },
	
	    getVersion: function () {
	        return this._versionNumber;
	    },
	
	    hasChanged: function (versionToCheck) {
	        return this.getVersion() !== versionToCheck;
	    },
	
	    updateVersion: function () {
	        ++this._versionNumber;
	    },
	
	    limit: function(limitFunction) {
	        var self = this, selfIsObservable = ko.isObservable(self),
	            ignoreBeforeChange, previousValue, pendingValue, beforeChange = 'beforeChange';
	
	        if (!self._origNotifySubscribers) {
	            self._origNotifySubscribers = self["notifySubscribers"];
	            self["notifySubscribers"] = limitNotifySubscribers;
	        }
	
	        var finish = limitFunction(function() {
	            self._notificationIsPending = false;
	
	            // If an observable provided a reference to itself, access it to get the latest value.
	            // This allows computed observables to delay calculating their value until needed.
	            if (selfIsObservable && pendingValue === self) {
	                pendingValue = self();
	            }
	            ignoreBeforeChange = false;
	            if (self.isDifferent(previousValue, pendingValue)) {
	                self._origNotifySubscribers(previousValue = pendingValue);
	            }
	        });
	
	        self._limitChange = function(value) {
	            self._notificationIsPending = ignoreBeforeChange = true;
	            pendingValue = value;
	            finish();
	        };
	        self._limitBeforeChange = function(value) {
	            if (!ignoreBeforeChange) {
	                previousValue = value;
	                self._origNotifySubscribers(value, beforeChange);
	            }
	        };
	    },
	
	    hasSubscriptionsForEvent: function(event) {
	        return this._subscriptions[event] && this._subscriptions[event].length;
	    },
	
	    getSubscriptionsCount: function (event) {
	        if (event) {
	            return this._subscriptions[event] && this._subscriptions[event].length || 0;
	        } else {
	            var total = 0;
	            ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {
	                if (eventName !== 'dirty')
	                    total += subscriptions.length;
	            });
	            return total;
	        }
	    },
	
	    isDifferent: function(oldValue, newValue) {
	        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);
	    },
	
	    extend: applyExtenders
	};
	
	ko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);
	ko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);
	ko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);
	
	// For browsers that support proto assignment, we overwrite the prototype of each
	// observable instance. Since observables are functions, we need Function.prototype
	// to still be in the prototype chain.
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);
	}
	
	ko.subscribable['fn'] = ko_subscribable_fn;
	
	
	ko.isSubscribable = function (instance) {
	    return instance != null && typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
	};
	
	ko.exportSymbol('subscribable', ko.subscribable);
	ko.exportSymbol('isSubscribable', ko.isSubscribable);
	
	ko.computedContext = ko.dependencyDetection = (function () {
	    var outerFrames = [],
	        currentFrame,
	        lastId = 0;
	
	    // Return a unique ID that can be assigned to an observable for dependency tracking.
	    // Theoretically, you could eventually overflow the number storage size, resulting
	    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
	    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
	    // take over 285 years to reach that number.
	    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
	    function getId() {
	        return ++lastId;
	    }
	
	    function begin(options) {
	        outerFrames.push(currentFrame);
	        currentFrame = options;
	    }
	
	    function end() {
	        currentFrame = outerFrames.pop();
	    }
	
	    return {
	        begin: begin,
	
	        end: end,
	
	        registerDependency: function (subscribable) {
	            if (currentFrame) {
	                if (!ko.isSubscribable(subscribable))
	                    throw new Error("Only subscribable things can act as dependencies");
	                currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));
	            }
	        },
	
	        ignore: function (callback, callbackTarget, callbackArgs) {
	            try {
	                begin();
	                return callback.apply(callbackTarget, callbackArgs || []);
	            } finally {
	                end();
	            }
	        },
	
	        getDependenciesCount: function () {
	            if (currentFrame)
	                return currentFrame.computed.getDependenciesCount();
	        },
	
	        isInitial: function() {
	            if (currentFrame)
	                return currentFrame.isInitial;
	        }
	    };
	})();
	
	ko.exportSymbol('computedContext', ko.computedContext);
	ko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);
	ko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);
	
	ko.exportSymbol('ignoreDependencies', ko.ignoreDependencies = ko.dependencyDetection.ignore);
	var observableLatestValue = ko.utils.createSymbolOrString('_latestValue');
	
	ko.observable = function (initialValue) {
	    function observable() {
	        if (arguments.length > 0) {
	            // Write
	
	            // Ignore writes if the value hasn't changed
	            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
	                observable.valueWillMutate();
	                observable[observableLatestValue] = arguments[0];
	                observable.valueHasMutated();
	            }
	            return this; // Permits chained assignments
	        }
	        else {
	            // Read
	            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
	            return observable[observableLatestValue];
	        }
	    }
	
	    observable[observableLatestValue] = initialValue;
	
	    // Inherit from 'subscribable'
	    if (!ko.utils.canSetPrototype) {
	        // 'subscribable' won't be on the prototype chain unless we put it there directly
	        ko.utils.extend(observable, ko.subscribable['fn']);
	    }
	    ko.subscribable['fn'].init(observable);
	
	    // Inherit from 'observable'
	    ko.utils.setPrototypeOfOrExtend(observable, observableFn);
	
	    if (ko.options['deferUpdates']) {
	        ko.extenders['deferred'](observable, true);
	    }
	
	    return observable;
	}
	
	// Define prototype for observables
	var observableFn = {
	    'equalityComparer': valuesArePrimitiveAndEqual,
	    peek: function() { return this[observableLatestValue]; },
	    valueHasMutated: function () { this['notifySubscribers'](this[observableLatestValue]); },
	    valueWillMutate: function () { this['notifySubscribers'](this[observableLatestValue], 'beforeChange'); }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.observable constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(observableFn, ko.subscribable['fn']);
	}
	
	var protoProperty = ko.observable.protoProperty = '__ko_proto__';
	observableFn[protoProperty] = ko.observable;
	
	ko.hasPrototype = function(instance, prototype) {
	    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
	    if (instance[protoProperty] === prototype) return true;
	    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
	};
	
	ko.isObservable = function (instance) {
	    return ko.hasPrototype(instance, ko.observable);
	}
	ko.isWriteableObservable = function (instance) {
	    // Observable
	    if ((typeof instance == 'function') && instance[protoProperty] === ko.observable)
	        return true;
	    // Writeable dependent observable
	    if ((typeof instance == 'function') && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
	        return true;
	    // Anything else
	    return false;
	}
	
	ko.exportSymbol('observable', ko.observable);
	ko.exportSymbol('isObservable', ko.isObservable);
	ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
	ko.exportSymbol('isWritableObservable', ko.isWriteableObservable);
	ko.exportSymbol('observable.fn', observableFn);
	ko.exportProperty(observableFn, 'peek', observableFn.peek);
	ko.exportProperty(observableFn, 'valueHasMutated', observableFn.valueHasMutated);
	ko.exportProperty(observableFn, 'valueWillMutate', observableFn.valueWillMutate);
	ko.observableArray = function (initialValues) {
	    initialValues = initialValues || [];
	
	    if (typeof initialValues != 'object' || !('length' in initialValues))
	        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");
	
	    var result = ko.observable(initialValues);
	    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
	    return result.extend({'trackArrayChanges':true});
	};
	
	ko.observableArray['fn'] = {
	    'remove': function (valueOrPredicate) {
	        var underlyingArray = this.peek();
	        var removedValues = [];
	        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
	        for (var i = 0; i < underlyingArray.length; i++) {
	            var value = underlyingArray[i];
	            if (predicate(value)) {
	                if (removedValues.length === 0) {
	                    this.valueWillMutate();
	                }
	                removedValues.push(value);
	                underlyingArray.splice(i, 1);
	                i--;
	            }
	        }
	        if (removedValues.length) {
	            this.valueHasMutated();
	        }
	        return removedValues;
	    },
	
	    'removeAll': function (arrayOfValues) {
	        // If you passed zero args, we remove everything
	        if (arrayOfValues === undefined) {
	            var underlyingArray = this.peek();
	            var allValues = underlyingArray.slice(0);
	            this.valueWillMutate();
	            underlyingArray.splice(0, underlyingArray.length);
	            this.valueHasMutated();
	            return allValues;
	        }
	        // If you passed an arg, we interpret it as an array of entries to remove
	        if (!arrayOfValues)
	            return [];
	        return this['remove'](function (value) {
	            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
	        });
	    },
	
	    'destroy': function (valueOrPredicate) {
	        var underlyingArray = this.peek();
	        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
	        this.valueWillMutate();
	        for (var i = underlyingArray.length - 1; i >= 0; i--) {
	            var value = underlyingArray[i];
	            if (predicate(value))
	                underlyingArray[i]["_destroy"] = true;
	        }
	        this.valueHasMutated();
	    },
	
	    'destroyAll': function (arrayOfValues) {
	        // If you passed zero args, we destroy everything
	        if (arrayOfValues === undefined)
	            return this['destroy'](function() { return true });
	
	        // If you passed an arg, we interpret it as an array of entries to destroy
	        if (!arrayOfValues)
	            return [];
	        return this['destroy'](function (value) {
	            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
	        });
	    },
	
	    'indexOf': function (item) {
	        var underlyingArray = this();
	        return ko.utils.arrayIndexOf(underlyingArray, item);
	    },
	
	    'replace': function(oldItem, newItem) {
	        var index = this['indexOf'](oldItem);
	        if (index >= 0) {
	            this.valueWillMutate();
	            this.peek()[index] = newItem;
	            this.valueHasMutated();
	        }
	    }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.observableArray constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);
	}
	
	// Populate ko.observableArray.fn with read/write functions from native arrays
	// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
	// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
	ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
	    ko.observableArray['fn'][methodName] = function () {
	        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
	        // (for consistency with mutating regular observables)
	        var underlyingArray = this.peek();
	        this.valueWillMutate();
	        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
	        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
	        this.valueHasMutated();
	        // The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.
	        return methodCallResult === underlyingArray ? this : methodCallResult;
	    };
	});
	
	// Populate ko.observableArray.fn with read-only functions from native arrays
	ko.utils.arrayForEach(["slice"], function (methodName) {
	    ko.observableArray['fn'][methodName] = function () {
	        var underlyingArray = this();
	        return underlyingArray[methodName].apply(underlyingArray, arguments);
	    };
	});
	
	ko.exportSymbol('observableArray', ko.observableArray);
	var arrayChangeEventName = 'arrayChange';
	ko.extenders['trackArrayChanges'] = function(target, options) {
	    // Use the provided options--each call to trackArrayChanges overwrites the previously set options
	    target.compareArrayOptions = {};
	    if (options && typeof options == "object") {
	        ko.utils.extend(target.compareArrayOptions, options);
	    }
	    target.compareArrayOptions['sparse'] = true;
	
	    // Only modify the target observable once
	    if (target.cacheDiffForKnownOperation) {
	        return;
	    }
	    var trackingChanges = false,
	        cachedDiff = null,
	        arrayChangeSubscription,
	        pendingNotifications = 0,
	        underlyingNotifySubscribersFunction,
	        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,
	        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;
	
	    // Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
	    target.beforeSubscriptionAdd = function (event) {
	        if (underlyingBeforeSubscriptionAddFunction)
	            underlyingBeforeSubscriptionAddFunction.call(target, event);
	        if (event === arrayChangeEventName) {
	            trackChanges();
	        }
	    };
	    // Watch "dispose" calls, and for array change events, ensure change tracking is disabled when all are disposed
	    target.afterSubscriptionRemove = function (event) {
	        if (underlyingAfterSubscriptionRemoveFunction)
	            underlyingAfterSubscriptionRemoveFunction.call(target, event);
	        if (event === arrayChangeEventName && !target.hasSubscriptionsForEvent(arrayChangeEventName)) {
	            if (underlyingNotifySubscribersFunction) {
	                target['notifySubscribers'] = underlyingNotifySubscribersFunction;
	                underlyingNotifySubscribersFunction = undefined;
	            }
	            arrayChangeSubscription.dispose();
	            trackingChanges = false;
	        }
	    };
	
	    function trackChanges() {
	        // Calling 'trackChanges' multiple times is the same as calling it once
	        if (trackingChanges) {
	            return;
	        }
	
	        trackingChanges = true;
	
	        // Intercept "notifySubscribers" to track how many times it was called.
	        underlyingNotifySubscribersFunction = target['notifySubscribers'];
	        target['notifySubscribers'] = function(valueToNotify, event) {
	            if (!event || event === defaultEvent) {
	                ++pendingNotifications;
	            }
	            return underlyingNotifySubscribersFunction.apply(this, arguments);
	        };
	
	        // Each time the array changes value, capture a clone so that on the next
	        // change it's possible to produce a diff
	        var previousContents = [].concat(target.peek() || []);
	        cachedDiff = null;
	        arrayChangeSubscription = target.subscribe(function(currentContents) {
	            // Make a copy of the current contents and ensure it's an array
	            currentContents = [].concat(currentContents || []);
	
	            // Compute the diff and issue notifications, but only if someone is listening
	            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
	                var changes = getChanges(previousContents, currentContents);
	            }
	
	            // Eliminate references to the old, removed items, so they can be GCed
	            previousContents = currentContents;
	            cachedDiff = null;
	            pendingNotifications = 0;
	
	            if (changes && changes.length) {
	                target['notifySubscribers'](changes, arrayChangeEventName);
	            }
	        });
	    }
	
	    function getChanges(previousContents, currentContents) {
	        // We try to re-use cached diffs.
	        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates
	        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
	        // notifications are issued immediately so we wouldn't be queueing up more than one.
	        if (!cachedDiff || pendingNotifications > 1) {
	            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, target.compareArrayOptions);
	        }
	
	        return cachedDiff;
	    }
	
	    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {
	        // Only run if we're currently tracking changes for this observable array
	        // and there aren't any pending deferred notifications.
	        if (!trackingChanges || pendingNotifications) {
	            return;
	        }
	        var diff = [],
	            arrayLength = rawArray.length,
	            argsLength = args.length,
	            offset = 0;
	
	        function pushDiff(status, value, index) {
	            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };
	        }
	        switch (operationName) {
	            case 'push':
	                offset = arrayLength;
	            case 'unshift':
	                for (var index = 0; index < argsLength; index++) {
	                    pushDiff('added', args[index], offset + index);
	                }
	                break;
	
	            case 'pop':
	                offset = arrayLength - 1;
	            case 'shift':
	                if (arrayLength) {
	                    pushDiff('deleted', rawArray[offset], offset);
	                }
	                break;
	
	            case 'splice':
	                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
	                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
	                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),
	                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),
	                    endAddIndex = startIndex + argsLength - 2,
	                    endIndex = Math.max(endDeleteIndex, endAddIndex),
	                    additions = [], deletions = [];
	                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {
	                    if (index < endDeleteIndex)
	                        deletions.push(pushDiff('deleted', rawArray[index], index));
	                    if (index < endAddIndex)
	                        additions.push(pushDiff('added', args[argsIndex], index));
	                }
	                ko.utils.findMovesInArrayComparison(deletions, additions);
	                break;
	
	            default:
	                return;
	        }
	        cachedDiff = diff;
	    };
	};
	var computedState = ko.utils.createSymbolOrString('_state');
	
	ko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
	    if (typeof evaluatorFunctionOrOptions === "object") {
	        // Single-parameter syntax - everything is on this "options" param
	        options = evaluatorFunctionOrOptions;
	    } else {
	        // Multi-parameter syntax - construct the options according to the params passed
	        options = options || {};
	        if (evaluatorFunctionOrOptions) {
	            options["read"] = evaluatorFunctionOrOptions;
	        }
	    }
	    if (typeof options["read"] != "function")
	        throw Error("Pass a function that returns the value of the ko.computed");
	
	    var writeFunction = options["write"];
	    var state = {
	        latestValue: undefined,
	        isStale: true,
	        isBeingEvaluated: false,
	        suppressDisposalUntilDisposeWhenReturnsFalse: false,
	        isDisposed: false,
	        pure: false,
	        isSleeping: false,
	        readFunction: options["read"],
	        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
	        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
	        disposeWhen: options["disposeWhen"] || options.disposeWhen,
	        domNodeDisposalCallback: null,
	        dependencyTracking: {},
	        dependenciesCount: 0,
	        evaluationTimeoutInstance: null
	    };
	
	    function computedObservable() {
	        if (arguments.length > 0) {
	            if (typeof writeFunction === "function") {
	                // Writing a value
	                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
	            } else {
	                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
	            }
	            return this; // Permits chained assignments
	        } else {
	            // Reading the value
	            ko.dependencyDetection.registerDependency(computedObservable);
	            if (state.isStale || (state.isSleeping && computedObservable.haveDependenciesChanged())) {
	                computedObservable.evaluateImmediate();
	            }
	            return state.latestValue;
	        }
	    }
	
	    computedObservable[computedState] = state;
	    computedObservable.hasWriteFunction = typeof writeFunction === "function";
	
	    // Inherit from 'subscribable'
	    if (!ko.utils.canSetPrototype) {
	        // 'subscribable' won't be on the prototype chain unless we put it there directly
	        ko.utils.extend(computedObservable, ko.subscribable['fn']);
	    }
	    ko.subscribable['fn'].init(computedObservable);
	
	    // Inherit from 'computed'
	    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);
	
	    if (options['pure']) {
	        state.pure = true;
	        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
	        ko.utils.extend(computedObservable, pureComputedOverrides);
	    } else if (options['deferEvaluation']) {
	        ko.utils.extend(computedObservable, deferEvaluationOverrides);
	    }
	
	    if (ko.options['deferUpdates']) {
	        ko.extenders['deferred'](computedObservable, true);
	    }
	
	    if (DEBUG) {
	        // #1731 - Aid debugging by exposing the computed's options
	        computedObservable["_options"] = options;
	    }
	
	    if (state.disposeWhenNodeIsRemoved) {
	        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
	        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
	        // we'll prevent disposal until "disposeWhen" first returns false.
	        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;
	
	        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
	        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
	        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't
	        // be documented or used by application code, as it's likely to change in a future version of KO.
	        if (!state.disposeWhenNodeIsRemoved.nodeType) {
	            state.disposeWhenNodeIsRemoved = null;
	        }
	    }
	
	    // Evaluate, unless sleeping or deferEvaluation is true
	    if (!state.isSleeping && !options['deferEvaluation']) {
	        computedObservable.evaluateImmediate();
	    }
	
	    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is
	    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).
	    if (state.disposeWhenNodeIsRemoved && computedObservable.isActive()) {
	        ko.utils.domNodeDisposal.addDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback = function () {
	            computedObservable.dispose();
	        });
	    }
	
	    return computedObservable;
	};
	
	// Utility function that disposes a given dependencyTracking entry
	function computedDisposeDependencyCallback(id, entryToDispose) {
	    if (entryToDispose !== null && entryToDispose.dispose) {
	        entryToDispose.dispose();
	    }
	}
	
	// This function gets called each time a dependency is detected while evaluating a computed.
	// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.
	function computedBeginDependencyDetectionCallback(subscribable, id) {
	    var computedObservable = this.computedObservable,
	        state = computedObservable[computedState];
	    if (!state.isDisposed) {
	        if (this.disposalCount && this.disposalCandidates[id]) {
	            // Don't want to dispose this subscription, as it's still being used
	            computedObservable.addDependencyTracking(id, subscribable, this.disposalCandidates[id]);
	            this.disposalCandidates[id] = null; // No need to actually delete the property - disposalCandidates is a transient object anyway
	            --this.disposalCount;
	        } else if (!state.dependencyTracking[id]) {
	            // Brand new subscription - add it
	            computedObservable.addDependencyTracking(id, subscribable, state.isSleeping ? { _target: subscribable } : computedObservable.subscribeToDependency(subscribable));
	        }
	    }
	}
	
	var computedFn = {
	    "equalityComparer": valuesArePrimitiveAndEqual,
	    getDependenciesCount: function () {
	        return this[computedState].dependenciesCount;
	    },
	    addDependencyTracking: function (id, target, trackingObj) {
	        if (this[computedState].pure && target === this) {
	            throw Error("A 'pure' computed must not be called recursively");
	        }
	
	        this[computedState].dependencyTracking[id] = trackingObj;
	        trackingObj._order = this[computedState].dependenciesCount++;
	        trackingObj._version = target.getVersion();
	    },
	    haveDependenciesChanged: function () {
	        var id, dependency, dependencyTracking = this[computedState].dependencyTracking;
	        for (id in dependencyTracking) {
	            if (dependencyTracking.hasOwnProperty(id)) {
	                dependency = dependencyTracking[id];
	                if (dependency._target.hasChanged(dependency._version)) {
	                    return true;
	                }
	            }
	        }
	    },
	    markDirty: function () {
	        // Process "dirty" events if we can handle delayed notifications
	        if (this._evalDelayed && !this[computedState].isBeingEvaluated) {
	            this._evalDelayed();
	        }
	    },
	    isActive: function () {
	        return this[computedState].isStale || this[computedState].dependenciesCount > 0;
	    },
	    respondToChange: function () {
	        // Ignore "change" events if we've already scheduled a delayed notification
	        if (!this._notificationIsPending) {
	            this.evaluatePossiblyAsync();
	        }
	    },
	    subscribeToDependency: function (target) {
	        if (target._deferUpdates && !this[computedState].disposeWhenNodeIsRemoved) {
	            var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),
	                changeSub = target.subscribe(this.respondToChange, this);
	            return {
	                _target: target,
	                dispose: function () {
	                    dirtySub.dispose();
	                    changeSub.dispose();
	                }
	            };
	        } else {
	            return target.subscribe(this.evaluatePossiblyAsync, this);
	        }
	    },
	    evaluatePossiblyAsync: function () {
	        var computedObservable = this,
	            throttleEvaluationTimeout = computedObservable['throttleEvaluation'];
	        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
	            clearTimeout(this[computedState].evaluationTimeoutInstance);
	            this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {
	                computedObservable.evaluateImmediate(true /*notifyChange*/);
	            }, throttleEvaluationTimeout);
	        } else if (computedObservable._evalDelayed) {
	            computedObservable._evalDelayed();
	        } else {
	            computedObservable.evaluateImmediate(true /*notifyChange*/);
	        }
	    },
	    evaluateImmediate: function (notifyChange) {
	        var computedObservable = this,
	            state = computedObservable[computedState],
	            disposeWhen = state.disposeWhen,
	            changed = false;
	
	        if (state.isBeingEvaluated) {
	            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
	            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
	            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
	            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
	            return;
	        }
	
	        // Do not evaluate (and possibly capture new dependencies) if disposed
	        if (state.isDisposed) {
	            return;
	        }
	
	        if (state.disposeWhenNodeIsRemoved && !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen && disposeWhen()) {
	            // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
	            if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {
	                computedObservable.dispose();
	                return;
	            }
	        } else {
	            // It just did return false, so we can stop suppressing now
	            state.suppressDisposalUntilDisposeWhenReturnsFalse = false;
	        }
	
	        state.isBeingEvaluated = true;
	        try {
	            changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);
	        } finally {
	            state.isBeingEvaluated = false;
	        }
	
	        if (!state.dependenciesCount) {
	            computedObservable.dispose();
	        }
	
	        return changed;
	    },
	    evaluateImmediate_CallReadWithDependencyDetection: function (notifyChange) {
	        // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
	        // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
	        // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).
	
	        var computedObservable = this,
	            state = computedObservable[computedState],
	            changed = false;
	
	        // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
	        // Then, during evaluation, we cross off any that are in fact still being used.
	        var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies, it must be the first time
	            dependencyDetectionContext = {
	                computedObservable: computedObservable,
	                disposalCandidates: state.dependencyTracking,
	                disposalCount: state.dependenciesCount
	            };
	
	        ko.dependencyDetection.begin({
	            callbackTarget: dependencyDetectionContext,
	            callback: computedBeginDependencyDetectionCallback,
	            computed: computedObservable,
	            isInitial: isInitial
	        });
	
	        state.dependencyTracking = {};
	        state.dependenciesCount = 0;
	
	        var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);
	
	        if (computedObservable.isDifferent(state.latestValue, newValue)) {
	            if (!state.isSleeping) {
	                computedObservable["notifySubscribers"](state.latestValue, "beforeChange");
	            }
	
	            state.latestValue = newValue;
	            if (DEBUG) computedObservable._latestValue = newValue;
	
	            if (state.isSleeping) {
	                computedObservable.updateVersion();
	            } else if (notifyChange) {
	                computedObservable["notifySubscribers"](state.latestValue);
	            }
	
	            changed = true;
	        }
	
	        if (isInitial) {
	            computedObservable["notifySubscribers"](state.latestValue, "awake");
	        }
	
	        return changed;
	    },
	    evaluateImmediate_CallReadThenEndDependencyDetection: function (state, dependencyDetectionContext) {
	        // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
	        // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
	        // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
	        // overhead of computed evaluation (on V8 at least).
	
	        try {
	            var readFunction = state.readFunction;
	            return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();
	        } finally {
	            ko.dependencyDetection.end();
	
	            // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
	            if (dependencyDetectionContext.disposalCount && !state.isSleeping) {
	                ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);
	            }
	
	            state.isStale = false;
	        }
	    },
	    peek: function () {
	        // Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation" is set.
	        var state = this[computedState];
	        if ((state.isStale && !state.dependenciesCount) || (state.isSleeping && this.haveDependenciesChanged())) {
	            this.evaluateImmediate();
	        }
	        return state.latestValue;
	    },
	    limit: function (limitFunction) {
	        // Override the limit function with one that delays evaluation as well
	        ko.subscribable['fn'].limit.call(this, limitFunction);
	        this._evalDelayed = function () {
	            this._limitBeforeChange(this[computedState].latestValue);
	
	            this[computedState].isStale = true; // Mark as dirty
	
	            // Pass the observable to the "limit" code, which will access it when
	            // it's time to do the notification.
	            this._limitChange(this);
	        }
	    },
	    dispose: function () {
	        var state = this[computedState];
	        if (!state.isSleeping && state.dependencyTracking) {
	            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                if (dependency.dispose)
	                    dependency.dispose();
	            });
	        }
	        if (state.disposeWhenNodeIsRemoved && state.domNodeDisposalCallback) {
	            ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);
	        }
	        state.dependencyTracking = null;
	        state.dependenciesCount = 0;
	        state.isDisposed = true;
	        state.isStale = false;
	        state.isSleeping = false;
	        state.disposeWhenNodeIsRemoved = null;
	    }
	};
	
	var pureComputedOverrides = {
	    beforeSubscriptionAdd: function (event) {
	        // If asleep, wake up the computed by subscribing to any dependencies.
	        var computedObservable = this,
	            state = computedObservable[computedState];
	        if (!state.isDisposed && state.isSleeping && event == 'change') {
	            state.isSleeping = false;
	            if (state.isStale || computedObservable.haveDependenciesChanged()) {
	                state.dependencyTracking = null;
	                state.dependenciesCount = 0;
	                state.isStale = true;
	                if (computedObservable.evaluateImmediate()) {
	                    computedObservable.updateVersion();
	                }
	            } else {
	                // First put the dependencies in order
	                var dependeciesOrder = [];
	                ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                    dependeciesOrder[dependency._order] = id;
	                });
	                // Next, subscribe to each one
	                ko.utils.arrayForEach(dependeciesOrder, function (id, order) {
	                    var dependency = state.dependencyTracking[id],
	                        subscription = computedObservable.subscribeToDependency(dependency._target);
	                    subscription._order = order;
	                    subscription._version = dependency._version;
	                    state.dependencyTracking[id] = subscription;
	                });
	            }
	            if (!state.isDisposed) {     // test since evaluating could trigger disposal
	                computedObservable["notifySubscribers"](state.latestValue, "awake");
	            }
	        }
	    },
	    afterSubscriptionRemove: function (event) {
	        var state = this[computedState];
	        if (!state.isDisposed && event == 'change' && !this.hasSubscriptionsForEvent('change')) {
	            ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
	                if (dependency.dispose) {
	                    state.dependencyTracking[id] = {
	                        _target: dependency._target,
	                        _order: dependency._order,
	                        _version: dependency._version
	                    };
	                    dependency.dispose();
	                }
	            });
	            state.isSleeping = true;
	            this["notifySubscribers"](undefined, "asleep");
	        }
	    },
	    getVersion: function () {
	        // Because a pure computed is not automatically updated while it is sleeping, we can't
	        // simply return the version number. Instead, we check if any of the dependencies have
	        // changed and conditionally re-evaluate the computed observable.
	        var state = this[computedState];
	        if (state.isSleeping && (state.isStale || this.haveDependenciesChanged())) {
	            this.evaluateImmediate();
	        }
	        return ko.subscribable['fn'].getVersion.call(this);
	    }
	};
	
	var deferEvaluationOverrides = {
	    beforeSubscriptionAdd: function (event) {
	        // This will force a computed with deferEvaluation to evaluate when the first subscription is registered.
	        if (event == 'change' || event == 'beforeChange') {
	            this.peek();
	        }
	    }
	};
	
	// Note that for browsers that don't support proto assignment, the
	// inheritance chain is created manually in the ko.computed constructor
	if (ko.utils.canSetPrototype) {
	    ko.utils.setPrototypeOf(computedFn, ko.subscribable['fn']);
	}
	
	// Set the proto chain values for ko.hasPrototype
	var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
	ko.computed[protoProp] = ko.observable;
	computedFn[protoProp] = ko.computed;
	
	ko.isComputed = function (instance) {
	    return ko.hasPrototype(instance, ko.computed);
	};
	
	ko.isPureComputed = function (instance) {
	    return ko.hasPrototype(instance, ko.computed)
	        && instance[computedState] && instance[computedState].pure;
	};
	
	ko.exportSymbol('computed', ko.computed);
	ko.exportSymbol('dependentObservable', ko.computed);    // export ko.dependentObservable for backwards compatibility (1.x)
	ko.exportSymbol('isComputed', ko.isComputed);
	ko.exportSymbol('isPureComputed', ko.isPureComputed);
	ko.exportSymbol('computed.fn', computedFn);
	ko.exportProperty(computedFn, 'peek', computedFn.peek);
	ko.exportProperty(computedFn, 'dispose', computedFn.dispose);
	ko.exportProperty(computedFn, 'isActive', computedFn.isActive);
	ko.exportProperty(computedFn, 'getDependenciesCount', computedFn.getDependenciesCount);
	
	ko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
	    if (typeof evaluatorFunctionOrOptions === 'function') {
	        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
	    } else {
	        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
	        evaluatorFunctionOrOptions['pure'] = true;
	        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
	    }
	}
	ko.exportSymbol('pureComputed', ko.pureComputed);
	
	(function() {
	    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)
	
	    ko.toJS = function(rootObject) {
	        if (arguments.length == 0)
	            throw new Error("When calling ko.toJS, pass the object you want to convert.");
	
	        // We just unwrap everything at every level in the object graph
	        return mapJsObjectGraph(rootObject, function(valueToMap) {
	            // Loop because an observable's value might in turn be another observable wrapper
	            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
	                valueToMap = valueToMap();
	            return valueToMap;
	        });
	    };
	
	    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
	        var plainJavaScriptObject = ko.toJS(rootObject);
	        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
	    };
	
	    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
	        visitedObjects = visitedObjects || new objectLookup();
	
	        rootObject = mapInputCallback(rootObject);
	        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof RegExp)) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));
	        if (!canHaveProperties)
	            return rootObject;
	
	        var outputProperties = rootObject instanceof Array ? [] : {};
	        visitedObjects.save(rootObject, outputProperties);
	
	        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
	            var propertyValue = mapInputCallback(rootObject[indexer]);
	
	            switch (typeof propertyValue) {
	                case "boolean":
	                case "number":
	                case "string":
	                case "function":
	                    outputProperties[indexer] = propertyValue;
	                    break;
	                case "object":
	                case "undefined":
	                    var previouslyMappedValue = visitedObjects.get(propertyValue);
	                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
	                        ? previouslyMappedValue
	                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
	                    break;
	            }
	        });
	
	        return outputProperties;
	    }
	
	    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
	        if (rootObject instanceof Array) {
	            for (var i = 0; i < rootObject.length; i++)
	                visitorCallback(i);
	
	            // For arrays, also respect toJSON property for custom mappings (fixes #278)
	            if (typeof rootObject['toJSON'] == 'function')
	                visitorCallback('toJSON');
	        } else {
	            for (var propertyName in rootObject) {
	                visitorCallback(propertyName);
	            }
	        }
	    };
	
	    function objectLookup() {
	        this.keys = [];
	        this.values = [];
	    };
	
	    objectLookup.prototype = {
	        constructor: objectLookup,
	        save: function(key, value) {
	            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
	            if (existingIndex >= 0)
	                this.values[existingIndex] = value;
	            else {
	                this.keys.push(key);
	                this.values.push(value);
	            }
	        },
	        get: function(key) {
	            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
	            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;
	        }
	    };
	})();
	
	ko.exportSymbol('toJS', ko.toJS);
	ko.exportSymbol('toJSON', ko.toJSON);
	(function () {
	    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';
	
	    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
	    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
	    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
	    ko.selectExtensions = {
	        readValue : function(element) {
	            switch (ko.utils.tagNameLower(element)) {
	                case 'option':
	                    if (element[hasDomDataExpandoProperty] === true)
	                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
	                    return ko.utils.ieVersion <= 7
	                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)
	                        : element.value;
	                case 'select':
	                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
	                default:
	                    return element.value;
	            }
	        },
	
	        writeValue: function(element, value, allowUnset) {
	            switch (ko.utils.tagNameLower(element)) {
	                case 'option':
	                    switch(typeof value) {
	                        case "string":
	                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
	                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
	                                delete element[hasDomDataExpandoProperty];
	                            }
	                            element.value = value;
	                            break;
	                        default:
	                            // Store arbitrary object using DomData
	                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
	                            element[hasDomDataExpandoProperty] = true;
	
	                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
	                            element.value = typeof value === "number" ? value : "";
	                            break;
	                    }
	                    break;
	                case 'select':
	                    if (value === "" || value === null)       // A blank string or null value will select the caption
	                        value = undefined;
	                    var selection = -1;
	                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {
	                        optionValue = ko.selectExtensions.readValue(element.options[i]);
	                        // Include special check to handle selecting a caption with a blank string value
	                        if (optionValue == value || (optionValue == "" && value === undefined)) {
	                            selection = i;
	                            break;
	                        }
	                    }
	                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {
	                        element.selectedIndex = selection;
	                    }
	                    break;
	                default:
	                    if ((value === null) || (value === undefined))
	                        value = "";
	                    element.value = value;
	                    break;
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('selectExtensions', ko.selectExtensions);
	ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
	ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
	ko.expressionRewriting = (function () {
	    var javaScriptReservedWords = ["true", "false", "null", "undefined"];
	
	    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
	    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
	    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
	    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;
	
	    function getWriteableValue(expression) {
	        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)
	            return false;
	        var match = expression.match(javaScriptAssignmentTarget);
	        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
	    }
	
	    // The following regular expressions will be used to split an object-literal string into tokens
	
	        // These two match strings, either with double quotes or single quotes
	    var stringDouble = '"(?:[^"\\\\]|\\\\.)*"',
	        stringSingle = "'(?:[^'\\\\]|\\\\.)*'",
	        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions
	        // as a regular expression (this is handled by the parsing loop below).
	        stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*',
	        // These characters have special meaning to the parser and must not appear in the middle of a
	        // token, except as part of a string.
	        specials = ',"\'{}()/:[\\]',
	        // Match text (at least two characters) that does not contain any of the above special characters,
	        // although some of the special characters are allowed to start it (all but the colon and comma).
	        // The text can contain spaces, but leading or trailing spaces are skipped.
	        everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']',
	        // Match any non-space character not matched already. This will match colons and commas, since they're
	        // not matched by "everyThingElse", but will also match any other single character that wasn't already
	        // matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).
	        oneNotSpace = '[^\\s]',
	
	        // Create the actual regular expression by or-ing the above strings. The order is important.
	        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),
	
	        // Match end of previous token to determine whether a slash is a division or regex.
	        divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/,
	        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};
	
	    function parseObjectLiteral(objectLiteralString) {
	        // Trim leading and trailing spaces from the string
	        var str = ko.utils.stringTrim(objectLiteralString);
	
	        // Trim braces '{' surrounding the whole object literal
	        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);
	
	        // Split into tokens
	        var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;
	
	        if (toks) {
	            // Append a comma so that we don't need a separate code block to deal with the last item
	            toks.push(',');
	
	            for (var i = 0, tok; tok = toks[i]; ++i) {
	                var c = tok.charCodeAt(0);
	                // A comma signals the end of a key/value pair if depth is zero
	                if (c === 44) { // ","
	                    if (depth <= 0) {
	                        result.push((key && values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});
	                        key = depth = 0;
	                        values = [];
	                        continue;
	                    }
	                // Simply skip the colon that separates the name and value
	                } else if (c === 58) { // ":"
	                    if (!depth && !key && values.length === 1) {
	                        key = values.pop();
	                        continue;
	                    }
	                // A set of slashes is initially matched as a regular expression, but could be division
	                } else if (c === 47 && i && tok.length > 1) {  // "/"
	                    // Look at the end of the previous token to determine if the slash is actually division
	                    var match = toks[i-1].match(divisionLookBehind);
	                    if (match && !keywordRegexLookBehind[match[0]]) {
	                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)
	                        str = str.substr(str.indexOf(tok) + 1);
	                        toks = str.match(bindingToken);
	                        toks.push(',');
	                        i = -1;
	                        // Continue with just the slash
	                        tok = '/';
	                    }
	                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
	                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
	                    ++depth;
	                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
	                    --depth;
	                // The key will be the first token; if it's a string, trim the quotes
	                } else if (!key && !values.length && (c === 34 || c === 39)) { // '"', "'"
	                    tok = tok.slice(1, -1);
	                }
	                values.push(tok);
	            }
	        }
	        return result;
	    }
	
	    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.
	    var twoWayBindings = {};
	
	    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
	        bindingOptions = bindingOptions || {};
	
	        function processKeyValue(key, val) {
	            var writableVal;
	            function callPreprocessHook(obj) {
	                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
	            }
	            if (!bindingParams) {
	                if (!callPreprocessHook(ko['getBindingHandler'](key)))
	                    return;
	
	                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {
	                    // For two-way bindings, provide a write method in case the value
	                    // isn't a writable observable.
	                    propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
	                }
	            }
	            // Values are wrapped in a function so that each value can be accessed independently
	            if (makeValueAccessors) {
	                val = 'function(){return ' + val + ' }';
	            }
	            resultStrings.push("'" + key + "':" + val);
	        }
	
	        var resultStrings = [],
	            propertyAccessorResultStrings = [],
	            makeValueAccessors = bindingOptions['valueAccessors'],
	            bindingParams = bindingOptions['bindingParams'],
	            keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
	                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;
	
	        ko.utils.arrayForEach(keyValueArray, function(keyValue) {
	            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
	        });
	
	        if (propertyAccessorResultStrings.length)
	            processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");
	
	        return resultStrings.join(",");
	    }
	
	    return {
	        bindingRewriteValidators: [],
	
	        twoWayBindings: twoWayBindings,
	
	        parseObjectLiteral: parseObjectLiteral,
	
	        preProcessBindings: preProcessBindings,
	
	        keyValueArrayContainsKey: function(keyValueArray, key) {
	            for (var i = 0; i < keyValueArray.length; i++)
	                if (keyValueArray[i]['key'] == key)
	                    return true;
	            return false;
	        },
	
	        // Internal, private KO utility for updating model properties from within bindings
	        // property:            If the property being updated is (or might be) an observable, pass it here
	        //                      If it turns out to be a writable observable, it will be written to directly
	        // allBindings:         An object with a get method to retrieve bindings in the current execution context.
	        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
	        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
	        // value:               The value to be written
	        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
	        //                      it is !== existing value on that writable observable
	        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
	            if (!property || !ko.isObservable(property)) {
	                var propWriters = allBindings.get('_ko_property_writers');
	                if (propWriters && propWriters[key])
	                    propWriters[key](value);
	            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {
	                property(value);
	            }
	        }
	    };
	})();
	
	ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
	ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
	ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
	ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);
	
	// Making bindings explicitly declare themselves as "two way" isn't ideal in the long term (it would be better if
	// all bindings could use an official 'property writer' API without needing to declare that they might). However,
	// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable
	// as an internal implementation detail in the short term.
	// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an
	// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official
	// public API, and we reserve the right to remove it at any time if we create a real public property writers API.
	ko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);
	
	// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
	// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
	ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
	ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);
	(function() {
	    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
	    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
	    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
	    // of that virtual hierarchy
	    //
	    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
	    // without having to scatter special cases all over the binding and templating code.
	
	    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
	    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
	    // So, use node.text where available, and node.nodeValue elsewhere
	    var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";
	
	    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;
	    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
	    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };
	
	    function isStartComment(node) {
	        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
	    }
	
	    function isEndComment(node) {
	        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
	    }
	
	    function getVirtualChildren(startComment, allowUnbalanced) {
	        var currentNode = startComment;
	        var depth = 1;
	        var children = [];
	        while (currentNode = currentNode.nextSibling) {
	            if (isEndComment(currentNode)) {
	                depth--;
	                if (depth === 0)
	                    return children;
	            }
	
	            children.push(currentNode);
	
	            if (isStartComment(currentNode))
	                depth++;
	        }
	        if (!allowUnbalanced)
	            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
	        return null;
	    }
	
	    function getMatchingEndComment(startComment, allowUnbalanced) {
	        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
	        if (allVirtualChildren) {
	            if (allVirtualChildren.length > 0)
	                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
	            return startComment.nextSibling;
	        } else
	            return null; // Must have no matching end comment, and allowUnbalanced is true
	    }
	
	    function getUnbalancedChildTags(node) {
	        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
	        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
	        var childNode = node.firstChild, captureRemaining = null;
	        if (childNode) {
	            do {
	                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
	                    captureRemaining.push(childNode);
	                else if (isStartComment(childNode)) {
	                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
	                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
	                        childNode = matchingEndComment;
	                    else
	                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
	                } else if (isEndComment(childNode)) {
	                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
	                }
	            } while (childNode = childNode.nextSibling);
	        }
	        return captureRemaining;
	    }
	
	    ko.virtualElements = {
	        allowedBindings: {},
	
	        childNodes: function(node) {
	            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
	        },
	
	        emptyNode: function(node) {
	            if (!isStartComment(node))
	                ko.utils.emptyDomNode(node);
	            else {
	                var virtualChildren = ko.virtualElements.childNodes(node);
	                for (var i = 0, j = virtualChildren.length; i < j; i++)
	                    ko.removeNode(virtualChildren[i]);
	            }
	        },
	
	        setDomNodeChildren: function(node, childNodes) {
	            if (!isStartComment(node))
	                ko.utils.setDomNodeChildren(node, childNodes);
	            else {
	                ko.virtualElements.emptyNode(node);
	                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
	                for (var i = 0, j = childNodes.length; i < j; i++)
	                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
	            }
	        },
	
	        prepend: function(containerNode, nodeToPrepend) {
	            if (!isStartComment(containerNode)) {
	                if (containerNode.firstChild)
	                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
	                else
	                    containerNode.appendChild(nodeToPrepend);
	            } else {
	                // Start comments must always have a parent and at least one following sibling (the end comment)
	                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
	            }
	        },
	
	        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
	            if (!insertAfterNode) {
	                ko.virtualElements.prepend(containerNode, nodeToInsert);
	            } else if (!isStartComment(containerNode)) {
	                // Insert after insertion point
	                if (insertAfterNode.nextSibling)
	                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
	                else
	                    containerNode.appendChild(nodeToInsert);
	            } else {
	                // Children of start comments must always have a parent and at least one following sibling (the end comment)
	                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
	            }
	        },
	
	        firstChild: function(node) {
	            if (!isStartComment(node))
	                return node.firstChild;
	            if (!node.nextSibling || isEndComment(node.nextSibling))
	                return null;
	            return node.nextSibling;
	        },
	
	        nextSibling: function(node) {
	            if (isStartComment(node))
	                node = getMatchingEndComment(node);
	            if (node.nextSibling && isEndComment(node.nextSibling))
	                return null;
	            return node.nextSibling;
	        },
	
	        hasBindingValue: isStartComment,
	
	        virtualNodeBindingValue: function(node) {
	            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
	            return regexMatch ? regexMatch[1] : null;
	        },
	
	        normaliseVirtualElementDomStructure: function(elementVerified) {
	            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
	            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
	            // that are direct descendants of <ul> into the preceding <li>)
	            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
	                return;
	
	            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
	            // must be intended to appear *after* that child, so move them there.
	            var childNode = elementVerified.firstChild;
	            if (childNode) {
	                do {
	                    if (childNode.nodeType === 1) {
	                        var unbalancedTags = getUnbalancedChildTags(childNode);
	                        if (unbalancedTags) {
	                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
	                            var nodeToInsertBefore = childNode.nextSibling;
	                            for (var i = 0; i < unbalancedTags.length; i++) {
	                                if (nodeToInsertBefore)
	                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
	                                else
	                                    elementVerified.appendChild(unbalancedTags[i]);
	                            }
	                        }
	                    }
	                } while (childNode = childNode.nextSibling);
	            }
	        }
	    };
	})();
	ko.exportSymbol('virtualElements', ko.virtualElements);
	ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
	ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
	//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
	ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
	//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
	ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
	ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
	(function() {
	    var defaultBindingAttributeName = "data-bind";
	
	    ko.bindingProvider = function() {
	        this.bindingCache = {};
	    };
	
	    ko.utils.extend(ko.bindingProvider.prototype, {
	        'nodeHasBindings': function(node) {
	            switch (node.nodeType) {
	                case 1: // Element
	                    return node.getAttribute(defaultBindingAttributeName) != null
	                        || ko.components['getComponentNameForNode'](node);
	                case 8: // Comment node
	                    return ko.virtualElements.hasBindingValue(node);
	                default: return false;
	            }
	        },
	
	        'getBindings': function(node, bindingContext) {
	            var bindingsString = this['getBindingsString'](node, bindingContext),
	                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
	            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
	        },
	
	        'getBindingAccessors': function(node, bindingContext) {
	            var bindingsString = this['getBindingsString'](node, bindingContext),
	                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
	            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
	        },
	
	        // The following function is only used internally by this default provider.
	        // It's not part of the interface definition for a general binding provider.
	        'getBindingsString': function(node, bindingContext) {
	            switch (node.nodeType) {
	                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
	                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
	                default: return null;
	            }
	        },
	
	        // The following function is only used internally by this default provider.
	        // It's not part of the interface definition for a general binding provider.
	        'parseBindingsString': function(bindingsString, bindingContext, node, options) {
	            try {
	                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
	                return bindingFunction(bindingContext, node);
	            } catch (ex) {
	                ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
	                throw ex;
	            }
	        }
	    });
	
	    ko.bindingProvider['instance'] = new ko.bindingProvider();
	
	    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {
	        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');
	        return cache[cacheKey]
	            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));
	    }
	
	    function createBindingsStringEvaluator(bindingsString, options) {
	        // Build the source for a function that evaluates "expression"
	        // For each scope variable, add an extra level of "with" nesting
	        // Example result: with(sc1) { with(sc0) { return (expression) } }
	        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
	            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
	        return new Function("$context", "$element", functionBody);
	    }
	})();
	
	ko.exportSymbol('bindingProvider', ko.bindingProvider);
	(function () {
	    ko.bindingHandlers = {};
	
	    // The following element types will not be recursed into during binding.
	    var bindingDoesNotRecurseIntoElementTypes = {
	        // Don't want bindings that operate on text nodes to mutate <script> and <textarea> contents,
	        // because it's unexpected and a potential XSS issue.
	        // Also bindings should not operate on <template> elements since this breaks in Internet Explorer
	        // and because such elements' contents are always intended to be bound in a different context
	        // from where they appear in the document.
	        'script': true,
	        'textarea': true,
	        'template': true
	    };
	
	    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
	    ko['getBindingHandler'] = function(bindingKey) {
	        return ko.bindingHandlers[bindingKey];
	    };
	
	    // The ko.bindingContext constructor is only called directly to create the root context. For child
	    // contexts, use bindingContext.createChildContext or bindingContext.extend.
	    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {
	
	        // The binding context object includes static properties for the current, parent, and root view models.
	        // If a view model is actually stored in an observable, the corresponding binding context object, and
	        // any child contexts, must be updated when the view model is changed.
	        function updateContext() {
	            // Most of the time, the context will directly get a view model object, but if a function is given,
	            // we call the function to retrieve the view model. If the function accesses any observables or returns
	            // an observable, the dependency is tracked, and those observables can later cause the binding
	            // context to be updated.
	            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
	                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);
	
	            if (parentContext) {
	                // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
	                // parent context is updated, this context will also be updated.
	                if (parentContext._subscribable)
	                    parentContext._subscribable();
	
	                // Copy $root and any custom properties from the parent context
	                ko.utils.extend(self, parentContext);
	
	                // Because the above copy overwrites our own properties, we need to reset them.
	                self._subscribable = subscribable;
	            } else {
	                self['$parents'] = [];
	                self['$root'] = dataItem;
	
	                // Export 'ko' in the binding context so it will be available in bindings and templates
	                // even if 'ko' isn't exported as a global, such as when using an AMD loader.
	                // See https://github.com/SteveSanderson/knockout/issues/490
	                self['ko'] = ko;
	            }
	            self['$rawData'] = dataItemOrObservable;
	            self['$data'] = dataItem;
	            if (dataItemAlias)
	                self[dataItemAlias] = dataItem;
	
	            // The extendCallback function is provided when creating a child context or extending a context.
	            // It handles the specific actions needed to finish setting up the binding context. Actions in this
	            // function could also add dependencies to this binding context.
	            if (extendCallback)
	                extendCallback(self, parentContext, dataItem);
	
	            return self['$data'];
	        }
	        function disposeWhen() {
	            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
	        }
	
	        var self = this,
	            isFunc = typeof(dataItemOrAccessor) == "function" && !ko.isObservable(dataItemOrAccessor),
	            nodes,
	            subscribable;
	
	        if (options && options['exportDependencies']) {
	            // The "exportDependencies" option means that the calling code will track any dependencies and re-create
	            // the binding context when they change.
	            updateContext();
	        } else {
	            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });
	
	            // At this point, the binding context has been initialized, and the "subscribable" computed observable is
	            // subscribed to any observables that were accessed in the process. If there is nothing to track, the
	            // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
	            // the context object.
	            if (subscribable.isActive()) {
	                self._subscribable = subscribable;
	
	                // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
	                subscribable['equalityComparer'] = null;
	
	                // We need to be able to dispose of this computed observable when it's no longer needed. This would be
	                // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
	                // we cannot assume that those nodes have any relation to each other. So instead we track any node that
	                // the context is attached to, and dispose the computed when all of those nodes have been cleaned.
	
	                // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates
	                nodes = [];
	                subscribable._addNode = function(node) {
	                    nodes.push(node);
	                    ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {
	                        ko.utils.arrayRemoveItem(nodes, node);
	                        if (!nodes.length) {
	                            subscribable.dispose();
	                            self._subscribable = subscribable = undefined;
	                        }
	                    });
	                };
	            }
	        }
	    }
	
	    // Extend the binding context hierarchy with a new view model object. If the parent context is watching
	    // any observables, the new child context will automatically get a dependency on the parent context.
	    // But this does not mean that the $data value of the child context will also get updated. If the child
	    // view model also depends on the parent view model, you must provide a function that returns the correct
	    // view model on each update.
	    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {
	        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
	            // Extend the context hierarchy by setting the appropriate pointers
	            self['$parentContext'] = parentContext;
	            self['$parent'] = parentContext['$data'];
	            self['$parents'] = (parentContext['$parents'] || []).slice(0);
	            self['$parents'].unshift(self['$parent']);
	            if (extendCallback)
	                extendCallback(self);
	        }, options);
	    };
	
	    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.
	    // Similarly to "child" contexts, provide a function here to make sure that the correct values are set
	    // when an observable view model is updated.
	    ko.bindingContext.prototype['extend'] = function(properties) {
	        // If the parent context references an observable view model, "_subscribable" will always be the
	        // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
	        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
	            // This "child" context doesn't directly track a parent observable view model,
	            // so we need to manually set the $rawData value to match the parent.
	            self['$rawData'] = parentContext['$rawData'];
	            ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
	        });
	    };
	
	    ko.bindingContext.prototype.createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {
	        return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { "exportDependencies": true });
	    };
	
	    // Returns the valueAccesor function for a binding value
	    function makeValueAccessor(value) {
	        return function() {
	            return value;
	        };
	    }
	
	    // Returns the value of a valueAccessor function
	    function evaluateValueAccessor(valueAccessor) {
	        return valueAccessor();
	    }
	
	    // Given a function that returns bindings, create and return a new object that contains
	    // binding value-accessors functions. Each accessor function calls the original function
	    // so that it always gets the latest value and all dependencies are captured. This is used
	    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
	    function makeAccessorsFromFunction(callback) {
	        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {
	            return function() {
	                return callback()[key];
	            };
	        });
	    }
	
	    // Given a bindings function or object, create and return a new object that contains
	    // binding value-accessors functions. This is used by ko.applyBindingsToNode.
	    function makeBindingAccessors(bindings, context, node) {
	        if (typeof bindings === 'function') {
	            return makeAccessorsFromFunction(bindings.bind(null, context, node));
	        } else {
	            return ko.utils.objectMap(bindings, makeValueAccessor);
	        }
	    }
	
	    // This function is used if the binding provider doesn't include a getBindingAccessors function.
	    // It must be called with 'this' set to the provider instance.
	    function getBindingsAndMakeAccessors(node, context) {
	        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));
	    }
	
	    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
	        var validator = ko.virtualElements.allowedBindings[bindingName];
	        if (!validator)
	            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
	    }
	
	    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
	        var currentChild,
	            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),
	            provider = ko.bindingProvider['instance'],
	            preprocessNode = provider['preprocessNode'];
	
	        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
	        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
	        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
	        // trigger insertion of <template> contents at that point in the document.
	        if (preprocessNode) {
	            while (currentChild = nextInQueue) {
	                nextInQueue = ko.virtualElements.nextSibling(currentChild);
	                preprocessNode.call(provider, currentChild);
	            }
	            // Reset nextInQueue for the next loop
	            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
	        }
	
	        while (currentChild = nextInQueue) {
	            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
	            nextInQueue = ko.virtualElements.nextSibling(currentChild);
	            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);
	        }
	    }
	
	    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {
	        var shouldBindDescendants = true;
	
	        // Perf optimisation: Apply bindings only if...
	        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
	        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
	        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
	        var isElement = (nodeVerified.nodeType === 1);
	        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
	            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);
	
	        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
	                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
	        if (shouldApplyBindings)
	            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];
	
	        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {
	            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
	            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
	            //    hence bindingContextsMayDifferFromDomParentElement is false
	            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
	            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
	            //    hence bindingContextsMayDifferFromDomParentElement is true
	            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
	        }
	    }
	
	    var boundElementDomDataKey = ko.utils.domData.nextKey();
	
	
	    function topologicalSortBindings(bindings) {
	        // Depth-first sort
	        var result = [],                // The list of key/handler pairs that we will return
	            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
	            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
	        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
	            if (!bindingsConsidered[bindingKey]) {
	                var binding = ko['getBindingHandler'](bindingKey);
	                if (binding) {
	                    // First add dependencies (if any) of the current binding
	                    if (binding['after']) {
	                        cyclicDependencyStack.push(bindingKey);
	                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
	                            if (bindings[bindingDependencyKey]) {
	                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
	                                    throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
	                                } else {
	                                    pushBinding(bindingDependencyKey);
	                                }
	                            }
	                        });
	                        cyclicDependencyStack.length--;
	                    }
	                    // Next add the current binding
	                    result.push({ key: bindingKey, handler: binding });
	                }
	                bindingsConsidered[bindingKey] = true;
	            }
	        });
	
	        return result;
	    }
	
	    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {
	        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified
	        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);
	        if (!sourceBindings) {
	            if (alreadyBound) {
	                throw Error("You cannot apply bindings multiple times to the same element.");
	            }
	            ko.utils.domData.set(node, boundElementDomDataKey, true);
	        }
	
	        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
	        // we can easily recover it just by scanning up the node's ancestors in the DOM
	        // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
	        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)
	            ko.storedBindingContextForNode(node, bindingContext);
	
	        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
	        var bindings;
	        if (sourceBindings && typeof sourceBindings !== 'function') {
	            bindings = sourceBindings;
	        } else {
	            var provider = ko.bindingProvider['instance'],
	                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;
	
	            // Get the binding from the provider within a computed observable so that we can update the bindings whenever
	            // the binding context is updated or if the binding provider accesses observables.
	            var bindingsUpdater = ko.dependentObservable(
	                function() {
	                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);
	                    // Register a dependency on the binding context to support observable view models.
	                    if (bindings && bindingContext._subscribable)
	                        bindingContext._subscribable();
	                    return bindings;
	                },
	                null, { disposeWhenNodeIsRemoved: node }
	            );
	
	            if (!bindings || !bindingsUpdater.isActive())
	                bindingsUpdater = null;
	        }
	
	        var bindingHandlerThatControlsDescendantBindings;
	        if (bindings) {
	            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
	            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets
	            // the latest binding value and registers a dependency on the binding updater.
	            var getValueAccessor = bindingsUpdater
	                ? function(bindingKey) {
	                    return function() {
	                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);
	                    };
	                } : function(bindingKey) {
	                    return bindings[bindingKey];
	                };
	
	            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
	            function allBindings() {
	                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);
	            }
	            // The following is the 3.x allBindings API
	            allBindings['get'] = function(key) {
	                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));
	            };
	            allBindings['has'] = function(key) {
	                return key in bindings;
	            };
	
	            // First put the bindings into the right order
	            var orderedBindings = topologicalSortBindings(bindings);
	
	            // Go through the sorted bindings, calling init and update for each
	            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {
	                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,
	                // so bindingKeyAndHandler.handler will always be nonnull.
	                var handlerInitFn = bindingKeyAndHandler.handler["init"],
	                    handlerUpdateFn = bindingKeyAndHandler.handler["update"],
	                    bindingKey = bindingKeyAndHandler.key;
	
	                if (node.nodeType === 8) {
	                    validateThatBindingIsAllowedForVirtualElements(bindingKey);
	                }
	
	                try {
	                    // Run init, ignoring any dependencies
	                    if (typeof handlerInitFn == "function") {
	                        ko.dependencyDetection.ignore(function() {
	                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
	
	                            // If this binding handler claims to control descendant bindings, make a note of this
	                            if (initResult && initResult['controlsDescendantBindings']) {
	                                if (bindingHandlerThatControlsDescendantBindings !== undefined)
	                                    throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
	                                bindingHandlerThatControlsDescendantBindings = bindingKey;
	                            }
	                        });
	                    }
	
	                    // Run update in its own computed wrapper
	                    if (typeof handlerUpdateFn == "function") {
	                        ko.dependentObservable(
	                            function() {
	                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
	                            },
	                            null,
	                            { disposeWhenNodeIsRemoved: node }
	                        );
	                    }
	                } catch (ex) {
	                    ex.message = "Unable to process binding \"" + bindingKey + ": " + bindings[bindingKey] + "\"\nMessage: " + ex.message;
	                    throw ex;
	                }
	            });
	        }
	
	        return {
	            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
	        };
	    };
	
	    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();
	    ko.storedBindingContextForNode = function (node, bindingContext) {
	        if (arguments.length == 2) {
	            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
	            if (bindingContext._subscribable)
	                bindingContext._subscribable._addNode(node);
	        } else {
	            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
	        }
	    }
	
	    function getBindingContext(viewModelOrBindingContext) {
	        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
	            ? viewModelOrBindingContext
	            : new ko.bindingContext(viewModelOrBindingContext);
	    }
	
	    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
	        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
	            ko.virtualElements.normaliseVirtualElementDomStructure(node);
	        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
	    };
	
	    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
	        var context = getBindingContext(viewModelOrBindingContext);
	        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
	    };
	
	    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {
	        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
	            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
	    };
	
	    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {
	        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
	        if (!jQueryInstance && window['jQuery']) {
	            jQueryInstance = window['jQuery'];
	        }
	
	        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
	            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
	        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional
	
	        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
	    };
	
	    // Retrieving binding context from arbitrary nodes
	    ko.contextFor = function(node) {
	        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
	        switch (node.nodeType) {
	            case 1:
	            case 8:
	                var context = ko.storedBindingContextForNode(node);
	                if (context) return context;
	                if (node.parentNode) return ko.contextFor(node.parentNode);
	                break;
	        }
	        return undefined;
	    };
	    ko.dataFor = function(node) {
	        var context = ko.contextFor(node);
	        return context ? context['$data'] : undefined;
	    };
	
	    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
	    ko.exportSymbol('applyBindings', ko.applyBindings);
	    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
	    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);
	    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
	    ko.exportSymbol('contextFor', ko.contextFor);
	    ko.exportSymbol('dataFor', ko.dataFor);
	})();
	(function(undefined) {
	    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight
	        loadedDefinitionsCache = {};    // Tracks component loads that have already completed
	
	    ko.components = {
	        get: function(componentName, callback) {
	            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
	            if (cachedDefinition) {
	                // It's already loaded and cached. Reuse the same definition object.
	                // Note that for API consistency, even cache hits complete asynchronously by default.
	                // You can bypass this by putting synchronous:true on your component config.
	                if (cachedDefinition.isSynchronousComponent) {
	                    ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning
	                        callback(cachedDefinition.definition);
	                    });
	                } else {
	                    ko.tasks.schedule(function() { callback(cachedDefinition.definition); });
	                }
	            } else {
	                // Join the loading process that is already underway, or start a new one.
	                loadComponentAndNotify(componentName, callback);
	            }
	        },
	
	        clearCachedDefinition: function(componentName) {
	            delete loadedDefinitionsCache[componentName];
	        },
	
	        _getFirstResultFromLoaders: getFirstResultFromLoaders
	    };
	
	    function getObjectOwnProperty(obj, propName) {
	        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;
	    }
	
	    function loadComponentAndNotify(componentName, callback) {
	        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),
	            completedAsync;
	        if (!subscribable) {
	            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.
	            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();
	            subscribable.subscribe(callback);
	
	            beginLoadingComponent(componentName, function(definition, config) {
	                var isSynchronousComponent = !!(config && config['synchronous']);
	                loadedDefinitionsCache[componentName] = { definition: definition, isSynchronousComponent: isSynchronousComponent };
	                delete loadingSubscribablesCache[componentName];
	
	                // For API consistency, all loads complete asynchronously. However we want to avoid
	                // adding an extra task schedule if it's unnecessary (i.e., the completion is already
	                // async).
	                //
	                // You can bypass the 'always asynchronous' feature by putting the synchronous:true
	                // flag on your component configuration when you register it.
	                if (completedAsync || isSynchronousComponent) {
	                    // Note that notifySubscribers ignores any dependencies read within the callback.
	                    // See comment in loaderRegistryBehaviors.js for reasoning
	                    subscribable['notifySubscribers'](definition);
	                } else {
	                    ko.tasks.schedule(function() {
	                        subscribable['notifySubscribers'](definition);
	                    });
	                }
	            });
	            completedAsync = true;
	        } else {
	            subscribable.subscribe(callback);
	        }
	    }
	
	    function beginLoadingComponent(componentName, callback) {
	        getFirstResultFromLoaders('getConfig', [componentName], function(config) {
	            if (config) {
	                // We have a config, so now load its definition
	                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {
	                    callback(definition, config);
	                });
	            } else {
	                // The component has no config - it's unknown to all the loaders.
	                // Note that this is not an error (e.g., a module loading error) - that would abort the
	                // process and this callback would not run. For this callback to run, all loaders must
	                // have confirmed they don't know about this component.
	                callback(null, null);
	            }
	        });
	    }
	
	    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
	        // On the first call in the stack, start with the full set of loaders
	        if (!candidateLoaders) {
	            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
	        }
	
	        // Try the next candidate
	        var currentCandidateLoader = candidateLoaders.shift();
	        if (currentCandidateLoader) {
	            var methodInstance = currentCandidateLoader[methodName];
	            if (methodInstance) {
	                var wasAborted = false,
	                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
	                        if (wasAborted) {
	                            callback(null);
	                        } else if (result !== null) {
	                            // This candidate returned a value. Use it.
	                            callback(result);
	                        } else {
	                            // Try the next candidate
	                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
	                        }
	                    }));
	
	                // Currently, loaders may not return anything synchronously. This leaves open the possibility
	                // that we'll extend the API to support synchronous return values in the future. It won't be
	                // a breaking change, because currently no loader is allowed to return anything except undefined.
	                if (synchronousReturnValue !== undefined) {
	                    wasAborted = true;
	
	                    // Method to suppress exceptions will remain undocumented. This is only to keep
	                    // KO's specs running tidily, since we can observe the loading got aborted without
	                    // having exceptions cluttering up the console too.
	                    if (!currentCandidateLoader['suppressLoaderExceptions']) {
	                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');
	                    }
	                }
	            } else {
	                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
	                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
	            }
	        } else {
	            // No candidates returned a value
	            callback(null);
	        }
	    }
	
	    // Reference the loaders via string name so it's possible for developers
	    // to replace the whole array by assigning to ko.components.loaders
	    ko.components['loaders'] = [];
	
	    ko.exportSymbol('components', ko.components);
	    ko.exportSymbol('components.get', ko.components.get);
	    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);
	})();
	(function(undefined) {
	
	    // The default loader is responsible for two things:
	    // 1. Maintaining the default in-memory registry of component configuration objects
	    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
	    // 2. Answering requests for components by fetching configuration objects
	    //    from that default in-memory registry and resolving them into standard
	    //    component definition objects (of the form { createViewModel: ..., template: ... })
	    // Custom loaders may override either of these facilities, i.e.,
	    // 1. To supply configuration objects from some other source (e.g., conventions)
	    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.
	
	    var defaultConfigRegistry = {};
	
	    ko.components.register = function(componentName, config) {
	        if (!config) {
	            throw new Error('Invalid configuration for ' + componentName);
	        }
	
	        if (ko.components.isRegistered(componentName)) {
	            throw new Error('Component ' + componentName + ' is already registered');
	        }
	
	        defaultConfigRegistry[componentName] = config;
	    };
	
	    ko.components.isRegistered = function(componentName) {
	        return defaultConfigRegistry.hasOwnProperty(componentName);
	    };
	
	    ko.components.unregister = function(componentName) {
	        delete defaultConfigRegistry[componentName];
	        ko.components.clearCachedDefinition(componentName);
	    };
	
	    ko.components.defaultLoader = {
	        'getConfig': function(componentName, callback) {
	            var result = defaultConfigRegistry.hasOwnProperty(componentName)
	                ? defaultConfigRegistry[componentName]
	                : null;
	            callback(result);
	        },
	
	        'loadComponent': function(componentName, config, callback) {
	            var errorCallback = makeErrorCallback(componentName);
	            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
	                resolveConfig(componentName, errorCallback, loadedConfig, callback);
	            });
	        },
	
	        'loadTemplate': function(componentName, templateConfig, callback) {
	            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
	        },
	
	        'loadViewModel': function(componentName, viewModelConfig, callback) {
	            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
	        }
	    };
	
	    var createViewModelKey = 'createViewModel';
	
	    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
	    // into the standard component definition format:
	    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
	    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
	    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
	    // so this is implemented manually below.
	    function resolveConfig(componentName, errorCallback, config, callback) {
	        var result = {},
	            makeCallBackWhenZero = 2,
	            tryIssueCallback = function() {
	                if (--makeCallBackWhenZero === 0) {
	                    callback(result);
	                }
	            },
	            templateConfig = config['template'],
	            viewModelConfig = config['viewModel'];
	
	        if (templateConfig) {
	            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {
	                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {
	                    result['template'] = resolvedTemplate;
	                    tryIssueCallback();
	                });
	            });
	        } else {
	            tryIssueCallback();
	        }
	
	        if (viewModelConfig) {
	            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {
	                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {
	                    result[createViewModelKey] = resolvedViewModel;
	                    tryIssueCallback();
	                });
	            });
	        } else {
	            tryIssueCallback();
	        }
	    }
	
	    function resolveTemplate(errorCallback, templateConfig, callback) {
	        if (typeof templateConfig === 'string') {
	            // Markup - parse it
	            callback(ko.utils.parseHtmlFragment(templateConfig));
	        } else if (templateConfig instanceof Array) {
	            // Assume already an array of DOM nodes - pass through unchanged
	            callback(templateConfig);
	        } else if (isDocumentFragment(templateConfig)) {
	            // Document fragment - use its child nodes
	            callback(ko.utils.makeArray(templateConfig.childNodes));
	        } else if (templateConfig['element']) {
	            var element = templateConfig['element'];
	            if (isDomElement(element)) {
	                // Element instance - copy its child nodes
	                callback(cloneNodesFromTemplateSourceElement(element));
	            } else if (typeof element === 'string') {
	                // Element ID - find it, then copy its child nodes
	                var elemInstance = document.getElementById(element);
	                if (elemInstance) {
	                    callback(cloneNodesFromTemplateSourceElement(elemInstance));
	                } else {
	                    errorCallback('Cannot find element with ID ' + element);
	                }
	            } else {
	                errorCallback('Unknown element type: ' + element);
	            }
	        } else {
	            errorCallback('Unknown template value: ' + templateConfig);
	        }
	    }
	
	    function resolveViewModel(errorCallback, viewModelConfig, callback) {
	        if (typeof viewModelConfig === 'function') {
	            // Constructor - convert to standard factory function format
	            // By design, this does *not* supply componentInfo to the constructor, as the intent is that
	            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only
	            // be used in factory functions, not viewmodel constructors.
	            callback(function (params /*, componentInfo */) {
	                return new viewModelConfig(params);
	            });
	        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {
	            // Already a factory function - use it as-is
	            callback(viewModelConfig[createViewModelKey]);
	        } else if ('instance' in viewModelConfig) {
	            // Fixed object instance - promote to createViewModel format for API consistency
	            var fixedInstance = viewModelConfig['instance'];
	            callback(function (params, componentInfo) {
	                return fixedInstance;
	            });
	        } else if ('viewModel' in viewModelConfig) {
	            // Resolved AMD module whose value is of the form { viewModel: ... }
	            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);
	        } else {
	            errorCallback('Unknown viewModel value: ' + viewModelConfig);
	        }
	    }
	
	    function cloneNodesFromTemplateSourceElement(elemInstance) {
	        switch (ko.utils.tagNameLower(elemInstance)) {
	            case 'script':
	                return ko.utils.parseHtmlFragment(elemInstance.text);
	            case 'textarea':
	                return ko.utils.parseHtmlFragment(elemInstance.value);
	            case 'template':
	                // For browsers with proper <template> element support (i.e., where the .content property
	                // gives a document fragment), use that document fragment.
	                if (isDocumentFragment(elemInstance.content)) {
	                    return ko.utils.cloneNodes(elemInstance.content.childNodes);
	                }
	        }
	
	        // Regular elements such as <div>, and <template> elements on old browsers that don't really
	        // understand <template> and just treat it as a regular container
	        return ko.utils.cloneNodes(elemInstance.childNodes);
	    }
	
	    function isDomElement(obj) {
	        if (window['HTMLElement']) {
	            return obj instanceof HTMLElement;
	        } else {
	            return obj && obj.tagName && obj.nodeType === 1;
	        }
	    }
	
	    function isDocumentFragment(obj) {
	        if (window['DocumentFragment']) {
	            return obj instanceof DocumentFragment;
	        } else {
	            return obj && obj.nodeType === 11;
	        }
	    }
	
	    function possiblyGetConfigFromAmd(errorCallback, config, callback) {
	        if (typeof config['require'] === 'string') {
	            // The config is the value of an AMD module
	            if (amdRequire || window['require']) {
	                (amdRequire || window['require'])([config['require']], callback);
	            } else {
	                errorCallback('Uses require, but no AMD loader is present');
	            }
	        } else {
	            callback(config);
	        }
	    }
	
	    function makeErrorCallback(componentName) {
	        return function (message) {
	            throw new Error('Component \'' + componentName + '\': ' + message);
	        };
	    }
	
	    ko.exportSymbol('components.register', ko.components.register);
	    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);
	    ko.exportSymbol('components.unregister', ko.components.unregister);
	
	    // Expose the default loader so that developers can directly ask it for configuration
	    // or to resolve configuration
	    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);
	
	    // By default, the default loader is the only registered component loader
	    ko.components['loaders'].push(ko.components.defaultLoader);
	
	    // Privately expose the underlying config registry for use in old-IE shim
	    ko.components._allRegisteredComponents = defaultConfigRegistry;
	})();
	(function (undefined) {
	    // Overridable API for determining which component name applies to a given node. By overriding this,
	    // you can for example map specific tagNames to components that are not preregistered.
	    ko.components['getComponentNameForNode'] = function(node) {
	        var tagNameLower = ko.utils.tagNameLower(node);
	        if (ko.components.isRegistered(tagNameLower)) {
	            // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues/1603
	            if (tagNameLower.indexOf('-') != -1 || ('' + node) == "[object HTMLUnknownElement]" || (ko.utils.ieVersion <= 8 && node.tagName === tagNameLower)) {
	                return tagNameLower;
	            }
	        }
	    };
	
	    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {
	        // Determine if it's really a custom element matching a component
	        if (node.nodeType === 1) {
	            var componentName = ko.components['getComponentNameForNode'](node);
	            if (componentName) {
	                // It does represent a component, so add a component binding for it
	                allBindings = allBindings || {};
	
	                if (allBindings['component']) {
	                    // Avoid silently overwriting some other 'component' binding that may already be on the element
	                    throw new Error('Cannot use the "component" binding on a custom element matching a component');
	                }
	
	                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };
	
	                allBindings['component'] = valueAccessors
	                    ? function() { return componentBindingValue; }
	                    : componentBindingValue;
	            }
	        }
	
	        return allBindings;
	    }
	
	    var nativeBindingProviderInstance = new ko.bindingProvider();
	
	    function getComponentParamsFromCustomElement(elem, bindingContext) {
	        var paramsAttribute = elem.getAttribute('params');
	
	        if (paramsAttribute) {
	            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),
	                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {
	                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });
	                }),
	                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {
	                    var paramValue = paramValueComputed.peek();
	                    // Does the evaluation of the parameter value unwrap any observables?
	                    if (!paramValueComputed.isActive()) {
	                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
	                        // Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
	                        return paramValue;
	                    } else {
	                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)
	                        // level of observability, and any inner (resulting model value) level of observability.
	                        // This means the component doesn't have to worry about multiple unwrapping. If the value is a
	                        // writable observable, the computed will also be writable and pass the value on to the observable.
	                        return ko.computed({
	                            'read': function() {
	                                return ko.utils.unwrapObservable(paramValueComputed());
	                            },
	                            'write': ko.isWriteableObservable(paramValue) && function(value) {
	                                paramValueComputed()(value);
	                            },
	                            disposeWhenNodeIsRemoved: elem
	                        });
	                    }
	                });
	
	            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'
	            // This is in case the developer wants to react to outer (binding) observability separately from inner
	            // (model value) observability, or in case the model value observable has subobservables.
	            if (!result.hasOwnProperty('$raw')) {
	                result['$raw'] = rawParamComputedValues;
	            }
	
	            return result;
	        } else {
	            // For consistency, absence of a "params" attribute is treated the same as the presence of
	            // any empty one. Otherwise component viewmodels need special code to check whether or not
	            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.
	            return { '$raw': {} };
	        }
	    }
	
	    // --------------------------------------------------------------------------------
	    // Compatibility code for older (pre-HTML5) IE browsers
	
	    if (ko.utils.ieVersion < 9) {
	        // Whenever you preregister a component, enable it as a custom element in the current document
	        ko.components['register'] = (function(originalFunction) {
	            return function(componentName) {
	                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element
	                return originalFunction.apply(this, arguments);
	            }
	        })(ko.components['register']);
	
	        // Whenever you create a document fragment, enable all preregistered component names as custom elements
	        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements
	        document.createDocumentFragment = (function(originalFunction) {
	            return function() {
	                var newDocFrag = originalFunction(),
	                    allComponents = ko.components._allRegisteredComponents;
	                for (var componentName in allComponents) {
	                    if (allComponents.hasOwnProperty(componentName)) {
	                        newDocFrag.createElement(componentName);
	                    }
	                }
	                return newDocFrag;
	            };
	        })(document.createDocumentFragment);
	    }
	})();(function(undefined) {
	
	    var componentLoadingOperationUniqueId = 0;
	
	    ko.bindingHandlers['component'] = {
	        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {
	            var currentViewModel,
	                currentLoadingOperationId,
	                disposeAssociatedComponentViewModel = function () {
	                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];
	                    if (typeof currentViewModelDispose === 'function') {
	                        currentViewModelDispose.call(currentViewModel);
	                    }
	                    currentViewModel = null;
	                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion
	                    currentLoadingOperationId = null;
	                },
	                originalChildNodes = ko.utils.makeArray(ko.virtualElements.childNodes(element));
	
	            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);
	
	            ko.computed(function () {
	                var value = ko.utils.unwrapObservable(valueAccessor()),
	                    componentName, componentParams;
	
	                if (typeof value === 'string') {
	                    componentName = value;
	                } else {
	                    componentName = ko.utils.unwrapObservable(value['name']);
	                    componentParams = ko.utils.unwrapObservable(value['params']);
	                }
	
	                if (!componentName) {
	                    throw new Error('No component name specified');
	                }
	
	                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;
	                ko.components.get(componentName, function(componentDefinition) {
	                    // If this is not the current load operation for this element, ignore it.
	                    if (currentLoadingOperationId !== loadingOperationId) {
	                        return;
	                    }
	
	                    // Clean up previous state
	                    disposeAssociatedComponentViewModel();
	
	                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
	                    if (!componentDefinition) {
	                        throw new Error('Unknown component \'' + componentName + '\'');
	                    }
	                    cloneTemplateIntoElement(componentName, componentDefinition, element);
	                    var componentViewModel = createViewModel(componentDefinition, element, originalChildNodes, componentParams),
	                        childBindingContext = bindingContext['createChildContext'](componentViewModel, /* dataItemAlias */ undefined, function(ctx) {
	                            ctx['$component'] = componentViewModel;
	                            ctx['$componentTemplateNodes'] = originalChildNodes;
	                        });
	                    currentViewModel = componentViewModel;
	                    ko.applyBindingsToDescendants(childBindingContext, element);
	                });
	            }, null, { disposeWhenNodeIsRemoved: element });
	
	            return { 'controlsDescendantBindings': true };
	        }
	    };
	
	    ko.virtualElements.allowedBindings['component'] = true;
	
	    function cloneTemplateIntoElement(componentName, componentDefinition, element) {
	        var template = componentDefinition['template'];
	        if (!template) {
	            throw new Error('Component \'' + componentName + '\' has no template');
	        }
	
	        var clonedNodesArray = ko.utils.cloneNodes(template);
	        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);
	    }
	
	    function createViewModel(componentDefinition, element, originalChildNodes, componentParams) {
	        var componentViewModelFactory = componentDefinition['createViewModel'];
	        return componentViewModelFactory
	            ? componentViewModelFactory.call(componentDefinition, componentParams, { 'element': element, 'templateNodes': originalChildNodes })
	            : componentParams; // Template-only component
	    }
	
	})();
	var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
	ko.bindingHandlers['attr'] = {
	    'update': function(element, valueAccessor, allBindings) {
	        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
	        ko.utils.objectForEach(value, function(attrName, attrValue) {
	            attrValue = ko.utils.unwrapObservable(attrValue);
	
	            // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
	            // when someProp is a "no value"-like value (strictly null, false, or undefined)
	            // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
	            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
	            if (toRemove)
	                element.removeAttribute(attrName);
	
	            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
	            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
	            // but instead of figuring out the mode, we'll just set the attribute through the Javascript
	            // property for IE <= 8.
	            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
	                attrName = attrHtmlToJavascriptMap[attrName];
	                if (toRemove)
	                    element.removeAttribute(attrName);
	                else
	                    element[attrName] = attrValue;
	            } else if (!toRemove) {
	                element.setAttribute(attrName, attrValue.toString());
	            }
	
	            // Treat "name" specially - although you can think of it as an attribute, it also needs
	            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
	            // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
	            // entirely, and there's no strong reason to allow for such casing in HTML.
	            if (attrName === "name") {
	                ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
	            }
	        });
	    }
	};
	(function() {
	
	ko.bindingHandlers['checked'] = {
	    'after': ['value', 'attr'],
	    'init': function (element, valueAccessor, allBindings) {
	        var checkedValue = ko.pureComputed(function() {
	            // Treat "value" like "checkedValue" when it is included with "checked" binding
	            if (allBindings['has']('checkedValue')) {
	                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));
	            } else if (allBindings['has']('value')) {
	                return ko.utils.unwrapObservable(allBindings.get('value'));
	            }
	
	            return element.value;
	        });
	
	        function updateModel() {
	            // This updates the model value from the view value.
	            // It runs in response to DOM events (click) and changes in checkedValue.
	            var isChecked = element.checked,
	                elemValue = useCheckedValue ? checkedValue() : isChecked;
	
	            // When we're first setting up this computed, don't change any model state.
	            if (ko.computedContext.isInitial()) {
	                return;
	            }
	
	            // We can ignore unchecked radio buttons, because some other radio
	            // button will be getting checked, and that one can take care of updating state.
	            if (isRadio && !isChecked) {
	                return;
	            }
	
	            var modelValue = ko.dependencyDetection.ignore(valueAccessor);
	            if (valueIsArray) {
	                var writableValue = rawValueIsNonArrayObservable ? modelValue.peek() : modelValue;
	                if (oldElemValue !== elemValue) {
	                    // When we're responding to the checkedValue changing, and the element is
	                    // currently checked, replace the old elem value with the new elem value
	                    // in the model array.
	                    if (isChecked) {
	                        ko.utils.addOrRemoveItem(writableValue, elemValue, true);
	                        ko.utils.addOrRemoveItem(writableValue, oldElemValue, false);
	                    }
	
	                    oldElemValue = elemValue;
	                } else {
	                    // When we're responding to the user having checked/unchecked a checkbox,
	                    // add/remove the element value to the model array.
	                    ko.utils.addOrRemoveItem(writableValue, elemValue, isChecked);
	                }
	                if (rawValueIsNonArrayObservable && ko.isWriteableObservable(modelValue)) {
	                    modelValue(writableValue);
	                }
	            } else {
	                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);
	            }
	        };
	
	        function updateView() {
	            // This updates the view value from the model value.
	            // It runs in response to changes in the bound (checked) value.
	            var modelValue = ko.utils.unwrapObservable(valueAccessor());
	
	            if (valueIsArray) {
	                // When a checkbox is bound to an array, being checked represents its value being present in that array
	                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;
	            } else if (isCheckbox) {
	                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish
	                element.checked = modelValue;
	            } else {
	                // For radio buttons, being checked means that the radio button's value corresponds to the model value
	                element.checked = (checkedValue() === modelValue);
	            }
	        };
	
	        var isCheckbox = element.type == "checkbox",
	            isRadio = element.type == "radio";
	
	        // Only bind to check boxes and radio buttons
	        if (!isCheckbox && !isRadio) {
	            return;
	        }
	
	        var rawValue = valueAccessor(),
	            valueIsArray = isCheckbox && (ko.utils.unwrapObservable(rawValue) instanceof Array),
	            rawValueIsNonArrayObservable = !(valueIsArray && rawValue.push && rawValue.splice),
	            oldElemValue = valueIsArray ? checkedValue() : undefined,
	            useCheckedValue = isRadio || valueIsArray;
	
	        // IE 6 won't allow radio buttons to be selected unless they have a name
	        if (isRadio && !element.name)
	            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });
	
	        // Set up two computeds to update the binding:
	
	        // The first responds to changes in the checkedValue value and to element clicks
	        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });
	        ko.utils.registerEventHandler(element, "click", updateModel);
	
	        // The second responds to changes in the model value (the one associated with the checked binding)
	        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
	
	        rawValue = undefined;
	    }
	};
	ko.expressionRewriting.twoWayBindings['checked'] = true;
	
	ko.bindingHandlers['checkedValue'] = {
	    'update': function (element, valueAccessor) {
	        element.value = ko.utils.unwrapObservable(valueAccessor());
	    }
	};
	
	})();var classesWrittenByBindingKey = '__ko__cssValue';
	ko.bindingHandlers['css'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        if (value !== null && typeof value == "object") {
	            ko.utils.objectForEach(value, function(className, shouldHaveClass) {
	                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);
	                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
	            });
	        } else {
	            value = ko.utils.stringTrim(String(value || '')); // Make sure we don't try to store or set a non-string value
	            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
	            element[classesWrittenByBindingKey] = value;
	            ko.utils.toggleDomNodeCssClass(element, value, true);
	        }
	    }
	};
	ko.bindingHandlers['enable'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        if (value && element.disabled)
	            element.removeAttribute("disabled");
	        else if ((!value) && (!element.disabled))
	            element.disabled = true;
	    }
	};
	
	ko.bindingHandlers['disable'] = {
	    'update': function (element, valueAccessor) {
	        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
	    }
	};
	// For certain common events (currently just 'click'), allow a simplified data-binding syntax
	// e.g. click:handler instead of the usual full-length event:{click:handler}
	function makeEventHandlerShortcut(eventName) {
	    ko.bindingHandlers[eventName] = {
	        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var newValueAccessor = function () {
	                var result = {};
	                result[eventName] = valueAccessor();
	                return result;
	            };
	            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
	        }
	    }
	}
	
	ko.bindingHandlers['event'] = {
	    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	        var eventsToHandle = valueAccessor() || {};
	        ko.utils.objectForEach(eventsToHandle, function(eventName) {
	            if (typeof eventName == "string") {
	                ko.utils.registerEventHandler(element, eventName, function (event) {
	                    var handlerReturnValue;
	                    var handlerFunction = valueAccessor()[eventName];
	                    if (!handlerFunction)
	                        return;
	
	                    try {
	                        // Take all the event args, and prefix with the viewmodel
	                        var argsForHandler = ko.utils.makeArray(arguments);
	                        viewModel = bindingContext['$data'];
	                        argsForHandler.unshift(viewModel);
	                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
	                    } finally {
	                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
	                            if (event.preventDefault)
	                                event.preventDefault();
	                            else
	                                event.returnValue = false;
	                        }
	                    }
	
	                    var bubble = allBindings.get(eventName + 'Bubble') !== false;
	                    if (!bubble) {
	                        event.cancelBubble = true;
	                        if (event.stopPropagation)
	                            event.stopPropagation();
	                    }
	                });
	            }
	        });
	    }
	};
	// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
	// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
	ko.bindingHandlers['foreach'] = {
	    makeTemplateValueAccessor: function(valueAccessor) {
	        return function() {
	            var modelValue = valueAccessor(),
	                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here
	
	            // If unwrappedValue is the array, pass in the wrapped value on its own
	            // The value will be unwrapped and tracked within the template binding
	            // (See https://github.com/SteveSanderson/knockout/issues/523)
	            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
	                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };
	
	            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
	            ko.utils.unwrapObservable(modelValue);
	            return {
	                'foreach': unwrappedValue['data'],
	                'as': unwrappedValue['as'],
	                'includeDestroyed': unwrappedValue['includeDestroyed'],
	                'afterAdd': unwrappedValue['afterAdd'],
	                'beforeRemove': unwrappedValue['beforeRemove'],
	                'afterRender': unwrappedValue['afterRender'],
	                'beforeMove': unwrappedValue['beforeMove'],
	                'afterMove': unwrappedValue['afterMove'],
	                'templateEngine': ko.nativeTemplateEngine.instance
	            };
	        };
	    },
	    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
	    },
	    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);
	    }
	};
	ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
	ko.virtualElements.allowedBindings['foreach'] = true;
	var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
	var hasfocusLastValue = '__ko_hasfocusLastValue';
	ko.bindingHandlers['hasfocus'] = {
	    'init': function(element, valueAccessor, allBindings) {
	        var handleElementFocusChange = function(isFocused) {
	            // Where possible, ignore which event was raised and determine focus state using activeElement,
	            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
	            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
	            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
	            // from calling 'blur()' on the element when it loses focus.
	            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
	            element[hasfocusUpdatingProperty] = true;
	            var ownerDoc = element.ownerDocument;
	            if ("activeElement" in ownerDoc) {
	                var active;
	                try {
	                    active = ownerDoc.activeElement;
	                } catch(e) {
	                    // IE9 throws if you access activeElement during page load (see issue #703)
	                    active = ownerDoc.body;
	                }
	                isFocused = (active === element);
	            }
	            var modelValue = valueAccessor();
	            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);
	
	            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
	            element[hasfocusLastValue] = isFocused;
	            element[hasfocusUpdatingProperty] = false;
	        };
	        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
	        var handleElementFocusOut = handleElementFocusChange.bind(null, false);
	
	        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
	        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
	        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
	        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
	    },
	    'update': function(element, valueAccessor) {
	        var value = !!ko.utils.unwrapObservable(valueAccessor());
	
	        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
	            value ? element.focus() : element.blur();
	
	            // In IE, the blur method doesn't always cause the element to lose focus (for example, if the window is not in focus).
	            // Setting focus to the body element does seem to be reliable in IE, but should only be used if we know that the current
	            // element was focused already.
	            if (!value && element[hasfocusLastValue]) {
	                element.ownerDocument.body.focus();
	            }
	
	            // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
	            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]);
	        }
	    }
	};
	ko.expressionRewriting.twoWayBindings['hasfocus'] = true;
	
	ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
	ko.expressionRewriting.twoWayBindings['hasFocus'] = true;
	ko.bindingHandlers['html'] = {
	    'init': function() {
	        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor) {
	        // setHtml will unwrap the value if needed
	        ko.utils.setHtml(element, valueAccessor());
	    }
	};
	// Makes a binding like with or if
	function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
	    ko.bindingHandlers[bindingKey] = {
	        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var didDisplayOnLastUpdate,
	                savedNodes;
	            ko.computed(function() {
	                var rawValue = valueAccessor(),
	                    dataValue = ko.utils.unwrapObservable(rawValue),
	                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
	                    isFirstRender = !savedNodes,
	                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);
	
	                if (needsRefresh) {
	                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
	                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {
	                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
	                    }
	
	                    if (shouldDisplay) {
	                        if (!isFirstRender) {
	                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));
	                        }
	                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, rawValue) : bindingContext, element);
	                    } else {
	                        ko.virtualElements.emptyNode(element);
	                    }
	
	                    didDisplayOnLastUpdate = shouldDisplay;
	                }
	            }, null, { disposeWhenNodeIsRemoved: element });
	            return { 'controlsDescendantBindings': true };
	        }
	    };
	    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
	    ko.virtualElements.allowedBindings[bindingKey] = true;
	}
	
	// Construct the actual binding handlers
	makeWithIfBinding('if');
	makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
	makeWithIfBinding('with', true /* isWith */, false /* isNot */,
	    function(bindingContext, dataValue) {
	        return bindingContext.createStaticChildContext(dataValue);
	    }
	);
	var captionPlaceholder = {};
	ko.bindingHandlers['options'] = {
	    'init': function(element) {
	        if (ko.utils.tagNameLower(element) !== "select")
	            throw new Error("options binding applies only to SELECT elements");
	
	        // Remove all existing <option>s.
	        while (element.length > 0) {
	            element.remove(0);
	        }
	
	        // Ensures that the binding processor doesn't try to bind the options
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor, allBindings) {
	        function selectedOptions() {
	            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });
	        }
	
	        var selectWasPreviouslyEmpty = element.length == 0,
	            multiple = element.multiple,
	            previousScrollTop = (!selectWasPreviouslyEmpty && multiple) ? element.scrollTop : null,
	            unwrappedArray = ko.utils.unwrapObservable(valueAccessor()),
	            valueAllowUnset = allBindings.get('valueAllowUnset') && allBindings['has']('value'),
	            includeDestroyed = allBindings.get('optionsIncludeDestroyed'),
	            arrayToDomNodeChildrenOptions = {},
	            captionValue,
	            filteredArray,
	            previousSelectedValues = [];
	
	        if (!valueAllowUnset) {
	            if (multiple) {
	                previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);
	            } else if (element.selectedIndex >= 0) {
	                previousSelectedValues.push(ko.selectExtensions.readValue(element.options[element.selectedIndex]));
	            }
	        }
	
	        if (unwrappedArray) {
	            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
	                unwrappedArray = [unwrappedArray];
	
	            // Filter out any entries marked as destroyed
	            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
	                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
	            });
	
	            // If caption is included, add it to the array
	            if (allBindings['has']('optionsCaption')) {
	                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));
	                // If caption value is null or undefined, don't show a caption
	                if (captionValue !== null && captionValue !== undefined) {
	                    filteredArray.unshift(captionPlaceholder);
	                }
	            }
	        } else {
	            // If a falsy value is provided (e.g. null), we'll simply empty the select element
	        }
	
	        function applyToObject(object, predicate, defaultValue) {
	            var predicateType = typeof predicate;
	            if (predicateType == "function")    // Given a function; run it against the data value
	                return predicate(object);
	            else if (predicateType == "string") // Given a string; treat it as a property name on the data value
	                return object[predicate];
	            else                                // Given no optionsText arg; use the data value itself
	                return defaultValue;
	        }
	
	        // The following functions can run at two different times:
	        // The first is when the whole array is being updated directly from this binding handler.
	        // The second is when an observable value for a specific array entry is updated.
	        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
	        var itemUpdate = false;
	        function optionForArrayItem(arrayEntry, index, oldOptions) {
	            if (oldOptions.length) {
	                previousSelectedValues = !valueAllowUnset && oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];
	                itemUpdate = true;
	            }
	            var option = element.ownerDocument.createElement("option");
	            if (arrayEntry === captionPlaceholder) {
	                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));
	                ko.selectExtensions.writeValue(option, undefined);
	            } else {
	                // Apply a value to the option element
	                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);
	                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));
	
	                // Apply some text to the option element
	                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);
	                ko.utils.setTextContent(option, optionText);
	            }
	            return [option];
	        }
	
	        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
	        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
	        arrayToDomNodeChildrenOptions['beforeRemove'] =
	            function (option) {
	                element.removeChild(option);
	            };
	
	        function setSelectionCallback(arrayEntry, newOptions) {
	            if (itemUpdate && valueAllowUnset) {
	                // The model value is authoritative, so make sure its value is the one selected
	                // There is no need to use dependencyDetection.ignore since setDomNodeChildrenFromArrayMapping does so already.
	                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
	            } else if (previousSelectedValues.length) {
	                // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
	                // That's why we first added them without selection. Now it's time to set the selection.
	                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;
	                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);
	
	                // If this option was changed from being selected during a single-item update, notify the change
	                if (itemUpdate && !isSelected) {
	                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
	                }
	            }
	        }
	
	        var callback = setSelectionCallback;
	        if (allBindings['has']('optionsAfterRender') && typeof allBindings.get('optionsAfterRender') == "function") {
	            callback = function(arrayEntry, newOptions) {
	                setSelectionCallback(arrayEntry, newOptions);
	                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);
	            }
	        }
	
	        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);
	
	        ko.dependencyDetection.ignore(function () {
	            if (valueAllowUnset) {
	                // The model value is authoritative, so make sure its value is the one selected
	                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
	            } else {
	                // Determine if the selection has changed as a result of updating the options list
	                var selectionChanged;
	                if (multiple) {
	                    // For a multiple-select box, compare the new selection count to the previous one
	                    // But if nothing was selected before, the selection can't have changed
	                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;
	                } else {
	                    // For a single-select box, compare the current value to the previous value
	                    // But if nothing was selected before or nothing is selected now, just look for a change in selection
	                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)
	                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])
	                        : (previousSelectedValues.length || element.selectedIndex >= 0);
	                }
	
	                // Ensure consistency between model value and selected option.
	                // If the dropdown was changed so that selection is no longer the same,
	                // notify the value or selectedOptions binding.
	                if (selectionChanged) {
	                    ko.utils.triggerEvent(element, "change");
	                }
	            }
	        });
	
	        // Workaround for IE bug
	        ko.utils.ensureSelectElementIsRenderedCorrectly(element);
	
	        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)
	            element.scrollTop = previousScrollTop;
	    }
	};
	ko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();
	ko.bindingHandlers['selectedOptions'] = {
	    'after': ['options', 'foreach'],
	    'init': function (element, valueAccessor, allBindings) {
	        ko.utils.registerEventHandler(element, "change", function () {
	            var value = valueAccessor(), valueToWrite = [];
	            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
	                if (node.selected)
	                    valueToWrite.push(ko.selectExtensions.readValue(node));
	            });
	            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);
	        });
	    },
	    'update': function (element, valueAccessor) {
	        if (ko.utils.tagNameLower(element) != "select")
	            throw new Error("values binding applies only to SELECT elements");
	
	        var newValue = ko.utils.unwrapObservable(valueAccessor()),
	            previousScrollTop = element.scrollTop;
	
	        if (newValue && typeof newValue.length == "number") {
	            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
	                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
	                if (node.selected != isSelected) {      // This check prevents flashing of the select element in IE
	                    ko.utils.setOptionNodeSelectionState(node, isSelected);
	                }
	            });
	        }
	
	        element.scrollTop = previousScrollTop;
	    }
	};
	ko.expressionRewriting.twoWayBindings['selectedOptions'] = true;
	ko.bindingHandlers['style'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor() || {});
	        ko.utils.objectForEach(value, function(styleName, styleValue) {
	            styleValue = ko.utils.unwrapObservable(styleValue);
	
	            if (styleValue === null || styleValue === undefined || styleValue === false) {
	                // Empty string removes the value, whereas null/undefined have no effect
	                styleValue = "";
	            }
	
	            element.style[styleName] = styleValue;
	        });
	    }
	};
	ko.bindingHandlers['submit'] = {
	    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	        if (typeof valueAccessor() != "function")
	            throw new Error("The value for a submit binding must be a function");
	        ko.utils.registerEventHandler(element, "submit", function (event) {
	            var handlerReturnValue;
	            var value = valueAccessor();
	            try { handlerReturnValue = value.call(bindingContext['$data'], element); }
	            finally {
	                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
	                    if (event.preventDefault)
	                        event.preventDefault();
	                    else
	                        event.returnValue = false;
	                }
	            }
	        });
	    }
	};
	ko.bindingHandlers['text'] = {
	    'init': function() {
	        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
	        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.
	        return { 'controlsDescendantBindings': true };
	    },
	    'update': function (element, valueAccessor) {
	        ko.utils.setTextContent(element, valueAccessor());
	    }
	};
	ko.virtualElements.allowedBindings['text'] = true;
	(function () {
	
	if (window && window.navigator) {
	    var parseVersion = function (matches) {
	        if (matches) {
	            return parseFloat(matches[1]);
	        }
	    };
	
	    // Detect various browser versions because some old versions don't fully support the 'input' event
	    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),
	        userAgent = window.navigator.userAgent,
	        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),
	        firefoxVersion = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));
	}
	
	// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
	// But it does fire the 'selectionchange' event on many of those, presumably because the
	// cursor is moving and that counts as the selection changing. The 'selectionchange' event is
	// fired at the document level only and doesn't directly indicate which element changed. We
	// set up just one event handler for the document and use 'activeElement' to determine which
	// element was changed.
	if (ko.utils.ieVersion < 10) {
	    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),
	        selectionChangeHandlerName = ko.utils.domData.nextKey();
	    var selectionChangeHandler = function(event) {
	        var target = this.activeElement,
	            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);
	        if (handler) {
	            handler(event);
	        }
	    };
	    var registerForSelectionChangeEvent = function (element, handler) {
	        var ownerDoc = element.ownerDocument;
	        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {
	            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);
	            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);
	        }
	        ko.utils.domData.set(element, selectionChangeHandlerName, handler);
	    };
	}
	
	ko.bindingHandlers['textInput'] = {
	    'init': function (element, valueAccessor, allBindings) {
	
	        var previousElementValue = element.value,
	            timeoutHandle,
	            elementValueBeforeEvent;
	
	        var updateModel = function (event) {
	            clearTimeout(timeoutHandle);
	            elementValueBeforeEvent = timeoutHandle = undefined;
	
	            var elementValue = element.value;
	            if (previousElementValue !== elementValue) {
	                // Provide a way for tests to know exactly which event was processed
	                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;
	                previousElementValue = elementValue;
	                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);
	            }
	        };
	
	        var deferUpdateModel = function (event) {
	            if (!timeoutHandle) {
	                // The elementValueBeforeEvent variable is set *only* during the brief gap between an
	                // event firing and the updateModel function running. This allows us to ignore model
	                // updates that are from the previous state of the element, usually due to techniques
	                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.
	                elementValueBeforeEvent = element.value;
	                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;
	                timeoutHandle = ko.utils.setTimeout(handler, 4);
	            }
	        };
	
	        // IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);
	        // so we'll make sure all updates are asynchronous
	        var ieUpdateModel = ko.utils.ieVersion == 9 ? deferUpdateModel : updateModel;
	
	        var updateView = function () {
	            var modelValue = ko.utils.unwrapObservable(valueAccessor());
	
	            if (modelValue === null || modelValue === undefined) {
	                modelValue = '';
	            }
	
	            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {
	                ko.utils.setTimeout(updateView, 4);
	                return;
	            }
	
	            // Update the element only if the element and model are different. On some browsers, updating the value
	            // will move the cursor to the end of the input, which would be bad while the user is typing.
	            if (element.value !== modelValue) {
	                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value
	                element.value = modelValue;
	            }
	        };
	
	        var onEvent = function (event, handler) {
	            ko.utils.registerEventHandler(element, event, handler);
	        };
	
	        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {
	            // Provide a way for tests to specify exactly which events are bound
	            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {
	                if (eventName.slice(0,5) == 'after') {
	                    onEvent(eventName.slice(5), deferUpdateModel);
	                } else {
	                    onEvent(eventName, updateModel);
	                }
	            });
	        } else {
	            if (ko.utils.ieVersion < 10) {
	                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever
	                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,
	                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it
	                // when using autocomplete, we'll use 'propertychange' for it also.
	                onEvent('propertychange', function(event) {
	                    if (event.propertyName === 'value') {
	                        ieUpdateModel(event);
	                    }
	                });
	
	                if (ko.utils.ieVersion == 8) {
	                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from
	                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following
	                    // events too.
	                    onEvent('keyup', updateModel);      // A single keystoke
	                    onEvent('keydown', updateModel);    // The first character when a key is held down
	                }
	                if (ko.utils.ieVersion >= 8) {
	                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using
	                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text
	                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'
	                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.
	                    // These are also needed in IE8 because of the bug described above.
	                    registerForSelectionChangeEvent(element, ieUpdateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.
	                    onEvent('dragend', deferUpdateModel);
	                }
	            } else {
	                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed
	                // through the user interface.
	                onEvent('input', updateModel);
	
	                if (safariVersion < 5 && ko.utils.tagNameLower(element) === "textarea") {
	                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'
	                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.
	                    onEvent('keydown', deferUpdateModel);
	                    onEvent('paste', deferUpdateModel);
	                    onEvent('cut', deferUpdateModel);
	                } else if (operaVersion < 11) {
	                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.
	                    // We can try to catch some of those using 'keydown'.
	                    onEvent('keydown', deferUpdateModel);
	                } else if (firefoxVersion < 4.0) {
	                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
	                    onEvent('DOMAutoComplete', updateModel);
	
	                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.
	                    onEvent('dragdrop', updateModel);       // <3.5
	                    onEvent('drop', updateModel);           // 3.5
	                }
	            }
	        }
	
	        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.
	        onEvent('change', updateModel);
	
	        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
	    }
	};
	ko.expressionRewriting.twoWayBindings['textInput'] = true;
	
	// textinput is an alias for textInput
	ko.bindingHandlers['textinput'] = {
	    // preprocess is the only way to set up a full alias
	    'preprocess': function (value, name, addBinding) {
	        addBinding('textInput', value);
	    }
	};
	
	})();ko.bindingHandlers['uniqueName'] = {
	    'init': function (element, valueAccessor) {
	        if (valueAccessor()) {
	            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
	            ko.utils.setElementName(element, name);
	        }
	    }
	};
	ko.bindingHandlers['uniqueName'].currentIndex = 0;
	ko.bindingHandlers['value'] = {
	    'after': ['options', 'foreach'],
	    'init': function (element, valueAccessor, allBindings) {
	        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
	        if (element.tagName.toLowerCase() == "input" && (element.type == "checkbox" || element.type == "radio")) {
	            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });
	            return;
	        }
	
	        // Always catch "change" event; possibly other events too if asked
	        var eventsToCatch = ["change"];
	        var requestedEventsToCatch = allBindings.get("valueUpdate");
	        var propertyChangedFired = false;
	        var elementValueBeforeEvent = null;
	
	        if (requestedEventsToCatch) {
	            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
	                requestedEventsToCatch = [requestedEventsToCatch];
	            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
	            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
	        }
	
	        var valueUpdateHandler = function() {
	            elementValueBeforeEvent = null;
	            propertyChangedFired = false;
	            var modelValue = valueAccessor();
	            var elementValue = ko.selectExtensions.readValue(element);
	            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);
	        }
	
	        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
	        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
	        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
	                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
	        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
	            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
	            ko.utils.registerEventHandler(element, "focus", function () { propertyChangedFired = false });
	            ko.utils.registerEventHandler(element, "blur", function() {
	                if (propertyChangedFired) {
	                    valueUpdateHandler();
	                }
	            });
	        }
	
	        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
	            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
	            // This is useful, for example, to catch "keydown" events after the browser has updated the control
	            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
	            var handler = valueUpdateHandler;
	            if (ko.utils.stringStartsWith(eventName, "after")) {
	                handler = function() {
	                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between
	                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen
	                    // at the earliest asynchronous opportunity. We store this temporary information so that
	                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,
	                    // we can overwrite that model value change with the value the user just typed. Otherwise,
	                    // techniques like rateLimit can trigger model changes at critical moments that will
	                    // override the user's inputs, causing keystrokes to be lost.
	                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);
	                    ko.utils.setTimeout(valueUpdateHandler, 0);
	                };
	                eventName = eventName.substring("after".length);
	            }
	            ko.utils.registerEventHandler(element, eventName, handler);
	        });
	
	        var updateFromModel = function () {
	            var newValue = ko.utils.unwrapObservable(valueAccessor());
	            var elementValue = ko.selectExtensions.readValue(element);
	
	            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {
	                ko.utils.setTimeout(updateFromModel, 0);
	                return;
	            }
	
	            var valueHasChanged = (newValue !== elementValue);
	
	            if (valueHasChanged) {
	                if (ko.utils.tagNameLower(element) === "select") {
	                    var allowUnset = allBindings.get('valueAllowUnset');
	                    var applyValueAction = function () {
	                        ko.selectExtensions.writeValue(element, newValue, allowUnset);
	                    };
	                    applyValueAction();
	
	                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {
	                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
	                        // because you're not allowed to have a model value that disagrees with a visible UI selection.
	                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
	                    } else {
	                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
	                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
	                        // to apply the value as well.
	                        ko.utils.setTimeout(applyValueAction, 0);
	                    }
	                } else {
	                    ko.selectExtensions.writeValue(element, newValue);
	                }
	            }
	        };
	
	        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });
	    },
	    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding
	};
	ko.expressionRewriting.twoWayBindings['value'] = true;
	ko.bindingHandlers['visible'] = {
	    'update': function (element, valueAccessor) {
	        var value = ko.utils.unwrapObservable(valueAccessor());
	        var isCurrentlyVisible = !(element.style.display == "none");
	        if (value && !isCurrentlyVisible)
	            element.style.display = "";
	        else if ((!value) && isCurrentlyVisible)
	            element.style.display = "none";
	    }
	};
	// 'click' is just a shorthand for the usual full-length event:{click:handler}
	makeEventHandlerShortcut('click');
	// If you want to make a custom template engine,
	//
	// [1] Inherit from this class (like ko.nativeTemplateEngine does)
	// [2] Override 'renderTemplateSource', supplying a function with this signature:
	//
	//        function (templateSource, bindingContext, options) {
	//            // - templateSource.text() is the text of the template you should render
	//            // - bindingContext.$data is the data you should pass into the template
	//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
	//            //     and bindingContext.$root available in the template too
	//            // - options gives you access to any other properties set on "data-bind: { template: options }"
	//            // - templateDocument is the document object of the template
	//            //
	//            // Return value: an array of DOM nodes
	//        }
	//
	// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
	//
	//        function (script) {
	//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
	//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
	//        }
	//
	//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
	//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
	//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.
	
	ko.templateEngine = function () { };
	
	ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
	    throw new Error("Override renderTemplateSource");
	};
	
	ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
	    throw new Error("Override createJavaScriptEvaluatorBlock");
	};
	
	ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
	    // Named template
	    if (typeof template == "string") {
	        templateDocument = templateDocument || document;
	        var elem = templateDocument.getElementById(template);
	        if (!elem)
	            throw new Error("Cannot find template with ID " + template);
	        return new ko.templateSources.domElement(elem);
	    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
	        // Anonymous template
	        return new ko.templateSources.anonymousTemplate(template);
	    } else
	        throw new Error("Unknown template type: " + template);
	};
	
	ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
	    var templateSource = this['makeTemplateSource'](template, templateDocument);
	    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
	};
	
	ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
	    // Skip rewriting if requested
	    if (this['allowTemplateRewriting'] === false)
	        return true;
	    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
	};
	
	ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
	    var templateSource = this['makeTemplateSource'](template, templateDocument);
	    var rewritten = rewriterCallback(templateSource['text']());
	    templateSource['text'](rewritten);
	    templateSource['data']("isRewritten", true);
	};
	
	ko.exportSymbol('templateEngine', ko.templateEngine);
	
	ko.templateRewriting = (function () {
	    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi;
	    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;
	
	    function validateDataBindValuesForRewriting(keyValueArray) {
	        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
	        for (var i = 0; i < keyValueArray.length; i++) {
	            var key = keyValueArray[i]['key'];
	            if (allValidators.hasOwnProperty(key)) {
	                var validator = allValidators[key];
	
	                if (typeof validator === "function") {
	                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
	                    if (possibleErrorMessage)
	                        throw new Error(possibleErrorMessage);
	                } else if (!validator) {
	                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
	                }
	            }
	        }
	    }
	
	    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {
	        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
	        validateDataBindValuesForRewriting(dataBindKeyValueArray);
	        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});
	
	        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
	        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
	        // extra indirection.
	        var applyBindingsToNextSiblingScript =
	            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()},'" + nodeName.toLowerCase() + "')";
	        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
	    }
	
	    return {
	        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
	            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
	                templateEngine['rewriteTemplate'](template, function (htmlString) {
	                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
	                }, templateDocument);
	        },
	
	        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
	            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
	                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);
	            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
	                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", /* nodeName: */ "#comment", templateEngine);
	            });
	        },
	
	        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {
	            return ko.memoization.memoize(function (domNode, bindingContext) {
	                var nodeToBind = domNode.nextSibling;
	                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {
	                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
	                }
	            });
	        }
	    }
	})();
	
	
	// Exported only because it has to be referenced by string lookup from within rewritten template
	ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
	(function() {
	    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
	    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
	    //
	    // Two are provided by default:
	    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
	    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
	    //                                           without reading/writing the actual element text content, since it will be overwritten
	    //                                           with the rendered template output.
	    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
	    // Template sources need to have the following functions:
	    //   text() 			- returns the template text from your storage location
	    //   text(value)		- writes the supplied template text to your storage location
	    //   data(key)			- reads values stored using data(key, value) - see below
	    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
	    //
	    // Optionally, template sources can also have the following functions:
	    //   nodes()            - returns a DOM element containing the nodes of this template, where available
	    //   nodes(value)       - writes the given DOM element to your storage location
	    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
	    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
	    //
	    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
	    // using and overriding "makeTemplateSource" to return an instance of your custom template source.
	
	    ko.templateSources = {};
	
	    // ---- ko.templateSources.domElement -----
	
	    // template types
	    var templateScript = 1,
	        templateTextArea = 2,
	        templateTemplate = 3,
	        templateElement = 4;
	
	    ko.templateSources.domElement = function(element) {
	        this.domElement = element;
	
	        if (element) {
	            var tagNameLower = ko.utils.tagNameLower(element);
	            this.templateType =
	                tagNameLower === "script" ? templateScript :
	                tagNameLower === "textarea" ? templateTextArea :
	                    // For browsers with proper <template> element support, where the .content property gives a document fragment
	                tagNameLower == "template" && element.content && element.content.nodeType === 11 ? templateTemplate :
	                templateElement;
	        }
	    }
	
	    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
	        var elemContentsProperty = this.templateType === templateScript ? "text"
	                                 : this.templateType === templateTextArea ? "value"
	                                 : "innerHTML";
	
	        if (arguments.length == 0) {
	            return this.domElement[elemContentsProperty];
	        } else {
	            var valueToWrite = arguments[0];
	            if (elemContentsProperty === "innerHTML")
	                ko.utils.setHtml(this.domElement, valueToWrite);
	            else
	                this.domElement[elemContentsProperty] = valueToWrite;
	        }
	    };
	
	    var dataDomDataPrefix = ko.utils.domData.nextKey() + "_";
	    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
	        if (arguments.length === 1) {
	            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
	        } else {
	            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
	        }
	    };
	
	    var templatesDomDataKey = ko.utils.domData.nextKey();
	    function getTemplateDomData(element) {
	        return ko.utils.domData.get(element, templatesDomDataKey) || {};
	    }
	    function setTemplateDomData(element, data) {
	        ko.utils.domData.set(element, templatesDomDataKey, data);
	    }
	
	    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
	        var element = this.domElement;
	        if (arguments.length == 0) {
	            var templateData = getTemplateDomData(element),
	                containerData = templateData.containerData;
	            return containerData || (
	                this.templateType === templateTemplate ? element.content :
	                this.templateType === templateElement ? element :
	                undefined);
	        } else {
	            var valueToWrite = arguments[0];
	            setTemplateDomData(element, {containerData: valueToWrite});
	        }
	    };
	
	    // ---- ko.templateSources.anonymousTemplate -----
	    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
	    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
	    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.
	
	    ko.templateSources.anonymousTemplate = function(element) {
	        this.domElement = element;
	    }
	    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
	    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;
	    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
	        if (arguments.length == 0) {
	            var templateData = getTemplateDomData(this.domElement);
	            if (templateData.textData === undefined && templateData.containerData)
	                templateData.textData = templateData.containerData.innerHTML;
	            return templateData.textData;
	        } else {
	            var valueToWrite = arguments[0];
	            setTemplateDomData(this.domElement, {textData: valueToWrite});
	        }
	    };
	
	    ko.exportSymbol('templateSources', ko.templateSources);
	    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
	    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
	})();
	(function () {
	    var _templateEngine;
	    ko.setTemplateEngine = function (templateEngine) {
	        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
	            throw new Error("templateEngine must inherit from ko.templateEngine");
	        _templateEngine = templateEngine;
	    }
	
	    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {
	        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
	        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
	            nextInQueue = ko.virtualElements.nextSibling(node);
	            action(node, nextInQueue);
	        }
	    }
	
	    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
	        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
	        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
	        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
	        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
	        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)
	
	        if (continuousNodeArray.length) {
	            var firstNode = continuousNodeArray[0],
	                lastNode = continuousNodeArray[continuousNodeArray.length - 1],
	                parentNode = firstNode.parentNode,
	                provider = ko.bindingProvider['instance'],
	                preprocessNode = provider['preprocessNode'];
	
	            if (preprocessNode) {
	                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
	                    var nodePreviousSibling = node.previousSibling;
	                    var newNodes = preprocessNode.call(provider, node);
	                    if (newNodes) {
	                        if (node === firstNode)
	                            firstNode = newNodes[0] || nextNodeInRange;
	                        if (node === lastNode)
	                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
	                    }
	                });
	
	                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
	                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
	                // first node needs to be in the array).
	                continuousNodeArray.length = 0;
	                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
	                    return;
	                }
	                if (firstNode === lastNode) {
	                    continuousNodeArray.push(firstNode);
	                } else {
	                    continuousNodeArray.push(firstNode, lastNode);
	                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
	                }
	            }
	
	            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
	            // whereas a regular applyBindings won't introduce new memoized nodes
	            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
	                if (node.nodeType === 1 || node.nodeType === 8)
	                    ko.applyBindings(bindingContext, node);
	            });
	            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
	                if (node.nodeType === 1 || node.nodeType === 8)
	                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
	            });
	
	            // Make sure any changes done by applyBindings or unmemoize are reflected in the array
	            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
	        }
	    }
	
	    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
	        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
	                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
	                                        : null;
	    }
	
	    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
	        options = options || {};
	        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	        var templateDocument = (firstTargetNode || template || {}).ownerDocument;
	        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
	        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
	        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);
	
	        // Loosely check result is an array of DOM nodes
	        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
	            throw new Error("Template engine must return an array of DOM nodes");
	
	        var haveAddedNodesToParent = false;
	        switch (renderMode) {
	            case "replaceChildren":
	                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
	                haveAddedNodesToParent = true;
	                break;
	            case "replaceNode":
	                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
	                haveAddedNodesToParent = true;
	                break;
	            case "ignoreTargetNode": break;
	            default:
	                throw new Error("Unknown renderMode: " + renderMode);
	        }
	
	        if (haveAddedNodesToParent) {
	            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
	            if (options['afterRender'])
	                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
	        }
	
	        return renderedNodesArray;
	    }
	
	    function resolveTemplateName(template, data, context) {
	        // The template can be specified as:
	        if (ko.isObservable(template)) {
	            // 1. An observable, with string value
	            return template();
	        } else if (typeof template === 'function') {
	            // 2. A function of (data, context) returning a string
	            return template(data, context);
	        } else {
	            // 3. A string
	            return template;
	        }
	    }
	
	    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
	        options = options || {};
	        if ((options['templateEngine'] || _templateEngine) == undefined)
	            throw new Error("Set a template engine before calling renderTemplate");
	        renderMode = renderMode || "replaceChildren";
	
	        if (targetNodeOrNodeArray) {
	            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	
	            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
	            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;
	
	            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
	                function () {
	                    // Ensure we've got a proper binding context to work with
	                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
	                        ? dataOrBindingContext
	                        : new ko.bindingContext(dataOrBindingContext, null, null, null, { "exportDependencies": true });
	
	                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
	                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);
	
	                    if (renderMode == "replaceNode") {
	                        targetNodeOrNodeArray = renderedNodesArray;
	                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
	                    }
	                },
	                null,
	                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
	            );
	        } else {
	            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
	            return ko.memoization.memoize(function (domNode) {
	                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
	            });
	        }
	    };
	
	    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
	        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
	        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
	        var arrayItemContext;
	
	        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
	        var executeTemplateForArrayItem = function (arrayValue, index) {
	            // Support selecting template as a function of the data being rendered
	            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
	                context['$index'] = index;
	            });
	
	            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
	            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
	        }
	
	        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
	        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
	            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
	            if (options['afterRender'])
	                options['afterRender'](addedNodesArray, arrayValue);
	
	            // release the "cache" variable, so that it can be collected by
	            // the GC when its value isn't used from within the bindings anymore.
	            arrayItemContext = null;
	        };
	
	        return ko.dependentObservable(function () {
	            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
	            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
	                unwrappedArray = [unwrappedArray];
	
	            // Filter out any entries marked as destroyed
	            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
	                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
	            });
	
	            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
	            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
	            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);
	
	        }, null, { disposeWhenNodeIsRemoved: targetNode });
	    };
	
	    var templateComputedDomDataKey = ko.utils.domData.nextKey();
	    function disposeOldComputedAndStoreNewOne(element, newComputed) {
	        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
	        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
	            oldComputed.dispose();
	        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
	    }
	
	    ko.bindingHandlers['template'] = {
	        'init': function(element, valueAccessor) {
	            // Support anonymous templates
	            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
	            if (typeof bindingValue == "string" || bindingValue['name']) {
	                // It's a named template - clear the element
	                ko.virtualElements.emptyNode(element);
	            } else if ('nodes' in bindingValue) {
	                // We've been given an array of DOM nodes. Save them as the template source.
	                // There is no known use case for the node array being an observable array (if the output
	                // varies, put that behavior *into* your template - that's what templates are for), and
	                // the implementation would be a mess, so assert that it's not observable.
	                var nodes = bindingValue['nodes'] || [];
	                if (ko.isObservable(nodes)) {
	                    throw new Error('The "nodes" option must be a plain, non-observable array.');
	                }
	                var container = ko.utils.moveCleanedNodesToContainerElement(nodes); // This also removes the nodes from their current parent
	                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
	            } else {
	                // It's an anonymous template - store the element contents, then clear the element
	                var templateNodes = ko.virtualElements.childNodes(element),
	                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
	                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
	            }
	            return { 'controlsDescendantBindings': true };
	        },
	        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
	            var value = valueAccessor(),
	                options = ko.utils.unwrapObservable(value),
	                shouldDisplay = true,
	                templateComputed = null,
	                templateName;
	
	            if (typeof options == "string") {
	                templateName = value;
	                options = {};
	            } else {
	                templateName = options['name'];
	
	                // Support "if"/"ifnot" conditions
	                if ('if' in options)
	                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
	                if (shouldDisplay && 'ifnot' in options)
	                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);
	            }
	
	            if ('foreach' in options) {
	                // Render once for each data point (treating data set as empty if shouldDisplay==false)
	                var dataArray = (shouldDisplay && options['foreach']) || [];
	                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
	            } else if (!shouldDisplay) {
	                ko.virtualElements.emptyNode(element);
	            } else {
	                // Render once for this single data point (or use the viewModel if no data was provided)
	                var innerBindingContext = ('data' in options) ?
	                    bindingContext.createStaticChildContext(options['data'], options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
	                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
	                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
	            }
	
	            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
	            disposeOldComputedAndStoreNewOne(element, templateComputed);
	        }
	    };
	
	    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
	    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
	        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);
	
	        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
	            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)
	
	        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
	            return null; // Named templates can be rewritten, so return "no error"
	        return "This template engine does not support anonymous templates nested within its templates";
	    };
	
	    ko.virtualElements.allowedBindings['template'] = true;
	})();
	
	ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
	ko.exportSymbol('renderTemplate', ko.renderTemplate);
	// Go through the items that have been added and deleted and try to find matches between them.
	ko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {
	    if (left.length && right.length) {
	        var failedCompares, l, r, leftItem, rightItem;
	        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {
	            for (r = 0; rightItem = right[r]; ++r) {
	                if (leftItem['value'] === rightItem['value']) {
	                    leftItem['moved'] = rightItem['index'];
	                    rightItem['moved'] = leftItem['index'];
	                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list
	                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
	                    break;
	                }
	            }
	            failedCompares += r;
	        }
	    }
	};
	
	ko.utils.compareArrays = (function () {
	    var statusNotInOld = 'added', statusNotInNew = 'deleted';
	
	    // Simple calculation based on Levenshtein distance.
	    function compareArrays(oldArray, newArray, options) {
	        // For backward compatibility, if the third arg is actually a bool, interpret
	        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
	        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
	        oldArray = oldArray || [];
	        newArray = newArray || [];
	
	        if (oldArray.length < newArray.length)
	            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
	        else
	            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
	    }
	
	    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {
	        var myMin = Math.min,
	            myMax = Math.max,
	            editDistanceMatrix = [],
	            smlIndex, smlIndexMax = smlArray.length,
	            bigIndex, bigIndexMax = bigArray.length,
	            compareRange = (bigIndexMax - smlIndexMax) || 1,
	            maxDistance = smlIndexMax + bigIndexMax + 1,
	            thisRow, lastRow,
	            bigIndexMaxForRow, bigIndexMinForRow;
	
	        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
	            lastRow = thisRow;
	            editDistanceMatrix.push(thisRow = []);
	            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
	            bigIndexMinForRow = myMax(0, smlIndex - 1);
	            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
	                if (!bigIndex)
	                    thisRow[bigIndex] = smlIndex + 1;
	                else if (!smlIndex)  // Top row - transform empty array into new array via additions
	                    thisRow[bigIndex] = bigIndex + 1;
	                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
	                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
	                else {
	                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
	                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
	                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
	                }
	            }
	        }
	
	        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
	        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
	            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
	            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
	                notInSml.push(editScript[editScript.length] = {     // added
	                    'status': statusNotInSml,
	                    'value': bigArray[--bigIndex],
	                    'index': bigIndex });
	            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
	                notInBig.push(editScript[editScript.length] = {     // deleted
	                    'status': statusNotInBig,
	                    'value': smlArray[--smlIndex],
	                    'index': smlIndex });
	            } else {
	                --bigIndex;
	                --smlIndex;
	                if (!options['sparse']) {
	                    editScript.push({
	                        'status': "retained",
	                        'value': bigArray[bigIndex] });
	                }
	            }
	        }
	
	        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
	        // smlIndexMax keeps the time complexity of this algorithm linear.
	        ko.utils.findMovesInArrayComparison(notInBig, notInSml, !options['dontLimitMoves'] && smlIndexMax * 10);
	
	        return editScript.reverse();
	    }
	
	    return compareArrays;
	})();
	
	ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);
	(function () {
	    // Objective:
	    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
	    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
	    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
	    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
	    //   previously mapped - retain those nodes, and just insert/delete other ones
	
	    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
	    // You can use this, for example, to activate bindings on those nodes.
	
	    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
	        // Map this array value inside a dependentObservable so we re-map when any dependency changes
	        var mappedNodes = [];
	        var dependentObservable = ko.dependentObservable(function() {
	            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];
	
	            // On subsequent evaluations, just replace the previously-inserted DOM nodes
	            if (mappedNodes.length > 0) {
	                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
	                if (callbackAfterAddingNodes)
	                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
	            }
	
	            // Replace the contents of the mappedNodes array, thereby updating the record
	            // of which nodes would be deleted if valueToMap was itself later removed
	            mappedNodes.length = 0;
	            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
	        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
	        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
	    }
	
	    var lastMappingResultDomDataKey = ko.utils.domData.nextKey(),
	        deletedItemDummyValue = ko.utils.domData.nextKey();
	
	    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
	        // Compare the provided array against the previous one
	        array = array || [];
	        options = options || {};
	        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
	        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
	        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
	        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);
	
	        // Build the new mapping result
	        var newMappingResult = [];
	        var lastMappingResultIndex = 0;
	        var newMappingResultIndex = 0;
	
	        var nodesToDelete = [];
	        var itemsToProcess = [];
	        var itemsForBeforeRemoveCallbacks = [];
	        var itemsForMoveCallbacks = [];
	        var itemsForAfterAddCallbacks = [];
	        var mapData;
	
	        function itemMovedOrRetained(editScriptIndex, oldPosition) {
	            mapData = lastMappingResult[oldPosition];
	            if (newMappingResultIndex !== oldPosition)
	                itemsForMoveCallbacks[editScriptIndex] = mapData;
	            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
	            mapData.indexObservable(newMappingResultIndex++);
	            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
	            newMappingResult.push(mapData);
	            itemsToProcess.push(mapData);
	        }
	
	        function callCallback(callback, items) {
	            if (callback) {
	                for (var i = 0, n = items.length; i < n; i++) {
	                    if (items[i]) {
	                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
	                            callback(node, i, items[i].arrayEntry);
	                        });
	                    }
	                }
	            }
	        }
	
	        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
	            movedIndex = editScriptItem['moved'];
	            switch (editScriptItem['status']) {
	                case "deleted":
	                    if (movedIndex === undefined) {
	                        mapData = lastMappingResult[lastMappingResultIndex];
	
	                        // Stop tracking changes to the mapping for these nodes
	                        if (mapData.dependentObservable) {
	                            mapData.dependentObservable.dispose();
	                            mapData.dependentObservable = undefined;
	                        }
	
	                        // Queue these nodes for later removal
	                        if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {
	                            if (options['beforeRemove']) {
	                                newMappingResult.push(mapData);
	                                itemsToProcess.push(mapData);
	                                if (mapData.arrayEntry === deletedItemDummyValue) {
	                                    mapData = null;
	                                } else {
	                                    itemsForBeforeRemoveCallbacks[i] = mapData;
	                                }
	                            }
	                            if (mapData) {
	                                nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);
	                            }
	                        }
	                    }
	                    lastMappingResultIndex++;
	                    break;
	
	                case "retained":
	                    itemMovedOrRetained(i, lastMappingResultIndex++);
	                    break;
	
	                case "added":
	                    if (movedIndex !== undefined) {
	                        itemMovedOrRetained(i, movedIndex);
	                    } else {
	                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
	                        newMappingResult.push(mapData);
	                        itemsToProcess.push(mapData);
	                        if (!isFirstExecution)
	                            itemsForAfterAddCallbacks[i] = mapData;
	                    }
	                    break;
	            }
	        }
	
	        // Store a copy of the array items we just considered so we can difference it next time
	        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
	
	        // Call beforeMove first before any changes have been made to the DOM
	        callCallback(options['beforeMove'], itemsForMoveCallbacks);
	
	        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
	        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);
	
	        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
	        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
	            // Get nodes for newly added items
	            if (!mapData.mappedNodes)
	                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));
	
	            // Put nodes in the right place if they aren't there already
	            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
	                if (node !== nextNode)
	                    ko.virtualElements.insertAfter(domNode, node, lastNode);
	            }
	
	            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
	            if (!mapData.initialized && callbackAfterAddingNodes) {
	                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
	                mapData.initialized = true;
	            }
	        }
	
	        // If there's a beforeRemove callback, call it after reordering.
	        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
	        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
	        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
	        // Perhaps we'll make that change in the future if this scenario becomes more common.
	        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);
	
	        // Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item
	        // as already "removed" so we won't call beforeRemove for it again, and it ensures that the item won't match up
	        // with an actual item in the array and appear as "retained" or "moved".
	        for (i = 0; i < itemsForBeforeRemoveCallbacks.length; ++i) {
	            if (itemsForBeforeRemoveCallbacks[i]) {
	                itemsForBeforeRemoveCallbacks[i].arrayEntry = deletedItemDummyValue;
	            }
	        }
	
	        // Finally call afterMove and afterAdd callbacks
	        callCallback(options['afterMove'], itemsForMoveCallbacks);
	        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);
	    }
	})();
	
	ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
	ko.nativeTemplateEngine = function () {
	    this['allowTemplateRewriting'] = false;
	}
	
	ko.nativeTemplateEngine.prototype = new ko.templateEngine();
	ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
	ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options, templateDocument) {
	    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
	        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
	        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;
	
	    if (templateNodes) {
	        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
	    } else {
	        var templateText = templateSource['text']();
	        return ko.utils.parseHtmlFragment(templateText, templateDocument);
	    }
	};
	
	ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
	ko.setTemplateEngine(ko.nativeTemplateEngine.instance);
	
	ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
	(function() {
	    ko.jqueryTmplTemplateEngine = function () {
	        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
	        // doesn't expose a version number, so we have to infer it.
	        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
	        // which KO internally refers to as version "2", so older versions are no longer detected.
	        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
	            if (!jQueryInstance || !(jQueryInstance['tmpl']))
	                return 0;
	            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
	            try {
	                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
	                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
	                    return 2; // Final version of jquery.tmpl
	                }
	            } catch(ex) { /* Apparently not the version we were looking for */ }
	
	            return 1; // Any older version that we don't support
	        })();
	
	        function ensureHasReferencedJQueryTemplates() {
	            if (jQueryTmplVersion < 2)
	                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
	        }
	
	        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
	            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
	        }
	
	        this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
	            templateDocument = templateDocument || document;
	            options = options || {};
	            ensureHasReferencedJQueryTemplates();
	
	            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
	            var precompiled = templateSource['data']('precompiled');
	            if (!precompiled) {
	                var templateText = templateSource['text']() || "";
	                // Wrap in "with($whatever.koBindingContext) { ... }"
	                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";
	
	                precompiled = jQueryInstance['template'](null, templateText);
	                templateSource['data']('precompiled', precompiled);
	            }
	
	            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
	            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);
	
	            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
	            resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work
	
	            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
	            return resultNodes;
	        };
	
	        this['createJavaScriptEvaluatorBlock'] = function(script) {
	            return "{{ko_code ((function() { return " + script + " })()) }}";
	        };
	
	        this['addTemplate'] = function(templateName, templateMarkup) {
	            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
	        };
	
	        if (jQueryTmplVersion > 0) {
	            jQueryInstance['tmpl']['tag']['ko_code'] = {
	                open: "__.push($1 || '');"
	            };
	            jQueryInstance['tmpl']['tag']['ko_with'] = {
	                open: "with($1) {",
	                close: "} "
	            };
	        }
	    };
	
	    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
	    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;
	
	    // Use this one by default *only if jquery.tmpl is referenced*
	    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
	    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
	        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);
	
	    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
	})();
	}));
	}());
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;;(function(factory) {
	    'use strict';
	    /* global window: false, define: false, module: false */
	    var root = typeof window === 'undefined' ? null : window;
	
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){ return factory(root); }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined') {
	        module.exports = factory(root);
	    } else {
	        root.DOMPurify = factory(root);
	    }
	}(function factory(window) {
	    'use strict';
	
	    var DOMPurify = function(window) {
	        return factory(window);
	    };
	
	    /**
	     * Version label, exposed for easier checks
	     * if DOMPurify is up to date or not
	     */
	    DOMPurify.version = '0.8.3';
	
	    /**
	     * Array of elements that DOMPurify removed during sanitation.
	     * Empty if nothing was removed.
	     */
	    DOMPurify.removed = [];
	
	    if (!window || !window.document || window.document.nodeType !== 9) {
	        // not running in a browser, provide a factory function
	        // so that you can pass your own Window
	        DOMPurify.isSupported = false;
	        return DOMPurify;
	    }
	
	    var document = window.document;
	    var originalDocument = document;
	    var DocumentFragment = window.DocumentFragment;
	    var HTMLTemplateElement = window.HTMLTemplateElement;
	    var NodeFilter = window.NodeFilter;
	    var NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap;
	    var Text = window.Text;
	    var Comment = window.Comment;
	    var DOMParser = window.DOMParser;
	
	    // As per issue #47, the web-components registry is inherited by a
	    // new document created via createHTMLDocument. As per the spec
	    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
	    // a new empty registry is used when creating a template contents owner
	    // document, so we use that as our parent document to ensure nothing
	    // is inherited.
	    if (typeof HTMLTemplateElement === 'function') {
	        var template = document.createElement('template');
	        if (template.content && template.content.ownerDocument) {
	            document = template.content.ownerDocument;
	        }
	    }
	    var implementation = document.implementation;
	    var createNodeIterator = document.createNodeIterator;
	    var getElementsByTagName = document.getElementsByTagName;
	    var createDocumentFragment = document.createDocumentFragment;
	    var importNode = originalDocument.importNode;
	
	    var hooks = {};
	
	    /**
	     * Expose whether this browser supports running the full DOMPurify.
	     */
	    DOMPurify.isSupported =
	        typeof implementation.createHTMLDocument !== 'undefined' &&
	        document.documentMode !== 9;
	
	    /* Add properties to a lookup table */
	    var _addToSet = function(set, array) {
	        var l = array.length;
	        while (l--) {
	            if (typeof array[l] === 'string') {
	                array[l] = array[l].toLowerCase();
	            }
	            set[array[l]] = true;
	        }
	        return set;
	    };
	
	    /* Shallow clone an object */
	    var _cloneObj = function(object) {
	        var newObject = {};
	        var property;
	        for (property in object) {
	            if (object.hasOwnProperty(property)) {
	                newObject[property] = object[property];
	            }
	        }
	        return newObject;
	    };
	
	    /**
	     * We consider the elements and attributes below to be safe. Ideally
	     * don't add any new ones but feel free to remove unwanted ones.
	     */
	
	    /* allowed element names */
	    var ALLOWED_TAGS = null;
	    var DEFAULT_ALLOWED_TAGS = _addToSet({}, [
	
	        // HTML
	        'a','abbr','acronym','address','area','article','aside','audio','b',
	        'bdi','bdo','big','blink','blockquote','body','br','button','canvas',
	        'caption','center','cite','code','col','colgroup','content','data',
	        'datalist','dd','decorator','del','details','dfn','dir','div','dl','dt',
	        'element','em','fieldset','figcaption','figure','font','footer','form',
	        'h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i',
	        'img','input','ins','kbd','label','legend','li','main','map','mark',
	        'marquee','menu','menuitem','meter','nav','nobr','ol','optgroup',
	        'option','output','p','pre','progress','q','rp','rt','ruby','s','samp',
	        'section','select','shadow','small','source','spacer','span','strike',
	        'strong','style','sub','summary','sup','table','tbody','td','template',
	        'textarea','tfoot','th','thead','time','tr','track','tt','u','ul','var',
	        'video','wbr',
	
	        // SVG
	        'svg','altglyph','altglyphdef','altglyphitem','animatecolor',
	        'animatemotion','animatetransform','circle','clippath','defs','desc',
	        'ellipse','filter','font','g','glyph','glyphref','hkern','image','line',
	        'lineargradient','marker','mask','metadata','mpath','path','pattern',
	        'polygon','polyline','radialgradient','rect','stop','switch','symbol',
	        'text','textpath','title','tref','tspan','view','vkern',
	
	        // SVG Filters
	        'feBlend','feColorMatrix','feComponentTransfer','feComposite',
	        'feConvolveMatrix','feDiffuseLighting','feDisplacementMap',
	        'feFlood','feFuncA','feFuncB','feFuncG','feFuncR','feGaussianBlur',
	        'feMerge','feMergeNode','feMorphology','feOffset',
	        'feSpecularLighting','feTile','feTurbulence',
	
	        //MathML
	        'math','menclose','merror','mfenced','mfrac','mglyph','mi','mlabeledtr',
	        'mmuliscripts','mn','mo','mover','mpadded','mphantom','mroot','mrow',
	        'ms','mpspace','msqrt','mystyle','msub','msup','msubsup','mtable','mtd',
	        'mtext','mtr','munder','munderover',
	
	        //Text
	        '#text'
	    ]);
	
	    /* Allowed attribute names */
	    var ALLOWED_ATTR = null;
	    var DEFAULT_ALLOWED_ATTR = _addToSet({}, [
	
	        // HTML
	        'accept','action','align','alt','autocomplete','background','bgcolor',
	        'border','cellpadding','cellspacing','checked','cite','class','clear','color',
	        'cols','colspan','coords','datetime','default','dir','disabled',
	        'download','enctype','face','for','headers','height','hidden','high','href',
	        'hreflang','id','ismap','label','lang','list','loop', 'low','max',
	        'maxlength','media','method','min','multiple','name','noshade','novalidate',
	        'nowrap','open','optimum','pattern','placeholder','poster','preload','pubdate',
	        'radiogroup','readonly','rel','required','rev','reversed','rows',
	        'rowspan','spellcheck','scope','selected','shape','size','span',
	        'srclang','start','src','step','style','summary','tabindex','title',
	        'type','usemap','valign','value','width','xmlns',
	
	        // SVG
	        'accent-height','accumulate','additivive','alignment-baseline',
	        'ascent','attributename','attributetype','azimuth','basefrequency',
	        'baseline-shift','begin','bias','by','clip','clip-path','clip-rule',
	        'color','color-interpolation','color-interpolation-filters','color-profile',
	        'color-rendering','cx','cy','d','dx','dy','diffuseconstant','direction',
	        'display','divisor','dur','edgemode','elevation','end','fill','fill-opacity',
	        'fill-rule','filter','flood-color','flood-opacity','font-family','font-size',
	        'font-size-adjust','font-stretch','font-style','font-variant','font-weight',
	        'fx', 'fy','g1','g2','glyph-name','glyphref','gradientunits','gradienttransform',
	        'image-rendering','in','in2','k','k1','k2','k3','k4','kerning','keypoints',
	        'keysplines','keytimes','lengthadjust','letter-spacing','kernelmatrix',
	        'kernelunitlength','lighting-color','local','marker-end','marker-mid',
	        'marker-start','markerheight','markerunits','markerwidth','maskcontentunits',
	        'maskunits','max','mask','mode','min','numoctaves','offset','operator',
	        'opacity','order','orient','orientation','origin','overflow','paint-order',
	        'path','pathlength','patterncontentunits','patterntransform','patternunits',
	        'points','preservealpha','r','rx','ry','radius','refx','refy','repeatcount',
	        'repeatdur','restart','result','rotate','scale','seed','shape-rendering',
	        'specularconstant','specularexponent','spreadmethod','stddeviation','stitchtiles',
	        'stop-color','stop-opacity','stroke-dasharray','stroke-dashoffset','stroke-linecap',
	        'stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke','stroke-width',
	        'surfacescale','targetx','targety','transform','text-anchor','text-decoration',
	        'text-rendering','textlength','u1','u2','unicode','values','viewbox',
	        'visibility','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing',
	        'wrap','writing-mode','xchannelselector','ychannelselector','x','x1','x2',
	        'y','y1','y2','z','zoomandpan',
	
	        // MathML
	        'accent','accentunder','bevelled','close','columnsalign','columnlines',
	        'columnspan','denomalign','depth','display','displaystyle','fence',
	        'frame','largeop','length','linethickness','lspace','lquote',
	        'mathbackground','mathcolor','mathsize','mathvariant','maxsize',
	        'minsize','movablelimits','notation','numalign','open','rowalign',
	        'rowlines','rowspacing','rowspan','rspace','rquote','scriptlevel',
	        'scriptminsize','scriptsizemultiplier','selection','separator',
	        'separators','stretchy','subscriptshift','supscriptshift','symmetric',
	        'voffset',
	
	        // XML
	        'xlink:href','xml:id','xlink:title','xml:space','xmlns:xlink'
	    ]);
	
	    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
	    var FORBID_TAGS = null;
	
	    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
	    var FORBID_ATTR = null;
	
	    /* Decide if custom data attributes are okay */
	    var ALLOW_DATA_ATTR = true;
	
	    /* Decide if unknown protocols are okay */
	    var ALLOW_UNKNOWN_PROTOCOLS = false;
	
	    /* Output should be safe for jQuery's $() factory? */
	    var SAFE_FOR_JQUERY = false;
	
	    /* Output should be safe for common template engines.
	     * This means, DOMPurify removes data attributes, mustaches and ERB
	     */
	    var SAFE_FOR_TEMPLATES = false;
	
	    /* Specify template detection regex for SAFE_FOR_TEMPLATES mode */
	    var MUSTACHE_EXPR = /\{\{[\s\S]*|[\s\S]*\}\}/gm;
	    var ERB_EXPR = /<%[\s\S]*|[\s\S]*%>/gm;
	
	    /* Decide if document with <html>... should be returned */
	    var WHOLE_DOCUMENT = false;
	
	    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html string.
	     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
	     */
	    var RETURN_DOM = false;
	
	    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html string */
	    var RETURN_DOM_FRAGMENT = false;
	
	    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
	     * `Node` is imported into the current `Document`. If this flag is not enabled the
	     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
	     * DOMPurify. */
	    var RETURN_DOM_IMPORT = false;
	
	    /* Output should be free from DOM clobbering attacks? */
	    var SANITIZE_DOM = true;
	
	    /* Keep element content when removing element? */
	    var KEEP_CONTENT = true;
	
	    /* Tags to ignore content of when KEEP_CONTENT is true */
	    var FORBID_CONTENTS = _addToSet({}, [
	        'audio', 'head', 'math', 'script', 'style', 'svg', 'video'
	    ]);
	
	    /* Tags that are safe for data: URIs */
	    var DATA_URI_TAGS = _addToSet({}, [
	        'audio', 'video', 'img', 'source'
	    ]);
	
	    /* Attributes safe for values like "javascript:" */
	    var URI_SAFE_ATTRIBUTES = _addToSet({}, [
	        'alt','class','for','id','label','name','pattern','placeholder',
	        'summary','title','value','style','xmlns'
	    ]);
	
	    /* Keep a reference to config to pass to hooks */
	    var CONFIG = null;
	
	    /* Ideally, do not touch anything below this line */
	    /* ______________________________________________ */
	
	    var formElement = document.createElement('form');
	
	    /**
	     * _parseConfig
	     *
	     * @param  optional config literal
	     */
	    var _parseConfig = function(cfg) {
	        /* Shield configuration object from tampering */
	        if (typeof cfg !== 'object') {
	            cfg = {};
	        }
	
	        /* Set configuration parameters */
	        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ?
	            _addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
	        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ?
	            _addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
	        FORBID_TAGS = 'FORBID_TAGS' in cfg ?
	            _addToSet({}, cfg.FORBID_TAGS) : {};
	        FORBID_ATTR = 'FORBID_ATTR' in cfg ?
	            _addToSet({}, cfg.FORBID_ATTR) : {};
	        ALLOW_DATA_ATTR     = cfg.ALLOW_DATA_ATTR     !== false; // Default true
	        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
	        SAFE_FOR_JQUERY     = cfg.SAFE_FOR_JQUERY     ||  false; // Default false
	        SAFE_FOR_TEMPLATES  = cfg.SAFE_FOR_TEMPLATES  ||  false; // Default false
	        WHOLE_DOCUMENT      = cfg.WHOLE_DOCUMENT      ||  false; // Default false
	        RETURN_DOM          = cfg.RETURN_DOM          ||  false; // Default false
	        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT ||  false; // Default false
	        RETURN_DOM_IMPORT   = cfg.RETURN_DOM_IMPORT   ||  false; // Default false
	        SANITIZE_DOM        = cfg.SANITIZE_DOM        !== false; // Default true
	        KEEP_CONTENT        = cfg.KEEP_CONTENT        !== false; // Default true
	
	        if (SAFE_FOR_TEMPLATES) {
	            ALLOW_DATA_ATTR = false;
	        }
	
	        if (RETURN_DOM_FRAGMENT) {
	            RETURN_DOM = true;
	        }
	
	        /* Merge configuration parameters */
	        if (cfg.ADD_TAGS) {
	            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
	                ALLOWED_TAGS = _cloneObj(ALLOWED_TAGS);
	            }
	            _addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
	        }
	        if (cfg.ADD_ATTR) {
	            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
	                ALLOWED_ATTR = _cloneObj(ALLOWED_ATTR);
	            }
	            _addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
	        }
	
	        /* Add #text in case KEEP_CONTENT is set to true */
	        if (KEEP_CONTENT) { ALLOWED_TAGS['#text'] = true; }
	
	        // Prevent further manipulation of configuration.
	        // Not available in IE8, Safari 5, etc.
	        if (Object && 'freeze' in Object) { Object.freeze(cfg); }
	
	        CONFIG = cfg;
	    };
	
	   /**
	     * _forceRemove
	     *
	     * @param  a DOM node
	     */
	    var _forceRemove = function(node) {
	        DOMPurify.removed.push({element: node});
	        try {
	            node.parentNode.removeChild(node);
	        } catch (e) {
	            node.outerHTML = '';
	        }
	    };
	
	   /**
	     * _removeAttribute
	     *
	     * @param  an Attribute name
	     * @param  a DOM node
	     */
	    var _removeAttribute = function(name, node) {
	        DOMPurify.removed.push({
	            attribute: node.getAttributeNode(name),
	            from: node
	        });
	        node.removeAttribute(name);
	    };
	
	   /**
	     * _initDocument
	     *
	     * @param  a string of dirty markup
	     * @return a DOM, filled with the dirty markup
	     */
	    var _initDocument = function(dirty) {
	        /* Create a HTML document using DOMParser */
	        var doc, body;
	        try {
	            doc = new DOMParser().parseFromString(dirty, 'text/html');
	        } catch (e) {}
	
	        /* Some browsers throw, some browsers return null for the code above
	           DOMParser with text/html support is only in very recent browsers.
	           See #159 why the check here is extra-thorough */
	        if (!doc || !doc.documentElement) {
	            doc = implementation.createHTMLDocument('');
	            body = doc.body;
	            body.parentNode.removeChild(body.parentNode.firstElementChild);
	            body.outerHTML = dirty;
	        }
	
	        /* Work on whole document or just its body */
	        if (typeof doc.getElementsByTagName === 'function') {
	            return doc.getElementsByTagName(
	                WHOLE_DOCUMENT ? 'html' : 'body')[0];
	        }
	        return getElementsByTagName.call(doc,
	            WHOLE_DOCUMENT ? 'html' : 'body')[0];
	    };
	
	    /**
	     * _createIterator
	     *
	     * @param  document/fragment to create iterator for
	     * @return iterator instance
	     */
	    var _createIterator = function(root) {
	        return createNodeIterator.call(root.ownerDocument || root,
	            root,
	            NodeFilter.SHOW_ELEMENT
	            | NodeFilter.SHOW_COMMENT
	            | NodeFilter.SHOW_TEXT,
	            function() { return NodeFilter.FILTER_ACCEPT; },
	            false
	        );
	    };
	
	    /**
	     * _isClobbered
	     *
	     * @param  element to check for clobbering attacks
	     * @return true if clobbered, false if safe
	     */
	    var _isClobbered = function(elm) {
	        if (elm instanceof Text || elm instanceof Comment) {
	            return false;
	        }
	        if (  typeof elm.nodeName !== 'string'
	           || typeof elm.textContent !== 'string'
	           || typeof elm.removeChild !== 'function'
	           || !(elm.attributes instanceof NamedNodeMap)
	           || typeof elm.removeAttribute !== 'function'
	           || typeof elm.setAttribute !== 'function'
	        ) {
	            return true;
	        }
	        return false;
	    };
	
	    /**
	     * _sanitizeElements
	     *
	     * @protect nodeName
	     * @protect textContent
	     * @protect removeChild
	     *
	     * @param   node to check for permission to exist
	     * @return  true if node was killed, false if left alive
	     */
	    var _sanitizeElements = function(currentNode) {
	        var tagName, content;
	        /* Execute a hook if present */
	        _executeHook('beforeSanitizeElements', currentNode, null);
	
	        /* Check if element is clobbered or can clobber */
	        if (_isClobbered(currentNode)) {
	            _forceRemove(currentNode);
	            return true;
	        }
	
	        /* Now let's check the element's type and name */
	        tagName = currentNode.nodeName.toLowerCase();
	
	        /* Execute a hook if present */
	        _executeHook('uponSanitizeElement', currentNode, {
	            tagName: tagName
	        });
	
	        /* Remove element if anything forbids its presence */
	        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
	            /* Keep content except for black-listed elements */
	            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]
	                    && typeof currentNode.insertAdjacentHTML === 'function') {
	                try {
	                    currentNode.insertAdjacentHTML('AfterEnd', currentNode.innerHTML);
	                } catch (e) {}
	            }
	            _forceRemove(currentNode);
	            return true;
	        }
	
	        /* Convert markup to cover jQuery behavior */
	        if (SAFE_FOR_JQUERY && !currentNode.firstElementChild &&
	                (!currentNode.content || !currentNode.content.firstElementChild) &&
	                /</g.test(currentNode.textContent)) {
	            DOMPurify.removed.push({element: currentNode.cloneNode()});
	            currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');
	        }
	
	        /* Sanitize element content to be template-safe */
	        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
	            /* Get the element's text content */
	            content = currentNode.textContent;
	            content = content.replace(MUSTACHE_EXPR, ' ');
	            content = content.replace(ERB_EXPR, ' ');
	            if (currentNode.textContent !== content) {
	                DOMPurify.removed.push({element: currentNode.cloneNode()});
	                currentNode.textContent = content;
	            }
	        }
	
	        /* Execute a hook if present */
	        _executeHook('afterSanitizeElements', currentNode, null);
	
	        return false;
	    };
	
	    var DATA_ATTR = /^data-[\-\w.\u00B7-\uFFFF]/;
	    var IS_ALLOWED_URI = /^(?:(?:(?:f|ht)tps?|mailto|tel):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
	    var IS_SCRIPT_OR_DATA = /^(?:\w+script|data):/i;
	    /* This needs to be extensive thanks to Webkit/Blink's behavior */
	    var ATTR_WHITESPACE = /[\x00-\x20\xA0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
	
	    /**
	     * _sanitizeAttributes
	     *
	     * @protect attributes
	     * @protect nodeName
	     * @protect removeAttribute
	     * @protect setAttribute
	     *
	     * @param   node to sanitize
	     * @return  void
	     */
	    var _sanitizeAttributes = function(currentNode) {
	        var attr, name, value, lcName, idAttr, attributes, hookEvent, l;
	        /* Execute a hook if present */
	        _executeHook('beforeSanitizeAttributes', currentNode, null);
	
	        attributes = currentNode.attributes;
	
	        /* Check if we have attributes; if not we might have a text node */
	        if (!attributes) { return; }
	
	        hookEvent = {
	            attrName: '',
	            attrValue: '',
	            keepAttr: true
	        };
	        l = attributes.length;
	
	        /* Go backwards over all attributes; safely remove bad ones */
	        while (l--) {
	            attr = attributes[l];
	            name = attr.name;
	            value = attr.value;
	            lcName = name.toLowerCase();
	
	            /* Execute a hook if present */
	            hookEvent.attrName = lcName;
	            hookEvent.attrValue = value;
	            hookEvent.keepAttr = true;
	            _executeHook('uponSanitizeAttribute', currentNode, hookEvent );
	            value = hookEvent.attrValue;
	
	            /* Remove attribute */
	            // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to
	            // remove a "name" attribute from an <img> tag that has an "id"
	            // attribute at the time.
	            if (lcName === 'name'  &&
	                    currentNode.nodeName === 'IMG' && attributes.id) {
	                idAttr = attributes.id;
	                attributes = Array.prototype.slice.apply(attributes);
	                _removeAttribute('id', currentNode);
	                _removeAttribute(name, currentNode);
	                if (attributes.indexOf(idAttr) > l) {
	                    currentNode.setAttribute('id', idAttr.value);
	                }
	            } else {
	                // This avoids a crash in Safari v9.0 with double-ids.
	                // The trick is to first set the id to be empty and then to
	                // remove the attriubute
	                if (name === 'id') {
	                    currentNode.setAttribute(name, '');
	                }
	                _removeAttribute(name, currentNode);
	            }
	
	            /* Did the hooks approve of the attribute? */
	            if (!hookEvent.keepAttr) {
	                continue;
	            }
	
	            /* Make sure attribute cannot clobber */
	            if (SANITIZE_DOM &&
	                    (lcName === 'id' || lcName === 'name') &&
	                    (value in window || value in document || value in formElement)) {
	                continue;
	            }
	
	            /* Sanitize attribute content to be template-safe */
	            if (SAFE_FOR_TEMPLATES) {
	                value = value.replace(MUSTACHE_EXPR, ' ');
	                value = value.replace(ERB_EXPR, ' ');
	            }
	
	            /* Allow valid data-* attributes: At least one character after "-"
	               (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
	               XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
	               We don't need to check the value; it's always URI safe. */
	            if (ALLOW_DATA_ATTR && DATA_ATTR.test(lcName)) {
	                // This attribute is safe
	            }
	            /* Otherwise, check the name is permitted */
	            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
	                continue;
	            }
	            /* Check value is safe. First, is attr inert? If so, is safe */
	            else if (URI_SAFE_ATTRIBUTES[lcName]) {
	                // This attribute is safe
	            }
	            /* Check no script, data or unknown possibly unsafe URI
	               unless we know URI values are safe for that attribute */
	            else if (IS_ALLOWED_URI.test(value.replace(ATTR_WHITESPACE,''))) {
	                // This attribute is safe
	            }
	            /* Keep image data URIs alive if src is allowed */
	            else if (
	                lcName === 'src' &&
	                value.indexOf('data:') === 0 &&
	                DATA_URI_TAGS[currentNode.nodeName.toLowerCase()]) {
	                // This attribute is safe
	            }
	            /* Allow unknown protocols: This provides support for links that
	               are handled by protocol handlers which may be unknown ahead of
	               time, e.g. fb:, spotify: */
	            else if (
	                ALLOW_UNKNOWN_PROTOCOLS &&
	                !IS_SCRIPT_OR_DATA.test(value.replace(ATTR_WHITESPACE,''))) {
	                // This attribute is safe
	            }
	            /* Check for binary attributes */
	            else if (!value) {
	                // binary attributes are safe at this point
	            }
	            /* Anything else, presume unsafe, do not add it back */
	            else {
	                continue;
	            }
	
	            /* Handle invalid data-* attribute set by try-catching it */
	            try {
	                currentNode.setAttribute(name, value);
	                DOMPurify.removed.pop();
	            } catch (e) {}
	        }
	
	        /* Execute a hook if present */
	        _executeHook('afterSanitizeAttributes', currentNode, null);
	    };
	
	    /**
	     * _sanitizeShadowDOM
	     *
	     * @param  fragment to iterate over recursively
	     * @return void
	     */
	    var _sanitizeShadowDOM = function(fragment) {
	        var shadowNode;
	        var shadowIterator = _createIterator(fragment);
	
	        /* Execute a hook if present */
	        _executeHook('beforeSanitizeShadowDOM', fragment, null);
	
	        while ( (shadowNode = shadowIterator.nextNode()) ) {
	            /* Execute a hook if present */
	            _executeHook('uponSanitizeShadowNode', shadowNode, null);
	
	            /* Sanitize tags and elements */
	            if (_sanitizeElements(shadowNode)) {
	                continue;
	            }
	
	            /* Deep shadow DOM detected */
	            if (shadowNode.content instanceof DocumentFragment) {
	                _sanitizeShadowDOM(shadowNode.content);
	            }
	
	            /* Check attributes, sanitize if necessary */
	            _sanitizeAttributes(shadowNode);
	        }
	
	        /* Execute a hook if present */
	        _executeHook('afterSanitizeShadowDOM', fragment, null);
	    };
	
	    /**
	     * _executeHook
	     * Execute user configurable hooks
	     *
	     * @param  {String} entryPoint  Name of the hook's entry point
	     * @param  {Node} currentNode
	     */
	    var _executeHook = function(entryPoint, currentNode, data) {
	        if (!hooks[entryPoint]) { return; }
	
	        hooks[entryPoint].forEach(function(hook) {
	            hook.call(DOMPurify, currentNode, data, CONFIG);
	        });
	    };
	
	    /**
	     * sanitize
	     * Public method providing core sanitation functionality
	     *
	     * @param {String} dirty string
	     * @param {Object} configuration object
	     */
	    DOMPurify.sanitize = function(dirty, cfg) {
	        var body, currentNode, oldNode, nodeIterator, returnNode;
	        /* Make sure we have a string to sanitize.
	           DO NOT return early, as this will return the wrong type if
	           the user has requested a DOM object rather than a string */
	        if (!dirty) {
	            dirty = '';
	        }
	
	        /* Stringify, in case dirty is an object */
	        if (typeof dirty !== 'string') {
	            if (typeof dirty.toString !== 'function') {
	                throw new TypeError('toString is not a function');
	            } else {
	                dirty = dirty.toString();
	            }
	        }
	
	        /* Check we can run. Otherwise fall back or ignore */
	        if (!DOMPurify.isSupported) {
	            if (typeof window.toStaticHTML === 'object'
	                || typeof window.toStaticHTML === 'function') {
	                return window.toStaticHTML(dirty);
	            }
	            return dirty;
	        }
	
	        /* Assign config vars */
	        _parseConfig(cfg);
	
	        /* Clean up removed elements */
	        DOMPurify.removed = [];
	
	        /* Exit directly if we have nothing to do */
	        if (!RETURN_DOM && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {
	            return dirty;
	        }
	
	        /* Initialize the document to work on */
	        body = _initDocument(dirty);
	
	        /* Check we have a DOM node from the data */
	        if (!body) {
	            return RETURN_DOM ? null : '';
	        }
	
	        /* Get node iterator */
	        nodeIterator = _createIterator(body);
	
	        /* Now start iterating over the created document */
	        while ( (currentNode = nodeIterator.nextNode()) ) {
	
	            /* Fix IE's strange behavior with manipulated textNodes #89 */
	            if (currentNode.nodeType === 3 && currentNode === oldNode) {
	                continue;
	            }
	
	            /* Sanitize tags and elements */
	            if (_sanitizeElements(currentNode)) {
	                continue;
	            }
	
	            /* Shadow DOM detected, sanitize it */
	            if (currentNode.content instanceof DocumentFragment) {
	                _sanitizeShadowDOM(currentNode.content);
	            }
	
	            /* Check attributes, sanitize if necessary */
	            _sanitizeAttributes(currentNode);
	
	            oldNode = currentNode;
	        }
	
	        /* Return sanitized string or DOM */
	        if (RETURN_DOM) {
	
	            if (RETURN_DOM_FRAGMENT) {
	                returnNode = createDocumentFragment.call(body.ownerDocument);
	
	                while (body.firstChild) {
	                    returnNode.appendChild(body.firstChild);
	                }
	            } else {
	                returnNode = body;
	            }
	
	            if (RETURN_DOM_IMPORT) {
	                /* adoptNode() is not used because internal state is not reset
	                   (e.g. the past names map of a HTMLFormElement), this is safe
	                   in theory but we would rather not risk another attack vector.
	                   The state that is cloned by importNode() is explicitly defined
	                   by the specs. */
	                returnNode = importNode.call(originalDocument, returnNode, true);
	            }
	
	            return returnNode;
	        }
	
	        return WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
	    };
	
	    /**
	     * addHook
	     * Public method to add DOMPurify hooks
	     *
	     * @param {String} entryPoint
	     * @param {Function} hookFunction
	     */
	    DOMPurify.addHook = function(entryPoint, hookFunction) {
	        if (typeof hookFunction !== 'function') { return; }
	        hooks[entryPoint] = hooks[entryPoint] || [];
	        hooks[entryPoint].push(hookFunction);
	    };
	
	    /**
	     * removeHook
	     * Public method to remove a DOMPurify hook at a given entryPoint
	     * (pops it from the stack of hooks if more are present)
	     *
	     * @param {String} entryPoint
	     * @return void
	     */
	    DOMPurify.removeHook = function(entryPoint) {
	        if (hooks[entryPoint]) {
	            hooks[entryPoint].pop();
	        }
	    };
	
	    /**
	     * removeHooks
	     * Public method to remove all DOMPurify hooks at a given entryPoint
	     *
	     * @param  {String} entryPoint
	     * @return void
	     */
	    DOMPurify.removeHooks = function(entryPoint) {
	        if (hooks[entryPoint]) {
	            hooks[entryPoint] = [];
	        }
	    };
	
	    /**
	     * removeAllHooks
	     * Public method to remove all DOMPurify hooks
	     *
	     * @return void
	     */
	    DOMPurify.removeAllHooks = function() {
	        hooks = {};
	    };
	
	    return DOMPurify;
	}));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(7);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 7 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 8 */
/***/ function(module, exports) {

	var clienttelemetry_build;!function(e){e.version="2.7.2"}(clienttelemetry_build||(clienttelemetry_build={}));var Microsoft;!function(e){var t;!function(e){!function(e){e[e.BT_STOP=0]="BT_STOP",e[e.BT_STOP_BASE=1]="BT_STOP_BASE",e[e.BT_BOOL=2]="BT_BOOL",e[e.BT_UINT8=3]="BT_UINT8",e[e.BT_UINT16=4]="BT_UINT16",e[e.BT_UINT32=5]="BT_UINT32",e[e.BT_UINT64=6]="BT_UINT64",e[e.BT_FLOAT=7]="BT_FLOAT",e[e.BT_DOUBLE=8]="BT_DOUBLE",e[e.BT_STRING=9]="BT_STRING",e[e.BT_STRUCT=10]="BT_STRUCT",e[e.BT_LIST=11]="BT_LIST",e[e.BT_SET=12]="BT_SET",e[e.BT_MAP=13]="BT_MAP",e[e.BT_INT8=14]="BT_INT8",e[e.BT_INT16=15]="BT_INT16",e[e.BT_INT32=16]="BT_INT32",e[e.BT_INT64=17]="BT_INT64",e[e.BT_WSTRING=18]="BT_WSTRING",e[e.BT_UNAVAILABLE=127]="BT_UNAVAILABLE"}(e.BondDataType||(e.BondDataType={}));e.BondDataType;!function(e){e[e.MARSHALED_PROTOCOL=0]="MARSHALED_PROTOCOL",e[e.MAFIA_PROTOCOL=17997]="MAFIA_PROTOCOL",e[e.COMPACT_PROTOCOL=16963]="COMPACT_PROTOCOL",e[e.JSON_PROTOCOL=21322]="JSON_PROTOCOL",e[e.PRETTY_JSON_PROTOCOL=20554]="PRETTY_JSON_PROTOCOL",e[e.SIMPLE_PROTOCOL=20563]="SIMPLE_PROTOCOL"}(e.ProtocolType||(e.ProtocolType={}));e.ProtocolType}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var Microsoft;!function(e){var t;!function(e){var t;!function(e){var t=function(){function e(){this._buffer=[]}return e.prototype.Add=function(e){for(var t=0;t<this._buffer.length&&this._buffer[t]!=e;++t);t==this._buffer.length&&this._buffer.push(e)},e.prototype.Count=function(){return this._buffer.length},e.prototype.GetBuffer=function(){return this._buffer},e}();e.Set=t;var n=function(){function e(){this._buffer=[]}return e.prototype.Add=function(e,t){this._getIndex(e)==-1&&this._buffer.push({Key:e,Value:t})},e.prototype.AddOrReplace=function(e,t){var n=this._getIndex(e);n>=0?this._buffer[n]={Key:e,Value:t}:this._buffer.push({Key:e,Value:t})},e.prototype.Remove=function(e){var t=this._getIndex(e);t>=0&&this._buffer.splice(t,1)},e.prototype.Count=function(){return this._buffer.length},e.prototype.GetBuffer=function(){return this._buffer},e.prototype.ContainsKey=function(e){return this._getIndex(e)>=0},e.prototype.Get=function(e){var t=this._getIndex(e);return t>=0?this._buffer[t].Value:null},e.prototype._getIndex=function(e){for(var t=0,n=-1;t<this._buffer.length;++t)if(this._buffer[t].Key==e){n=t;break}return n},e}();e.Map=n}(t=e.Collections||(e.Collections={}))}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var Microsoft;!function(e){var t;!function(t){var n;!function(e){var n=function(){function e(){}return e.GetBytes=function(e){for(var t=[],n=0;n<e.length;++n){var i=e.charCodeAt(n);i<128?t.push(i):i<2048?t.push(192|i>>6,128|63&i):i<55296||i>=57344?t.push(224|i>>12,128|i>>6&63,128|63&i):(i=65536+((1023&i)<<10|1023&e.charCodeAt(++n)),t.push(240|i>>18,128|i>>12&63,128|i>>6&63,128|63&i))}return t},e}();e.Utf8=n;var i=function(){function e(){}return e.GetString=function(e){var t,n,i,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=[],s=e.length%3,a=function(e){return[r.charAt(e>>18&63),r.charAt(e>>12&63),r.charAt(e>>6&63),r.charAt(63&e)].join("")};for(t=0,i=e.length-s;t<i;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],o.push(a(n));switch(s){case 1:n=e[e.length-1],o.push(r.charAt(n>>2)),o.push(r.charAt(n<<4&63)),o.push("==");break;case 2:n=(e[e.length-2]<<8)+e[e.length-1],o.push(r.charAt(n>>10)),o.push(r.charAt(n>>4&63)),o.push(r.charAt(n<<2&63)),o.push("=")}return o.join("")},e}();e.Base64=i;var o=function(){function e(){}return e.GetBytes=function(e){for(var t=[];4294967168&e;)t.push(127&e|128),e>>>=7;return t.push(127&e),t},e}();e.Varint=o;var s=function(){function e(){}return e.GetBytes=function(e){for(var t=e.low,n=e.high,i=[];n||4294967168&t;)i.push(127&t|128),t=(127&n)<<25|t>>>7,n>>>=7;return i.push(127&t),i},e}();e.Varint64=s;var a=function(){function e(){}return e.GetBytes=function(e){if(t.BrowserChecker.IsDataViewSupport()){var n=new DataView(new ArrayBuffer(4));n.setFloat32(0,e,!0);for(var i=[],o=0;o<4;++o)i.push(n.getUint8(o));return i}return r.ConvertNumberToArray(e,!1)},e}();e.Float=a;var u=function(){function e(){}return e.GetBytes=function(e){if(t.BrowserChecker.IsDataViewSupport()){var n=new DataView(new ArrayBuffer(8));n.setFloat64(0,e,!0);for(var i=[],o=0;o<8;++o)i.push(n.getUint8(o));return i}return r.ConvertNumberToArray(e,!0)},e}();e.Double=u;var d=function(){function e(){}return e.EncodeZigzag16=function(e){return e=t.Number.ToInt16(e),e<<1^e>>15},e.EncodeZigzag32=function(e){return e=t.Number.ToInt32(e),e<<1^e>>31},e.EncodeZigzag64=function(e){var n=e.low,i=e.high,r=i<<1|n>>>31,o=n<<1;2147483648&i&&(r=~r,o=~o);var s=new t.UInt64("0");return s.low=o,s.high=r,s},e}();e.Zigzag=d}(n=t.Encoding||(t.Encoding={}));var i;!function(n){var i=function(){function e(){}return e.GetString=function(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];if(i<=191)t.push(String.fromCharCode(i));else if(i<=223){var r=e[++n];t.push(String.fromCharCode((31&i)<<6|63&r))}else if(i<=239){var r=e[++n],o=e[++n];t.push(String.fromCharCode((15&i)<<12|(63&r)<<6|63&o))}else{var r=e[++n],o=e[++n],s=e[++n];i=(7&i)<<18|(63&r)<<12|(63&o)<<6|63&s,i-=65536,t.push(String.fromCharCode(55296|i>>10&1023)),t.push(String.fromCharCode(56320|1023&i))}}return t.join("")},e}();n.Utf8=i;var o=function(){function e(){}return e.GetBytes=function(e){for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n=[],i=0;i<e.length;++i){var r=t.indexOf(e.charAt(i++)),o=t.indexOf(e.charAt(i++)),s=t.indexOf(e.charAt(i++)),a=t.indexOf(e.charAt(i));n.push(r<<2|o>>4),s>=0&&(n.push(o<<4&240|s>>2),a>=0&&n.push(s<<6&192|a))}return n},e}();n.Base64=o;var s=function(){function t(){}return t.GetInt64=function(t){var n=new e.Bond.Int64("0"),i=this._Read(t);return n.low=i[0],i.length>1&&(n.high=i[1]),n},t.GetNumber=function(e){return this._Read(e)[0]},t._Read=function(e){for(var t=[],n=0,i=!0,r=0;i;){var o=e.shift();if(i=0!=(128&o),o=127&o,!(r<28)){n|=o<<r,t.push(n),n=o>>4,r=3;break}n|=o<<r,r+=7}for(;i;){var o=e.shift();if(i=0!=(128&o),o=127&o,n|=o<<r,r+=7,r>=32)break}return t.push(n),t},t}();n.Varint=s;var a=function(){function e(){}return e.GetNumber=function(e){if(t.BrowserChecker.IsDataViewSupport()){for(var n=new DataView(new ArrayBuffer(4)),i=0;i<4;++i)n.setUint8(i,e[i]);return n.getFloat32(0,!0)}return r.ConvertArrayToNumber(e,!1)},e}();n.Float=a;var u=function(){function e(){}return e.GetNumber=function(e){if(t.BrowserChecker.IsDataViewSupport()){for(var n=new DataView(new ArrayBuffer(8)),i=0;i<8;++i)n.setUint8(i,e[i]);return n.getFloat64(0,!0)}return r.ConvertArrayToNumber(e,!0)},e}();n.Double=u;var d=function(){function t(){}return t.DecodeZigzag16=function(e){return((65535&e)>>>1^-(1&e))<<16>>16},t.DecodeZigzag32=function(e){return e>>>1^-(1&e)},t.DecodeZigzag64=function(t){var n=1&t.high,i=t.high>>>1,r=1&t.low,o=t.low>>>1;o=n<<31|o,r&&(o^=4294967295,i^=4294967295);var s=new e.Bond.UInt64("0");return s.low=o,s.high=i,s},t}();n.Zigzag=d}(i=t.Decoding||(t.Decoding={}));var r=function(){function e(){}return e.ConvertNumberToArray=function(e,t){if(!e)return t?this._doubleZero:this._floatZero;var n=t?11:8,i=t?52:23,r=(1<<n-1)-1,o=1-r,s=r,a=e<0?1:0;e=Math.abs(e);for(var u=Math.floor(e),d=e-u,c=2*(r+2)+i,l=new Array(c),_=0;_<c;)l[_++]=0;for(_=r+2;_&&u;)l[--_]=u%2,u=Math.floor(u/2);for(_=r+1;_<c-1&&d>0;)d*=2,d>=1?(l[++_]=1,--d):l[++_]=0;for(var f=0;f<c&&!l[f];++f);var h=r+1-f,p=f+i;if(l[p+1]){for(_=p;_>f&&!(l[_]=1-l[_]);--_);_==f&&++h}if(h>s||u)return a?t?this._doubleNegInifinity:this._floatNegInifinity:t?this._doubleInifinity:this._floatInifinity;if(h<o)return t?this._doubleZero:this._floatZero;if(t){var I=0;for(_=0;_<20;++_)I=I<<1|l[++f];for(var T=0;_<52;++_)T=T<<1|l[++f];I|=h+r<<20,I=a<<31|2147483647&I;var S=[255&T,T>>8&255,T>>16&255,T>>>24,255&I,I>>8&255,I>>16&255,I>>>24];return S}var g=0;for(_=0;_<23;++_)g=g<<1|l[++f];g|=h+r<<23,g=a<<31|2147483647&g;var S=[255&g,g>>8&255,g>>16&255,g>>>24];return S},e.ConvertArrayToNumber=function(e,n){var i=n?11:8,r=(1<<i-1)-1,o=0!=(128&e[n?7:3]),s=n?(127&e[7])<<4|(240&e[6])>>4:(127&e[3])<<1|(128&e[2])>>7;if(255==s)throw new t.Exception("Not a valid float/double buffer.");var a=1,u=1;if(n){var d=(15&e[6])<<28|(255&e[5])<<20|(255&e[4])<<12,c=e[3]<<24|(255&e[2])<<16|(255&e[1])<<8|255&e[0];if(!s&&!d&&!c)return 0;for(var l=0;l<20;++l)u/=2,d<0&&(a+=u),d<<=1;for(var l=0;l<32;++l)u/=2,c<0&&(a+=u),c<<=1}else{var _=(127&e[2])<<25|(255&e[1])<<17|(255&e[0])<<9;if(!s&&!_)return 0;for(var l=0;l<23;++l)u/=2,_<0&&(a+=u),_<<=1}return a*=Math.pow(2,s-r),o?0-a:a},e._floatZero=[0,0,0,0],e._doubleZero=[0,0,0,0,0,0,0,0],e._floatInifinity=[0,0,128,127],e._floatNegInifinity=[0,0,128,255],e._doubleInifinity=[0,0,0,0,0,0,240,127],e._doubleNegInifinity=[0,0,0,0,0,0,240,255],e}()}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var Microsoft;!function(e){var t;!function(e){var t;!function(t){var n=function(){function t(){this._buffer=[]}return t.prototype.WriteByte=function(t){this._buffer.push(e.Number.ToByte(t))},t.prototype.Write=function(e,t,n){for(;n--;)this.WriteByte(e[t++])},t.prototype.GetBuffer=function(){return this._buffer},t}();t.MemoryStream=n}(t=e.IO||(e.IO={}))}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var Microsoft;!function(e){var t;!function(e){var t=function(){function e(e,t){this.Type=e,this.Id=t}return e}();e.FieldTag=t;var n=function(){function e(e,t){this.ElementType=e,this.Size=t}return e}();e.ContainerTag=n;var i=function(){function e(e,t,n){this.KeyType=e,this.ValueType=t,this.Size=n}return e}();e.KeyValueContainerTag=i;var r=function(){function e(){}return e}();e.Bonded=r;var o=function(){function e(e){this.low=0,this.high=0,this.low=parseInt(e),this.low<0&&(this.high=-1)}return e.prototype.Equals=function(t){var n=new e(t);return this.low==n.low&&this.high==n.high},e}();e.Int64=o;var s=function(){function e(e){this.low=0,this.high=0,this.low=parseInt(e)}return e.prototype.Equals=function(t){var n=new e(t);return this.low==n.low&&this.high==n.high},e}();e.UInt64=s;var a=function(){function e(){}return e.ToByte=function(e){return this.ToUInt8(e)},e.ToInt8=function(e){var t=(128&e)<<24>>24;return 127&e|t},e.ToInt16=function(e){var t=(32768&e)<<16>>16;return 32767&e|t},e.ToInt32=function(e){var t=2147483648&e;return 2147483647&e|t},e.ToUInt8=function(e){return 255&e},e.ToUInt16=function(e){return 65535&e},e.ToUInt32=function(e){return 4294967295&e},e}();e.Number=a;var u=function(){function e(e){this.Message=e}return e}();e.Exception=u;var d=function(){function e(){}return e}();e.KeyValuePair=d;var c=function(){function e(){}return e.IsDataViewSupport=function(){return"undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},e}();e.BrowserChecker=c}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var Microsoft;!function(e){var t;!function(e){var t=function(){function t(e){this._stream=e}return t.prototype.WriteBlob=function(e){this._stream.Write(e,0,e.length)},t.prototype.WriteBool=function(e){this._stream.WriteByte(e?1:0)},t.prototype.WriteContainerBegin=function(e,t){this.WriteUInt8(t),this.WriteUInt32(e)},t.prototype.WriteMapContainerBegin=function(e,t,n){this.WriteUInt8(t),this.WriteUInt8(n),this.WriteUInt32(e)},t.prototype.WriteContainerEnd=function(){},t.prototype.WriteDouble=function(t){var n=e.Encoding.Double.GetBytes(t);this._stream.Write(n,0,n.length)},t.prototype.WriteFloat=function(t){var n=e.Encoding.Float.GetBytes(t);this._stream.Write(n,0,n.length)},t.prototype.WriteFieldBegin=function(e,t,n){t<=5?this._stream.WriteByte(e|t<<5):t<=255?(this._stream.WriteByte(192|e),this._stream.WriteByte(t)):(this._stream.WriteByte(224|e),this._stream.WriteByte(t),this._stream.WriteByte(t>>8))},t.prototype.WriteFieldEnd=function(){},t.prototype.WriteFieldOmitted=function(e,t,n){},t.prototype.WriteInt16=function(t){t=e.Encoding.Zigzag.EncodeZigzag16(t),this.WriteUInt16(t)},t.prototype.WriteInt32=function(t){t=e.Encoding.Zigzag.EncodeZigzag32(t),this.WriteUInt32(t)},t.prototype.WriteInt64=function(t){this.WriteUInt64(e.Encoding.Zigzag.EncodeZigzag64(t))},t.prototype.WriteInt8=function(t){this._stream.WriteByte(e.Number.ToInt8(t))},t.prototype.WriteString=function(t){if(""==t)this.WriteUInt32(0);else{var n=e.Encoding.Utf8.GetBytes(t);this.WriteUInt32(n.length),this._stream.Write(n,0,n.length)}},t.prototype.WriteStructBegin=function(e,t){},t.prototype.WriteStructEnd=function(t){this.WriteUInt8(t?e.BondDataType.BT_STOP_BASE:e.BondDataType.BT_STOP)},t.prototype.WriteUInt16=function(t){var n=e.Encoding.Varint.GetBytes(e.Number.ToUInt16(t));this._stream.Write(n,0,n.length)},t.prototype.WriteUInt32=function(t){var n=e.Encoding.Varint.GetBytes(e.Number.ToUInt32(t));this._stream.Write(n,0,n.length)},t.prototype.WriteUInt64=function(t){var n=e.Encoding.Varint64.GetBytes(t);this._stream.Write(n,0,n.length)},t.prototype.WriteUInt8=function(t){this._stream.WriteByte(e.Number.ToUInt8(t))},t.prototype.WriteWString=function(e){this.WriteUInt32(e.length);for(var t=0;t<e.length;++t){var n=e.charCodeAt(t);this._stream.WriteByte(n),this._stream.WriteByte(n>>>8)}},t}();e.CompactBinaryProtocolWriter=t;var n=function(){function e(){}return e}();e.CompactBinaryProtocolReader=n}(t=e.Bond||(e.Bond={}))}(Microsoft||(Microsoft={}));var sct;!function(e){var t=function(){function t(){}return t.IsSafari=function(){if(null===t._isSafari)if("undefined"!=typeof navigator&&navigator.userAgent){var e=navigator.userAgent.toLowerCase();e.indexOf("safari")>=0&&e.indexOf("chrome")<0?t._isSafari=!0:t._isSafari=!1}else t._isSafari=!1;return t._isSafari},t.IsReactNative=function(){return null===t._isReactNative&&("undefined"!=typeof navigator&&navigator.product?t._isReactNative="ReactNative"===navigator.product:t._isReactNative=!1),t._isReactNative},t.IsUint8ArrSupported=function(){return!e.Utils.IsSafari()&&"undefined"!=typeof Uint8Array&&!e.Utils.IsReactNative()},t.ajax=function(e,n){var i=t._createConnection();if(e.headers){var r="qsp=true";for(var o in e.headers)r+="&",r+=encodeURIComponent(o),r+="=",r+=encodeURIComponent(e.headers[o]);e.url.indexOf("?")<0?e.url+="?":e.url+="&",e.url+=r}i.open(e.type,e.url,!n),e.complete&&(i.onload=function(){"undefined"==typeof i.status&&(i.status=200),e.complete(i)},i.ontimeout=function(){"undefined"==typeof i.status&&(i.status=500),e.complete(i)},i.onerror=function(){e.complete(i)}),i.send(e.data)},t.keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)e.hasOwnProperty(n)&&t.push(n);return t},t.IsUsingXDomainRequest=function(){if(null==t._usingXDomainRequest){var e=new XMLHttpRequest;"undefined"==typeof e.withCredentials&&"undefined"!=typeof XDomainRequest?t._usingXDomainRequest=!0:t._usingXDomainRequest=!1}return t._usingXDomainRequest},t._createConnection=function(){var e=new XMLHttpRequest;return t.IsUsingXDomainRequest()?new XDomainRequest:e},t._isSafari=null,t._isReactNative=null,t._usingXDomainRequest=null,t}();e.Utils=t}(sct||(sct={}));var microsoft;!function(e){var t;!function(e){var t;!function(e){var t;!function(t){var n=function(){function e(){}return e.GetGuid=function(){var e=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1,5)};return[e(),e(),"-",e(),"-",e(),"-",e(),"-",e(),e(),e()].join("")},e.GetTimeStamp=function(){var e=(new Date).getTime(),t=new Microsoft.Bond.Int64("0");return t.low=4294967295&e,t.high=Math.floor(e/4294967296),t},e.GetTimeStampWithValue=function(e){var t=new Microsoft.Bond.Int64("0");return t.low=4294967295&e,t.high=Math.floor(e/4294967296),t},e}();t.utils=n,function(e){e[e.NotSet=0]="NotSet",e[e.Event=1]="Event",e[e.PerformanceCounter=2]="PerformanceCounter",e[e.Anomaly=3]="Anomaly",e[e.Prediction=4]="Prediction",e[e.TraceLog=5]="TraceLog",e[e.EventSourceLog=6]="EventSourceLog",e[e.HttpLog=7]="HttpLog",e[e.PerformanceCounterAzure=8]="PerformanceCounterAzure",e[e.PerformanceCounterGfs=9]="PerformanceCounterGfs"}(t.RecordType||(t.RecordType={}));t.RecordType;!function(e){e[e.NotSet=0]="NotSet",e[e.O365=1]="O365",e[e.SkypeBI=2]="SkypeBI",e[e.SkypeData=3]="SkypeData"}(t.PIIScrubber||(t.PIIScrubber={}));t.PIIScrubber;!function(e){e[e.NotSet=0]="NotSet",e[e.DistinguishedName=1]="DistinguishedName",e[e.GenericData=2]="GenericData",e[e.IPV4Address=3]="IPV4Address",e[e.IPv6Address=4]="IPv6Address",e[e.MailSubject=5]="MailSubject",e[e.PhoneNumber=6]="PhoneNumber",e[e.QueryString=7]="QueryString",e[e.SipAddress=8]="SipAddress",e[e.SmtpAddress=9]="SmtpAddress",e[e.Identity=10]="Identity",e[e.Uri=11]="Uri",e[e.Fqdn=12]="Fqdn",e[e.IPV4AddressLegacy=13]="IPV4AddressLegacy"}(t.PIIKind||(t.PIIKind={}));t.PIIKind;!function(e){e[e.Unknown=0]="Unknown",e[e.MSACID=1]="MSACID",e[e.MSAPUID=2]="MSAPUID",e[e.ANID=3]="ANID",e[e.OrgIdCID=4]="OrgIdCID",e[e.OrgIdPUID=5]="OrgIdPUID",e[e.UserObjectId=6]="UserObjectId",e[e.Skype=7]="Skype",e[e.Yammer=8]="Yammer",e[e.EmailAddress=9]="EmailAddress",e[e.PhoneNumber=10]="PhoneNumber",e[e.SipAddress=11]="SipAddress",e[e.MUID=12]="MUID"}(t.UserIdType||(t.UserIdType={}));var i=(t.UserIdType,function(){function t(){this.ScrubType=e.datamodels.PIIScrubber.NotSet,this.Kind=e.datamodels.PIIKind.NotSet,this.RawContent=""}return t.prototype.Write=function(e){this.WriteImpl(e,!1)},t.prototype.WriteImpl=function(t,n){t.WriteStructBegin(null,n),this.ScrubType!=e.datamodels.PIIScrubber.NotSet?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32,1,null),t.WriteInt32(this.ScrubType),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32,1,null),this.Kind!=e.datamodels.PIIKind.NotSet?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32,2,null),t.WriteInt32(this.Kind),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32,2,null),""!=this.RawContent?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,3,null),t.WriteString(this.RawContent),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,3,null),t.WriteStructEnd(n)},t.prototype.Read=function(e){this.ReadImpl(e,!1)},t.prototype.ReadImpl=function(e,t){},t}());t.PII=i;var r=function(){function t(){this.Id=n.GetGuid(),this.Timestamp=n.GetTimeStamp(),this.Type="",this.EventType="",this.Extension=new Microsoft.Bond.Collections.Map,this.RecordType=e.datamodels.RecordType.NotSet,this.PIIExtensions=new Microsoft.Bond.Collections.Map}return t.prototype.AddOrReplacePII=function(t,n,i){var r=new e.datamodels.PII;r.RawContent=n,r.Kind=i,r.ScrubType=e.datamodels.PIIScrubber.O365,this.PIIExtensions.AddOrReplace(t,r)},t.prototype.Write=function(e){this.WriteImpl(e,!1)},t.prototype.WriteImpl=function(t,n){if(t.WriteStructBegin(null,n),""!=this.Id?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,1,null),t.WriteString(this.Id),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,1,null),this.Timestamp.Equals("0")?t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64,3,null):(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64,3,null),t.WriteInt64(this.Timestamp),t.WriteFieldEnd()),""!=this.Type?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,5,null),t.WriteString(this.Type),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,5,null),""!=this.EventType?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,6,null),t.WriteString(this.EventType),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,6,null),this.Extension.Count()){t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP,13,null),t.WriteMapContainerBegin(this.Extension.Count(),Microsoft.Bond.BondDataType.BT_STRING,Microsoft.Bond.BondDataType.BT_STRING);for(var i=0;i<this.Extension.GetBuffer().length;++i)t.WriteString(this.Extension.GetBuffer()[i].Key),t.WriteString(this.Extension.GetBuffer()[i].Value);t.WriteContainerEnd(),t.WriteFieldEnd()}else t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP,13,null);if(this.RecordType!=e.datamodels.RecordType.NotSet?(t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32,24,null),t.WriteInt32(this.RecordType),t.WriteFieldEnd()):t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32,24,null),this.PIIExtensions.Count()){t.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP,30,null),t.WriteMapContainerBegin(this.PIIExtensions.Count(),Microsoft.Bond.BondDataType.BT_STRING,Microsoft.Bond.BondDataType.BT_STRUCT);for(var r=0;r<this.PIIExtensions.GetBuffer().length;++r)t.WriteString(this.PIIExtensions.GetBuffer()[r].Key),this.PIIExtensions.GetBuffer()[r].Value.WriteImpl(t,!1);t.WriteContainerEnd(),t.WriteFieldEnd()}else t.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP,30,null);t.WriteStructEnd(n)},t.prototype.Read=function(e){this.ReadImpl(e,!1)},t.prototype.ReadImpl=function(e,t){},t}();t.Record=r;var o=function(){function e(){this.Source="",this.DataPackageId="",this.Timestamp=new Microsoft.Bond.Int64("0"),this.Records=[]}return e.prototype.Write=function(e){this.WriteImpl(e,!1)},e.prototype.WriteImpl=function(e,t){if(e.WriteStructBegin(null,t),""!=this.Source?(e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,2,null),e.WriteString(this.Source),e.WriteFieldEnd()):e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,2,null),""!=this.DataPackageId?(e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING,5,null),e.WriteString(this.DataPackageId),e.WriteFieldEnd()):e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING,5,null),this.Timestamp.Equals("0")?e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64,6,null):(e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64,6,null),e.WriteInt64(this.Timestamp),e.WriteFieldEnd()),this.Records.length){e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST,8,null),e.WriteContainerBegin(this.Records.length,Microsoft.Bond.BondDataType.BT_STRUCT);for(var n=0;n<this.Records.length;++n)this.Records[n].WriteImpl(e,!1);e.WriteContainerEnd(),e.WriteFieldEnd()}else e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST,8,null);e.WriteStructEnd(t)},e.prototype.Read=function(e){this.ReadImpl(e,!1)},e.prototype.ReadImpl=function(e,t){},e}();t.DataPackage=o;var s=function(){function e(){this.DataPackages=[],this.RequestRetryCount=0}return e.prototype.Write=function(e){this.WriteImpl(e,!1)},e.prototype.WriteImpl=function(e,t){if(e.WriteStructBegin(null,t),this.DataPackages.length){e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST,1,null),e.WriteContainerBegin(this.DataPackages.length,Microsoft.Bond.BondDataType.BT_STRUCT);for(var n=0;n<this.DataPackages.length;++n)this.DataPackages[n].WriteImpl(e,!1);e.WriteContainerEnd(),e.WriteFieldEnd()}else e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST,1,null);0!=this.RequestRetryCount?(e.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32,2,null),e.WriteInt32(this.RequestRetryCount),e.WriteFieldEnd()):e.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32,2,null),e.WriteStructEnd(t)},e.prototype.Read=function(e){this.ReadImpl(e,!1)},e.prototype.ReadImpl=function(e,t){},e}();t.ClientToCollectorRequest=s}(t=e.datamodels||(e.datamodels={}))}(t=e.telemetry||(e.telemetry={}))}(t=e.applications||(e.applications={}))}(microsoft||(microsoft={}));var microsoft;!function(e){var t;!function(e){var t;!function(e){var t;!function(t){!function(e){e[e.SENT=0]="SENT",e[e.SEND_FAILED=1]="SEND_FAILED"}(t.CallbackEventType||(t.CallbackEventType={}));var n=t.CallbackEventType;!function(e){e[e.DATARV_ERROR_OK=0]="DATARV_ERROR_OK",e[e.DATARV_ERROR_INVALID_EVENT=1]="DATARV_ERROR_INVALID_EVENT",e[e.DATARV_ERROR_INVALID_CONFIG=2]="DATARV_ERROR_INVALID_CONFIG",e[e.DATARV_ERROR_INVALID_DEPENDENCIES=3]="DATARV_ERROR_INVALID_DEPENDENCIES",e[e.DATARV_ERROR_INVALID_STATUS=4]="DATARV_ERROR_INVALID_STATUS",e[e.DATARV_ERROR_INVALID_ARG=5]="DATARV_ERROR_INVALID_ARG"}(t.DATARV_ERROR||(t.DATARV_ERROR={}));var i=t.DATARV_ERROR,r=function(){function e(e){this._errorCode=i.DATARV_ERROR_OK,this._errorCode=e}return e.prototype.ErrorCode=function(){return this._errorCode},e.prototype.toString=function(){switch(this._errorCode){case i.DATARV_ERROR_OK:return"DATARV_ERROR_OK";case i.DATARV_ERROR_INVALID_EVENT:return"Event is invalid. Either event.Id is empty, or event.Timestamp is empty, or event.EventType is empty.";case i.DATARV_ERROR_INVALID_CONFIG:return"Invalid configuration. CollectorUrl is missing.";case i.DATARV_ERROR_INVALID_DEPENDENCIES:return"DATARV_ERROR_INVALID_DEPENDENCIES";case i.DATARV_ERROR_INVALID_STATUS:return"Telemetry Manager is not initialized.";case i.DATARV_ERROR_INVALID_ARG:return"TenantToken is null or empty, or events is null.";default:return"Unknown error"}},e}();t.Exception=r;var o=function(){function e(){}return e}();t.TelemetryConfig=o;var s=function(){function e(){}return e.CreateTelemetryManager=function(){return new d},e}();t.TelemetryManagerFactory=s;var a,u=function(){function e(){}return e.MaxPackageSizeInBytes=function(){return 3e6},e.TimeIntervalForNextSendInMS=function(){return 1e3},e}();!function(e){e[e.Created=0]="Created",e[e.Initialized=1]="Initialized",e[e.Started=2]="Started"}(a||(a={}));var d=function(){function t(){this._MaxPackageSizeInBytes=u.MaxPackageSizeInBytes(),this._listeners=[],this._status=a.Created,this._etag=null,this._testServerResponseHook=null,this._isPaused=!1}return t.prototype.Initialize=function(e){if(this._status!=a.Created)throw new r(i.DATARV_ERROR_INVALID_STATUS);if(!e||!e.collectorUrl)throw new r(i.DATARV_ERROR_INVALID_CONFIG);this._config=e,this._Reset(),this._status=a.Initialized,this._Verbose("Initialize() done")},t.prototype.AddListener=function(e){if(this._status<a.Initialized)throw new r(i.DATARV_ERROR_INVALID_STATUS);this._Verbose(["AddListener(), status: ",this._status," old length: ",this._listeners.length," func: ",e].join(""));for(var t=0;t<this._listeners.length;++t)if(this._listeners[t]==e)return void this._Verbose("the listener has been added already, index: "+t);this._listeners.push(e),this._Verbose("AddListener() done, the new length: "+this._listeners.length)},t.prototype.RemoveListener=function(e){if(this._status<a.Initialized)throw new r(i.DATARV_ERROR_INVALID_STATUS);this._Verbose(["RemoveListener(), status: ",this._status," old length: ",this._listeners.length," func: ",e].join(""));for(var t=0;t<this._listeners.length;++t)if(this._listeners[t]==e)return 1==this._listeners.length?this._listeners=[]:t==this._listeners.length-1?this._listeners.pop():this._listeners[t]=this._listeners.pop(),void this._Verbose(["this listener has been found, index: ",t,"new length: ",this._listeners.length].join(""));this._Verbose("listener isn't been found, new length"+this._listeners.length)},t.prototype.Start=function(){if(this._status<a.Initialized)throw new r(i.DATARV_ERROR_INVALID_STATUS);this._Verbose(["Start(), status:",this._status,"tag:",t._tag].join(" ")),this._status>=a.Started&&this._Verbose("Start() already, ignore"),++t._tag,this._status=a.Started,this._Verbose(["Start() done, status: ",this._status,"tag: ",t._tag].join(""))},t.prototype.Stop=function(){if(this._status<a.Initialized)throw new r(i.DATARV_ERROR_INVALID_STATUS);return this._Verbose("Stop(), status: "+this._status),this._status==a.Initialized?void this._Verbose("Stop() already, ignore"):(this._Reset(),this._status=a.Initialized,void this._Verbose("Stop() done, status: "+this._status))},t.prototype.Pause=function(){this._isPaused=!0,this._CleanTimer()},t.prototype.Resume=function(){this._isPaused=!1,this._eventsCache.IsEmpty()||this._timer||this._ScheduleTimer(!1)},t.prototype.Flush=function(e){this._eventsCache.IsEmpty()||this._WorkThread(e,!0)},t.prototype.SendAsync=function(e,n){if(this._status<a.Initialized)throw new r(i.DATARV_ERROR_INVALID_STATUS);if(this._Verbose(["SendAsync(), status:",this._status,"tenantToken:",e,"count:",n.length].join(" ")),this._status<a.Started)return this._Info("SendAsync(), not started, ignore, return false"),!1;if(!e||!n)throw this._Error("SendAsync(), tenantToken or events is null or empty"),new r(i.DATARV_ERROR_INVALID_ARG);for(var o=0;o<n.length;++o)if(!n[o].Id||!t._eventTypeRegex.test(n[o].EventType)||n[o].Timestamp.Equals("0"))throw this._Error(["eventId:",n[o].Id,"eventType:",n[o].EventType,"timestamp high:",n[o].Timestamp.high,"timestamp low:",n[o].Timestamp.low].join("")),new r(i.DATARV_ERROR_INVALID_EVENT);return this._eventsCache.AddEvents(e,n),this._Verbose(["SendAsync(), currentTimer: ",this._timer,"eventsCacheIsEmpty",this._eventsCache.IsEmpty()].join(" ")),this._eventsCache.IsEmpty()||this._timer||this._ScheduleTimer(!1),this._Verbose("SendAsync() done"),!0},t.prototype._WorkThread=function(e,n){var i=this;try{if(this._Verbose("_WorkThread, status: "+this._status),this._status<a.Started)return void this._Verbose("_WorkThread, status is not started, return");var r=this._eventsCache.DequeuEvents();if(null==r)return this._Verbose("_WorkThread, No events found, return"),void this._CleanTimer();var o=this._PackEvents(r.tenantToken,r.events);if(this._eventsCache.AddEvents(r.tenantToken,o.remainedEvents),null==o.buffer||0==o.buffer.length)return void(this._eventsCache.IsEmpty()?(this._Verbose("eventsCache is empty, stop schedule"),this._CleanTimer()):(this._Verbose("eventsCache is not empty, schedule for next run"),this._ScheduleTimer(!1)));if(this._testServerResponseHook){var s=this._testServerResponseHook();return void setTimeout(this._SendCallback(d,r.tenantToken,o.sendEvents,s,!1,null),100)}var u={type:"POST",url:this._config.collectorUrl,processData:!1,headers:{"content-type":"application/bond-compact-binary","client-id":"NO_AUTH","sdk-version":"ACT-Web-JS-"+clienttelemetry_build.version},complete:function(t){return i._SendCallback(d,r.tenantToken,o.sendEvents,t,n,e)}};sct.Utils.IsUint8ArrSupported()?(this._Verbose("Uint8Array is defined, send with binary format directly."),u.data=new Uint8Array(o.buffer)):(this._Verbose("Uint8Array is undefined, send with base64 encode."),u.data=Microsoft.Bond.Encoding.Base64.GetString(o.buffer),u.headers["content-encoding"]="base64"),r.tenantToken&&(u.headers["x-apikey"]=r.tenantToken);var d=t._tag;this._lastActiveTime=(new Date).getTime(),sct.Utils.ajax(u,n),this._Verbose("_Workthread, send via jquery, tag: "+d)}catch(e){this._Error("_WorkThread, exception: "+e)}},t.prototype._PackEvents=function(t,n){this._Verbose("_PackageEvents, total Count: "+n.length);var i=new e.datamodels.ClientToCollectorRequest,r=new e.datamodels.DataPackage;r.Source="JS_default_source",r.DataPackageId=e.datamodels.utils.GetGuid(),r.Timestamp=e.datamodels.utils.GetTimeStamp();var o,s=n;for(n=[];;){if(r.Records=[],r.Records.push.apply(r.Records,s),i.DataPackages=[],i.DataPackages.push(r),o=this._Serialize(i),this._Verbose(["_PackageEvents, sendEvents.length:",s.length,"buffer.length:",o.length,"MaxPackageSize:",this._MaxPackageSizeInBytes].join("")),o.length<this._MaxPackageSizeInBytes)break;if(1==s.length){s=[],o=null;break}var a=s.splice(0,Math.floor(s.length/2));this._Verbose("_PackageEvents, too large, package again"),n.push.apply(n,s),s=a}return this._Verbose(["_PakcageEvents done, sendEventsCount:",s.length,"buffer.length:",null==o?0:o.length,"remained events:",n.length].join("")),{buffer:o,sendEvents:s,remainedEvents:n}},t.prototype._Serialize=function(e){var t=new Microsoft.Bond.IO.MemoryStream,n=new Microsoft.Bond.CompactBinaryProtocolWriter(t);return e.Write(n),t.GetBuffer()},t.prototype._SendCallback=function(e,i,r,o,s,u){if(this._Verbose(["_SendCallback","tag:",e,"current tag:",t._tag,"tenantToken:",i,"events count:",r.length,"jqXHR:",o].join("")),u&&u(o?o.status:0,i,r),!s){var d=null!=o&&o.status>=200&&o.status<300;if(this._status<a.Started||e<t._tag)return void this._Verbose("_SendCallback, is not started, or tag is not the same, return");if(!d&&(!o||o.status&&400!=o.status))return this._Verbose("retry statusCode: "+(o?o.status:0)),this._eventsCache.AddEvents(i,r),void this._ScheduleTimer(!0);for(var c=0;c<this._listeners.length;++c)this._listeners[c](d?n.SENT:n.SEND_FAILED,o?o.status:0,i,r);this._eventsCache.IsEmpty()?(this._Verbose("eventsCache is empty, stop schedule"),this._CleanTimer()):(this._Verbose("eventsCache is not empty, schedule for next run"),this._ScheduleTimer(!1))}},t.prototype._CleanTimer=function(){
	this._Verbose("_CleanTimer(), timer: "+this._timer),this._timer&&(clearTimeout(this._timer),this._timer=null)},t.prototype._ScheduleTimer=function(e){var t=this;if(!this._isPaused)if(this._Verbose("_ScheduleTimer: isRetry: "+e),this._CleanTimer(),e){this._Verbose("_ScheduleTimer, current factor: "+this._rescheduleFactor);var n=Math.floor(5*this._rescheduleFactor*(1+Math.random()));this._timer=setTimeout(function(){return t._WorkThread(null,!1)},1e3*n),this._Verbose("_ScheduleTimer, next try (s): "+n),this._rescheduleFactor<<=1,this._rescheduleFactor>64&&(this._rescheduleFactor=1)}else{var n=0,i=(new Date).getTime(),r=i-this._lastActiveTime;n=r>u.TimeIntervalForNextSendInMS()?0:u.TimeIntervalForNextSendInMS()-r,this._timer=setTimeout(function(){return t._WorkThread(null,!1)},n),this._Verbose("_ScheduleTimer, next try: "+n),this._rescheduleFactor=1}},t.prototype._Verbose=function(e){this._config.log&&this._config.log.Verbose("[TelemetryManagerImpl]: "+e)},t.prototype._Info=function(e){this._config.log&&this._config.log.Info("[TelemetryManagerImpl]: "+e)},t.prototype._Error=function(e){this._config.log&&this._config.log.Error("[TelemetryManagerImpl]: "+e)},t.prototype._Reset=function(){this._Verbose("Reset()"),this._CleanTimer(),this._lastActiveTime=0,this._rescheduleFactor=1,this._sendingEvents=[],this._eventsCache=new c},t.prototype.__GetListenerArray=function(){return this._listeners},t.prototype.__GetTotalEventsCount=function(){return this._eventsCache.GetTotalEventsCount()},t.prototype.__IsScheduled=function(){return null!=this._timer},t.prototype.__ChageMaxPackageSizeInKB=function(e){this._MaxPackageSizeInBytes=1024*e},t.prototype.__SetTestServerResponseHook=function(e){this._testServerResponseHook=e},t._eventTypeRegex=/^[a-zA-Z0-9]([a-zA-Z0-9]|_){2,98}[a-zA-Z0-9]$/,t._tag=0,t}(),c=function(){function e(){this._events={},this._tokens=[]}return e.prototype.AddEvents=function(e,t){t.length&&(this._events[e]||(this._events[e]=[],this._tokens.push(e)),this._events[e].push.apply(this._events[e],t))},e.prototype.IsEmpty=function(){return 0==this._tokens.length},e.prototype.DequeuEvents=function(){if(0==this._tokens.length)return null;var e=this._tokens.shift(),t=this._events[e];return delete this._events[e],{tenantToken:e,events:t}},e.prototype.GetTotalEventsCount=function(){var e=0;for(var t in this._events)e+=this._events[t].length;return e},e}()}(t=e._sender||(e._sender={}))}(t=e.telemetry||(e.telemetry={}))}(t=e.applications||(e.applications={}))}(microsoft||(microsoft={}));var microsoft;!function(e){var t;!function(t){var n;!function(t){var n=t._sender.TelemetryManagerFactory.CreateTelemetryManager(),i=function(){function e(){this.collectorUrl=null,this.enableAutoUserSession=!1,this.browserOverrides=new r}return e}();t.LogConfiguration=i;var r=function(){function e(){this.onSaveData=null,this.onGetData=null}return e}();t.LogConfigurationBrowserOverrides=r;var o=function(){function e(){this.value=null,this.pii=null}return e._isPii=function(e){return null!==e&&void 0!==e&&e!==t.datamodels.PIIKind.NotSet&&!isNaN(e)&&void 0!==t.datamodels.PIIKind[e]},e}(),s=function(){function e(){this.name=null,this.timestamp=null,this.properties={},this.eventType=null}return e.prototype.setProperty=function(n,i,r){if(!n||!e._propertyNameRegex.test(n))throw new u(a.INVALID_PROPERTY_NAME);r?this.properties[n]={value:i,pii:r!=t.datamodels.PIIKind.NotSet?r:null}:this.properties[n]={value:i,pii:null}},e._propertyNameRegex=/^[a-zA-Z0-9](([a-zA-Z0-9|_|\.]){0,98}[a-zA-Z0-9])?$/,e}();t.EventProperties=s,function(e){e[e.INVALID_TENANT_TOKEN=1]="INVALID_TENANT_TOKEN",e[e.MISSING_EVENT_PROPERTIES_NAME=2]="MISSING_EVENT_PROPERTIES_NAME",e[e.INVALID_PROPERTY_NAME=3]="INVALID_PROPERTY_NAME",e[e.MISSING_FAILURE_SIGNATURE=5]="MISSING_FAILURE_SIGNATURE",e[e.MISSING_FAILURE_DETAIL=6]="MISSING_FAILURE_DETAIL",e[e.MISSING_PAGEVIEW_ID=7]="MISSING_PAGEVIEW_ID",e[e.MISSING_PAGEVIEW_NAME=8]="MISSING_PAGEVIEW_NAME",e[e.INVALID_SESSION_STATE=9]="INVALID_SESSION_STATE",e[e.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET=10]="INVALID_CONFIGURATION_USE_CUSTOM_GET_SET"}(t.TelemetryError||(t.TelemetryError={}));var a=t.TelemetryError,u=function(){function e(e){this.errorCode=null,this.errorCode=e}return e.prototype.ErrorCode=function(){return this.errorCode},e.prototype.toString=function(){switch(this.errorCode){case a.INVALID_TENANT_TOKEN:return"Invalid tenant token";case a.MISSING_EVENT_PROPERTIES_NAME:return"Eventproperties.name can not be null or empty";case a.INVALID_PROPERTY_NAME:return"Invalid Key. Key does not conform to regular expression ^[a-zA-Z0-9](([a-zA-Z0-9|_|.]){0,98}[a-zA-Z0-9])?$";case a.MISSING_FAILURE_SIGNATURE:return"Failure signature can't be null or empty.";case a.MISSING_FAILURE_DETAIL:return"Failure detail can't be null or empty.";case a.MISSING_PAGEVIEW_ID:return"Pageview id can't be null or empty.";case a.MISSING_PAGEVIEW_NAME:return"Pageview name can't be null or empty.";case a.INVALID_SESSION_STATE:return"Session state has to be a value from the SessionState enum.";case a.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET:return"Invalid configuration provided during initialization. Both onGetConfigData and onSaveConfigData must be provided together.  These are manditory when running in a non-brower enviornment";default:return"Unknown error"}},e}();t.Exception=u;var d=function(){function n(e){this.contextMap={},this.piiKind=t.datamodels.PIIKind.NotSet,this._allowDeviceInfoFields=!1,this._allowDeviceInfoFields=e}return n.prototype.setAppId=function(e){e&&(this.contextMap["AppInfo.Id"]=e)},n.prototype.setAppVersion=function(e){e&&(this.contextMap["AppInfo.Version"]=e)},n.prototype.setAppLanguage=function(e){e&&(this.contextMap["AppInfo.Language"]=e)},n.prototype.setDeviceId=function(e){e&&this._allowDeviceInfoFields&&(this.contextMap["DeviceInfo.Id"]=e,c.checkAndUpdateDeviceId(e))},n.prototype.setDeviceOsName=function(e){e&&this._allowDeviceInfoFields&&(this.contextMap["DeviceInfo.OsName"]=e)},n.prototype.setDeviceOsVersion=function(e){e&&this._allowDeviceInfoFields&&(this.contextMap["DeviceInfo.OsVersion"]=e)},n.prototype.setDeviceBrowserName=function(e){e&&this._allowDeviceInfoFields&&(this.contextMap["DeviceInfo.BrowserName"]=e)},n.prototype.setDeviceBrowserVersion=function(e){e&&this._allowDeviceInfoFields&&(this.contextMap["DeviceInfo.BrowserVersion"]=e)},n.prototype.setUserId=function(t,n,i){if(t&&(this.contextMap["UserInfo.Id"]=t),i)this.contextMap["UserInfo.IdType"]=i;else{var r;switch(n){case e.applications.telemetry.datamodels.PIIKind.SipAddress:r=e.applications.telemetry.datamodels.UserIdType.SipAddress;break;case e.applications.telemetry.datamodels.PIIKind.PhoneNumber:r=e.applications.telemetry.datamodels.UserIdType.PhoneNumber;break;case e.applications.telemetry.datamodels.PIIKind.SmtpAddress:r=e.applications.telemetry.datamodels.UserIdType.EmailAddress;break;default:r=e.applications.telemetry.datamodels.UserIdType.Unknown}this.contextMap["UserInfo.IdType"]=r}if(n)o._isPii(n)&&(this.piiKind=n);else{var s;switch(i){case e.applications.telemetry.datamodels.UserIdType.Skype:s=e.applications.telemetry.datamodels.PIIKind.Identity;break;case e.applications.telemetry.datamodels.UserIdType.EmailAddress:s=e.applications.telemetry.datamodels.PIIKind.SmtpAddress;break;case e.applications.telemetry.datamodels.UserIdType.PhoneNumber:s=e.applications.telemetry.datamodels.PIIKind.PhoneNumber;break;case e.applications.telemetry.datamodels.UserIdType.SipAddress:s=e.applications.telemetry.datamodels.PIIKind.SipAddress;break;default:s=e.applications.telemetry.datamodels.PIIKind.NotSet}o._isPii(s)&&(this.piiKind=s)}},n.prototype.setUserMsaId=function(e){e&&(this.contextMap["UserInfo.MsaId"]=e)},n.prototype.setUserANID=function(e){e&&(this.contextMap["UserInfo.ANID"]=e)},n.prototype.setUserAdvertisingId=function(e){e&&(this.contextMap["UserInfo.AdvertisingId"]=e)},n.prototype.setUserTimeZone=function(e){e&&(this.contextMap["UserInfo.TimeZone"]=e)},n.prototype.setUserLanguage=function(e){e&&(this.contextMap["UserInfo.Language"]=e)},n}();t.SemanticContext=d;var c=function(){function e(){}return e.initialize=function(n){this._overrides=n;var i=e._getAppLanguage();i&&e.semanticContext.setAppLanguage(i);var r=e._getUserLanguage();r&&e.semanticContext.setUserLanguage(r);var o=(new Date).getTimezoneOffset(),s=o%60,a=(o-s)/60,u="+";a>0&&(u="-"),e.semanticContext.setUserTimeZone(u+(a<10?"0"+a:a.toString())+":"+(s<10?"0"+s:s.toString()));var d=e._getUserAgent();d&&(e.semanticContext.setDeviceBrowserName(e._getBrowserName()),e.semanticContext.setDeviceBrowserVersion(e._getBrowserVersion()),e.semanticContext.setDeviceOsName(e._getOsName()),e.semanticContext.setDeviceOsVersion(e._getOsVersion()));var c=e._getData(e.DEVICE_ID_COOKIE);c&&""!=c||(c=t.datamodels.utils.GetGuid()),e.semanticContext.setDeviceId(c)},e.checkAndUpdateDeviceId=function(t){var n=e._getData(e.DEVICE_ID_COOKIE);n!=t&&(e._saveData(e.DEVICE_ID_COOKIE,t),e._saveData(e.FIRST_LAUNCH_TIME_COOKIE,(new Date).getTime().toString()));var i=e._getData(e.FIRST_LAUNCH_TIME_COOKIE);e.firstLaunchTime=parseInt(i)},e._saveData=function(e,t){if(this._overrides.onSaveData)this._overrides.onSaveData(e,t);else if("undefined"!=typeof document&&document.cookie){var n="expires=Mon, 31 Dec 2029 23:59:59 GMT";document.cookie=e+"="+t+"; "+n}},e._getData=function(e){if(this._overrides.onGetData)return this._overrides.onGetData(e)||"";if("undefined"!=typeof document&&document.cookie)for(var t=e+"=",n=document.cookie.split(";"),i=0;i<n.length;i++){for(var r=n[i],o=0;" "==r.charAt(o);)o++;if(r=r.substring(o),0==r.indexOf(t))return r.substring(t.length,r.length)}return""},e._getUserAgent=function(){return"undefined"!=typeof navigator?navigator.userAgent||"":""},e._getAppLanguage=function(){return"undefined"!=typeof document&&document.documentElement?document.documentElement.lang:null},e._getUserLanguage=function(){return"undefined"!=typeof navigator?navigator.userLanguage||navigator.language:null},e._userAgentContainsString=function(t){return e._getUserAgent().indexOf(t)>-1},e._isIe=function(){return e._userAgentContainsString("Trident")},e._isEdge=function(){return e._userAgentContainsString(e.BROWSERS.EDGE)},e._isOpera=function(){return e._userAgentContainsString("OPR/")},e._getBrowserName=function(){return e._isOpera()?e.BROWSERS.UNKNOWN:e._userAgentContainsString(e.BROWSERS.PHANTOMJS)?e.BROWSERS.PHANTOMJS:e._isIe()?e.BROWSERS.MSIE:e._isEdge()?e.BROWSERS.EDGE:e._userAgentContainsString(e.BROWSERS.ELECTRON)?e.BROWSERS.ELECTRON:e._userAgentContainsString(e.BROWSERS.CHROME)?e.BROWSERS.CHROME:e._userAgentContainsString(e.BROWSERS.FIREFOX)?e.BROWSERS.FIREFOX:e._userAgentContainsString(e.BROWSERS.SAFARI)?e.BROWSERS.SAFARI:e._userAgentContainsString(e.BROWSERS.SKYPE_SHELL)?e.BROWSERS.SKYPE_SHELL:e.BROWSERS.UNKNOWN},e._getBrowserVersion=function(){function t(){var t,n=e._getUserAgent(),i=n.match(new RegExp(e.BROWSERS.MSIE+" "+e.REGEX_VERSION));return i?i[1]:(t=n.match(new RegExp("rv:"+e.REGEX_VERSION)))?t[1]:void 0}function n(t){var n;return t===e.BROWSERS.SAFARI&&(t="Version"),n=e._getUserAgent().match(new RegExp(t+"/"+e.REGEX_VERSION)),n?n[1]:e.UNKNOWN_VERSION}return e._isIe()?t():n(e._getBrowserName())},e._getOsName=function(){var t=/(windows|win32)/i,n=/ arm;/i,i=/windows\sphone\s\d+\.\d+/i,r=/(macintosh|mac os x)/i,o=/(iPad|iPhone|iPod)(?=.*like Mac OS X)/i,s=/(linux|joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)/i,a=/android/i;return e._getUserAgent().match(i)?e.OPERATING_SYSTEMS.WINDOWS_PHONE:e._getUserAgent().match(n)?e.OPERATING_SYSTEMS.WINDOWS_RT:e._getUserAgent().match(o)?e.OPERATING_SYSTEMS.IOS:e._getUserAgent().match(a)?e.OPERATING_SYSTEMS.ANDROID:e._getUserAgent().match(s)?e.OPERATING_SYSTEMS.LINUX:e._getUserAgent().match(r)?e.OPERATING_SYSTEMS.MACOSX:e._getUserAgent().match(t)?e.OPERATING_SYSTEMS.WINDOWS:e.OPERATING_SYSTEMS.UNKNOWN},e._getOsVersion=function(){function t(){var t=e._getUserAgent().match(new RegExp("Windows NT "+e.REGEX_VERSION));return t&&e.VERSION_MAPPINGS[t[1]]?e.VERSION_MAPPINGS[t[1]]:e.UNKNOWN_VERSION}function n(){var t=e._getUserAgent().match(new RegExp(e.OPERATING_SYSTEMS.MACOSX+" "+e.REGEX_VERSION_MAC));if(t){var n=t[1].replace(/_/g,"."),r=[];if(n){var o=i(n);return o?(r=n.split(o),r[0]):n}}return e.UNKNOWN_VERSION}function i(e){return e.indexOf(".")>-1?".":e.indexOf("_")>-1?"_":null}return e._getOsName()===e.OPERATING_SYSTEMS.WINDOWS?t():e._getOsName()===e.OPERATING_SYSTEMS.MACOSX?n():e.UNKNOWN_VERSION},e.semanticContext=new d((!0)),e.firstLaunchTime=-1,e.BROWSERS={MSIE:"MSIE",CHROME:"Chrome",FIREFOX:"Firefox",SAFARI:"Safari",EDGE:"Edge",ELECTRON:"Electron",SKYPE_SHELL:"SkypeShell",PHANTOMJS:"PhantomJS",UNKNOWN:"Unknown"},e.OPERATING_SYSTEMS={WINDOWS:"Windows",MACOSX:"Mac OS X",WINDOWS_PHONE:"Windows Phone",WINDOWS_RT:"Windows RT",IOS:"iOS",ANDROID:"Android",LINUX:"Linux",UNKNOWN:"Unknown"},e.VERSION_MAPPINGS={5.1:"XP","6.0":"Vista",6.1:"7",6.2:"8",6.3:"8.1","10.0":"10"},e.REGEX_VERSION="([\\d,.]+)",e.REGEX_VERSION_MAC="([\\d,_,.]+)",e.UNKNOWN_VERSION="Unknown",e.DEVICE_ID_COOKIE="MicrosoftApplicationsTelemetryDeviceId",e.FIRST_LAUNCH_TIME_COOKIE="MicrosoftApplicationsTelemetryFirstLaunchTime",e}();!function(e){e[e.STARTED=0]="STARTED",e[e.ENDED=1]="ENDED"}(t.SessionState||(t.SessionState={}));var l=t.SessionState,_=function(){function e(){}return e.initialize=function(t,i){if(!e._initialized){if(!t)throw new u(a.INVALID_TENANT_TOKEN);if(e._defaultToken=t,e._tmConfig.collectorUrl="https://browser.pipe.aria.microsoft.com/Collector/3.0/",e._configuration=i,!("undefined"!=typeof window||i&&i.browserOverrides&&i.browserOverrides.onGetData))throw new u(a.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET);var o=new r;if(i&&(i.collectorUrl&&(e._tmConfig.collectorUrl=i.collectorUrl),i.browserOverrides)){if(i.browserOverrides.onGetData?!i.browserOverrides.onSaveData:!!i.browserOverrides.onSaveData)throw new u(a.INVALID_CONFIGURATION_USE_CUSTOM_GET_SET);o.onGetData=i.browserOverrides.onGetData,o.onSaveData=i.browserOverrides.onSaveData}n.Initialize(e._tmConfig),n.Start(),c.initialize(o),e._initialized=!0,"undefined"!=typeof window&&window.addEventListener&&(i&&i.enableAutoUserSession&&(e._logger=new f,e._logger.logSession(l.STARTED)),window.addEventListener("beforeunload",e._teardown))}},e.pauseTransmission=function(){n.Pause()},e.resumeTransmission=function(){n.Resume()},e.flush=function(e){n.Flush(e)},e.addCallbackListener=function(t){e._initialized&&n.AddListener(t)},e.setContext=function(t,n,i){e._contextProperties.setProperty(t,n,i)},e.isInitialized=function(){return e._initialized},e.getDefaultToken=function(){return e._defaultToken},e.getSemanticContext=function(){return e._semanticContext},e._getInitIdForToken=function(n){return e._initIdMap[n]||(e._initIdMap[n]=t.datamodels.utils.GetGuid()),e._initIdMap[n]},e._getSequenceForToken=function(t){return e._sequenceMap[t]||(e._sequenceMap[t]=0),e._sequenceMap[t]++,e._sequenceMap[t]},e._teardown=function(){e._logger&&e._logger.logSession(l.ENDED),e.flush()},e.__backToUninitialized=function(){e._tmConfig=new t._sender.TelemetryConfig,e._semanticContext=new d((!0)),e._contextProperties=new s,e._configuration=null,n=t._sender.TelemetryManagerFactory.CreateTelemetryManager(),e._initialized=!1,e._initIdMap={},e._sequenceMap={}},e._initialized=!1,e._defaultToken=null,e._tmConfig=new t._sender.TelemetryConfig,e._logger=null,e._initIdMap={},e._sequenceMap={},e._configuration=null,e._contextProperties=new s,e._semanticContext=new d((!0)),e}();t.LogManager=_;var f=function(){function e(e){this._initId=null,this._tenantToken=null,this._contextProperties=new s,this._semanticContext=new d((!1)),this._sessionStartTime=0,this._sessionId=null,e?this._tenantToken=e:this._tenantToken=_.getDefaultToken(),this._initId=_._getInitIdForToken(this._tenantToken)}return e.prototype.logEvent=function(e){if(!e.name)throw new u(a.MISSING_EVENT_PROPERTIES_NAME);var t=this._createEventRecord(e.name,e.eventType);this._addPropertiesAndSendEvent(t,e)},e.prototype.logFailure=function(e,t,n,i,r){if(!e)throw new u(a.MISSING_FAILURE_SIGNATURE);if(!t)throw new u(a.MISSING_FAILURE_DETAIL);var o=this._createEventRecord("failure","failure");o.Extension.Add("Failure.Signature",e),o.Extension.Add("Failure.Detail",t),n&&o.Extension.Add("Failure.Category",n),i&&o.Extension.Add("Failure.Id",i),this._addPropertiesAndSendEvent(o,r)},e.prototype.logPageView=function(e,t,n,i,r,o){if(!e)throw new u(a.MISSING_PAGEVIEW_ID);if(!t)throw new u(a.MISSING_PAGEVIEW_NAME);var s=this._createEventRecord("pageview","pageview");s.Extension.Add("PageView.Id",e),s.Extension.Add("PageView.Name",t),n&&s.Extension.Add("PageView.Category",n),i&&s.Extension.Add("PageView.Uri",i),r&&s.Extension.Add("PageView.ReferrerUri",r),this._addPropertiesAndSendEvent(s,o)},e.prototype.logSession=function(e,n){if(e!==l.STARTED&&e!==l.ENDED)throw new u(a.INVALID_SESSION_STATE);var i=this._createEventRecord("session","session");if(e===l.STARTED){if(this._sessionStartTime>0)return;this._sessionStartTime=(new Date).getTime(),this._sessionId=t.datamodels.utils.GetGuid(),i.Extension.Add("Session.Id",this._sessionId),i.Extension.Add("Session.State","Started")}else if(e===l.ENDED){if(0==this._sessionStartTime)return;var r=Math.floor(((new Date).getTime()-this._sessionStartTime)/1e3);i.Extension.Add("Session.Duration",r.toString()),i.Extension.Add("Session.DurationBucket",this._getSessionDurationFromTime(r)),i.Extension.Add("Session.Id",this._sessionId),i.Extension.Add("Session.State","Ended"),this._sessionId=null,this._sessionStartTime=0}i.Extension.Add("Session.FirstLaunchTime",this._getISOString(new Date(c.firstLaunchTime))),this._addPropertiesAndSendEvent(i,n)},e.prototype.getSessionId=function(){return this._sessionId},e.prototype.setContext=function(e,t,n){this._contextProperties.setProperty(e,t,n)},e.prototype.getSemanticContext=function(){return this._semanticContext},e.prototype._getSessionDurationFromTime=function(e){return e<0?"Undefined":e<=3?"UpTo3Sec":e<=10?"UpTo10Sec":e<=30?"UpTo30Sec":e<=60?"UpTo60Sec":e<=180?"UpTo3Min":e<=600?"UpTo10Min":e<=1800?"UpTo30Min":"Above30Min"},e.prototype._createEventRecord=function(e,n){var i=new t.datamodels.Record;n||(n="custom"),i.EventType=e.toLowerCase(),i.Type=n.toLowerCase(),i.Extension.Add("EventInfo.Source","JS_default_source"),i.Extension.Add("EventInfo.InitId",this._initId),i.Extension.Add("EventInfo.Sequence",_._getSequenceForToken(this._tenantToken).toString()),i.Extension.Add("EventInfo.Name",e.toLowerCase());var r=new Date;return i.Timestamp=t.datamodels.utils.GetTimeStampWithValue(r.getTime()),i.Extension.Add("EventInfo.Time",this._getISOString(r)),i.Extension.Add("EventInfo.SdkVersion","ACT-Web-JS-"+clienttelemetry_build.version),i},e.prototype._getISOString=function(e){function t(e){return e<10?"0"+e:e.toString()}function n(e){return e<10?"00"+e:e<100?"0"+e:e.toString()}return e.getUTCFullYear()+"-"+t(e.getUTCMonth()+1)+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+n(e.getUTCMilliseconds())+"Z"},e.prototype._addCustomPropertiesToEvent=function(e,t){this._addSemanticContext(e,c.semanticContext),this._addSemanticContext(e,_._semanticContext),this._addSemanticContext(e,this._semanticContext),this._sessionId&&e.Extension.Add("Session.Id",this._sessionId),this._addEventPropertiesToEvent(e,_._contextProperties),this._addEventPropertiesToEvent(e,this._contextProperties),this._addEventPropertiesToEvent(e,t)},e.prototype._addSemanticContext=function(e,n){if(n&&n.contextMap){var i=n.contextMap;for(var r in n.contextMap)"UserInfo.Id"==r&&n.piiKind!=t.datamodels.PIIKind.NotSet?e.AddOrReplacePII(r,i[r],n.piiKind):e.Extension.AddOrReplace(r,i[r])}},e.prototype._addEventPropertiesToEvent=function(e,n){if(n){n.timestamp&&n.timestamp>=new Date("1/1/2000").getTime()&&(e.Timestamp=t.datamodels.utils.GetTimeStampWithValue(n.timestamp),e.Extension.AddOrReplace("EventInfo.Time",this._getISOString(new Date(n.timestamp)))),n.name&&(e.EventType=n.name.toLowerCase(),e.Extension.AddOrReplace("EventInfo.Name",n.name.toLowerCase()));var i=n.properties;if(i)for(var r in i)r&&(i[r].value||i[r].value===!1||0==i[r].value||""==i[r].value)&&(o._isPii(i[r].pii)?(e.AddOrReplacePII(r,i[r].value.toString(),i[r].pii),e.Extension.Remove(r)):(e.Extension.AddOrReplace(r,i[r].value.toString()),e.PIIExtensions.Remove(r)))}},e.prototype._addPropertiesAndSendEvent=function(e,t){this._addCustomPropertiesToEvent(e,t),_.isInitialized()&&(this._sanitizeName(e),n.SendAsync(this._tenantToken,[e]))},e.prototype._sanitizeName=function(e){var t=e.EventType.replace(/\./g,"_");e.EventType=t,e.Extension.AddOrReplace("EventInfo.Name",t)},e}();t.Logger=f}(n=t.telemetry||(t.telemetry={}))}(t=e.applications||(e.applications={}))}(microsoft||(microsoft={})),"undefined"!=typeof module&&(module.exports=microsoft.applications.telemetry);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var buttonConfigFactory_1 = __webpack_require__(10);
	var chatDefinition_1 = __webpack_require__(20);
	var preloadType_1 = __webpack_require__(21);
	var buttonRenderEvent_1 = __webpack_require__(22);
	var buttonClickEvent_1 = __webpack_require__(31);
	var ariaTelemetryService_1 = __webpack_require__(32);
	var ButtonBootstrapper = (function () {
	    function ButtonBootstrapper() {
	        this._buttons = [];
	        this._initialized = false;
	        this.init();
	    }
	    ButtonBootstrapper.prototype.init = function () {
	        var _this = this;
	        this._skypeButtonPlaceholders = document.querySelectorAll('.skype-button');
	        if (!this._skypeButtonPlaceholders.length) {
	            return;
	        }
	        var _loop_1 = function(i) {
	            var skypeButtonPlaceholder = this_1._skypeButtonPlaceholders[i];
	            this_1.createSkypeButton(skypeButtonPlaceholder, function (definition, chat) {
	                definition._isHidden = false;
	                if (skypeButtonPlaceholder.classList.contains('bubble')) {
	                    skypeButtonPlaceholder.firstElementChild.classList.remove('close-bubble');
	                    skypeButtonPlaceholder.firstElementChild.classList.add('open-bubble');
	                }
	                switch (definition.Preload) {
	                    case preloadType_1.PreloadType.UIONLY:
	                        chat.showChat();
	                        break;
	                    case preloadType_1.PreloadType.NONE:
	                    case preloadType_1.PreloadType.FULL:
	                    default:
	                        chat.startChat(definition);
	                        break;
	                }
	                var btnClickEvt = new buttonClickEvent_1.default();
	                btnClickEvt.chatId = definition.ConversationType === 'agent' ? definition.ConversationId : null;
	                _this.telemetryService.sendEvent(btnClickEvt);
	            });
	        };
	        var this_1 = this;
	        for (var i = 0; i < this._skypeButtonPlaceholders.length; i++) {
	            _loop_1(i);
	        }
	        this._showSkypeButtons();
	    };
	    ButtonBootstrapper.prototype.dispose = function () {
	        this._buttons.forEach(function (button) {
	            button.element.removeEventListener('click', button.callback);
	        });
	    };
	    Object.defineProperty(ButtonBootstrapper.prototype, "telemetryService", {
	        get: function () {
	            if (!this._telemetryService) {
	                this._telemetryService = new ariaTelemetryService_1.AriaTelemetryService();
	            }
	            return this._telemetryService;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ButtonBootstrapper.prototype._showSkypeButtons = function () {
	        for (var i = 0; i < this._skypeButtonPlaceholders.length; i++) {
	            var skypeButtonPlaceholder = this._skypeButtonPlaceholders[i];
	            skypeButtonPlaceholder.style.visibility = null;
	        }
	    };
	    ButtonBootstrapper.prototype.createSkypeButton = function (skypeButtonPlaceholder, onClicked) {
	        var configFactory = new buttonConfigFactory_1.ButtonConfigFactory();
	        var definition = configFactory.getDefinitionFromDOM(skypeButtonPlaceholder);
	        var buttonConversationId = definition.ConversationId;
	        var buttonConversationTitle = definition.Title;
	        var chat = window.SkypeWebControl.SDK.Chat;
	        var chatAttrs = chat.getChatAttrs();
	        if (!chatAttrs) {
	            chatAttrs = new chatDefinition_1.ChatDefinition();
	        }
	        // definition.MergeWith(chatAttrs)
	        chatAttrs.MergeWith(definition);
	        if (definition && chatAttrs) {
	            definition.MergeWith(chatAttrs);
	        }
	        if (chatAttrs.Preload === preloadType_1.PreloadType.UIONLY) {
	            chat.startChat(chatAttrs);
	        }
	        if (chatAttrs.Preload === preloadType_1.PreloadType.FULL) {
	            chatAttrs._isHidden = true;
	            chat.startChat(chatAttrs);
	        }
	        chatAttrs.ConversationId = buttonConversationId;
	        chatAttrs.Title = buttonConversationTitle;
	        var callback = function () { return onClicked(chatAttrs, chat); };
	        if (skypeButtonPlaceholder.children.length > 0 || skypeButtonPlaceholder.innerText.length > 0) {
	            skypeButtonPlaceholder.addEventListener('click', callback);
	            this._buttons.push({ element: skypeButtonPlaceholder, callback: callback });
	        }
	        else {
	            var buttonElement = document.createElement('a');
	            var buttonText = definition.Text || 'Contact us';
	            buttonElement.className = 'lwc-chat-button';
	            buttonElement.innerHTML = this.getTemplate(buttonText);
	            buttonElement.addEventListener('click', callback);
	            if (definition.Color) {
	                buttonElement.style.backgroundColor = definition.Color;
	            }
	            skypeButtonPlaceholder.appendChild(buttonElement);
	            this._buttons.push({ element: buttonElement, callback: callback });
	        }
	        !this._initialized && this._showSkypeButtons();
	        this._initialized = true;
	        var btnRenderEvt = new buttonRenderEvent_1.default();
	        btnRenderEvt.chatId = definition.ConversationType === 'agent' ? definition.ConversationId : null;
	        this.telemetryService.sendEvent(btnRenderEvt);
	    };
	    ButtonBootstrapper.prototype.getTemplate = function (label) {
	        return "\n            <span class=\"lwc-button-icon\">\n                <svg viewBox=\"0 0 38 35\" style=\"width: inherit\">\n                <path fill=\"#FFF\" fill-rule=\"evenodd\" d=\"M36.9 10.05c-1-4.27-4.45-7.6-8.8-8.4-2.95-.5-6-.78-9.1-.78-3.1 0-6.15.27-9.1.8-4.35.8-7.8 4.1-8.8 8.38-.4 1.5-.6 3.07-.6 4.7 0 1.62.2 3.2.6 4.7 1 4.26 4.45 7.58 8.8 8.37 2.95.53 6 .45 9.1.45v5.2c0 .77.62 1.4 1.4 1.4.3 0 .6-.12.82-.3l11.06-8.46c2.3-1.53 3.97-3.9 4.62-6.66.4-1.5.6-3.07.6-4.7 0-1.62-.2-3.2-.6-4.7zm-14.2 9.1H10.68c-.77 0-1.4-.63-1.4-1.4 0-.77.63-1.4 1.4-1.4H22.7c.76 0 1.4.63 1.4 1.4 0 .77-.63 1.4-1.4 1.4zm4.62-6.03H10.68c-.77 0-1.4-.62-1.4-1.38 0-.77.63-1.4 1.4-1.4h16.64c.77 0 1.4.63 1.4 1.4 0 .76-.63 1.38-1.4 1.38z\"/></svg>\n            </span>\n            <span id=\"chatIconText\" class=\"lwc-button-text\">" + label + "</span>\n        ";
	    };
	    return ButtonBootstrapper;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ButtonBootstrapper;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var configFactory_1 = __webpack_require__(11);
	var buttonDefinition_1 = __webpack_require__(17);
	var buttonAttributes_1 = __webpack_require__(19);
	var ButtonConfigFactory = (function (_super) {
	    __extends(ButtonConfigFactory, _super);
	    function ButtonConfigFactory() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Returns button definition built from the default values
	     * and updated with values sent through the url of the hosting page.
	     * Primarily used to pass the config context to a hosting iframe.
	     *
	     * @returns {ButtonDefinition}
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ButtonConfigFactory.prototype.getDefinitionFromUrl = function () {
	        var params = this.getQueryStringParameters();
	        var definition = new buttonDefinition_1.ButtonDefinition();
	        if (!params) {
	            return definition;
	        }
	        this.parseBaseUrlParams(definition, params);
	        definition.Text = params[buttonAttributes_1.default.TEXT] || 'Contact us';
	        if (params[buttonAttributes_1.default.COLOR]) {
	            definition.Color = params[buttonAttributes_1.default.COLOR];
	        }
	        return definition;
	    };
	    /**
	     * Sets the attributes of the button element to represent the
	     * state of given button definition.
	     *
	     * @param {ButtonDefinition} definition
	     * @param {Element} [element]
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ButtonConfigFactory.prototype.setDOMFrom = function (definition, element) {
	        this.setBaseDOM(definition, element);
	        if (definition.Text) {
	            element.setAttribute(buttonAttributes_1.default.TEXT, definition.Text);
	        }
	        if (definition.Color) {
	            element.setAttribute(buttonAttributes_1.default.COLOR, definition.Color);
	        }
	    };
	    /**
	     * Process the given element data- attributes searching for
	     * the values customizing the behavior of the Skype Button.
	     *
	     * @param {HTMLElement} element
	     * @returns {ButtonDefinition}
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ButtonConfigFactory.prototype.getDefinitionFromDOM = function (element) {
	        var definition = new buttonDefinition_1.ButtonDefinition();
	        this.parseBaseDom(definition, element);
	        definition.Text = element.getAttribute(buttonAttributes_1.default.TEXT);
	        definition.Color = element.getAttribute(buttonAttributes_1.default.COLOR);
	        return definition;
	    };
	    /**
	     * Packs the button customization data into a set of url params
	     *
	     * @param {ButtonDefinition} definition
	     * @returns {string}
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ButtonConfigFactory.prototype.toUrlParams = function (definition) {
	        var query = this.getBaseParams(definition);
	        var separator = query ? '&' : '';
	        if (definition.Text) {
	            query += separator + buttonAttributes_1.default.TEXT + '=' + definition.Text;
	            separator = '&';
	        }
	        if (definition.Color) {
	            query += separator + buttonAttributes_1.default.COLOR + '=' + definition.Color;
	            separator = '&';
	        }
	        return query;
	    };
	    return ButtonConfigFactory;
	}(configFactory_1.ConfigFactory));
	exports.ButtonConfigFactory = ButtonConfigFactory;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var attributes_1 = __webpack_require__(12);
	var identityParser_1 = __webpack_require__(13);
	var conversationType_1 = __webpack_require__(14);
	var errorHandler_1 = __webpack_require__(15);
	var stringUtils_1 = __webpack_require__(16);
	/**
	 * Base configuration factory processing html and urls to populate configuration.
	 *
	 * @export
	 * @class ConfigFactory
	 */
	var ConfigFactory = (function () {
	    function ConfigFactory() {
	    }
	    /**
	     * Process attributes of the given html element and
	     * initialize the provided definition with defined data- attributes.
	     *
	     * @protected
	     * @param {Definition} definition
	     * @param {HTMLElement} element
	     *
	     * @memberOf ConfigFactory
	     */
	    ConfigFactory.prototype.parseBaseDom = function (definition, element) {
	        definition.Locale = element.getAttribute(attributes_1.Attributes.LOCALE);
	        definition.Theme = element.getAttribute(attributes_1.Attributes.THEME);
	        definition.Payload = element.getAttribute(attributes_1.Attributes.PAYLOAD);
	        definition.BingDLApi = stringUtils_1.default.toBoolean(element.getAttribute(attributes_1.Attributes.BING_DL_API));
	        definition.Title = element.getAttribute(attributes_1.Attributes.TITLE);
	        definition.Avatar = element.getAttribute(attributes_1.Attributes.AVATAR);
	        definition.TermsOfUseUri = element.getAttribute(attributes_1.Attributes.TermsOfUseUri);
	        definition.PrivacyUri = element.getAttribute(attributes_1.Attributes.PrivacyUri);
	        var conversationId = element.getAttribute(attributes_1.Attributes.BOT_ID);
	        if (conversationId) {
	            definition.ConversationId = identityParser_1.default.getBotId(conversationId);
	            definition.ConversationType = conversationType_1.default.AGENT;
	        }
	        conversationId = element.getAttribute(attributes_1.Attributes.CONTACT_EMAIL);
	        if (conversationId) {
	            definition.ConversationId = conversationId;
	            definition.ConversationType = conversationType_1.default.PERSON;
	        }
	        conversationId = element.getAttribute(attributes_1.Attributes.CONTACT_ID);
	        if (conversationId) {
	            definition.ConversationId = identityParser_1.default.getPersonId(conversationId);
	            definition.ConversationType = conversationType_1.default.PERSON;
	        }
	        conversationId = element.getAttribute(attributes_1.Attributes.THREAD_ID);
	        if (conversationId) {
	            definition.ConversationId = identityParser_1.default.getThreadId(conversationId);
	            definition.ConversationType = conversationType_1.default.GROUP;
	        }
	        conversationId = element.getAttribute(attributes_1.Attributes.JOIN_LINK);
	        if (conversationId) {
	            definition.ConversationId = conversationId;
	            definition.ConversationType = conversationType_1.default.JOIN;
	        }
	        conversationId = element.getAttribute(attributes_1.Attributes.TOKEN);
	        if (conversationId) {
	            definition.ConversationId = conversationId;
	            definition.ConversationType = conversationType_1.default.DIRECT_LINE;
	        }
	    };
	    /**
	     * Sets the DOM element attributes based on the definition.
	     *
	     * @protected
	     * @param {Definition} definition
	     * @param {Element} element
	     *
	     * @memberOf ConfigFactory
	     */
	    ConfigFactory.prototype.setBaseDOM = function (definition, element) {
	        if (definition.ConversationId) {
	            element.removeAttribute(attributes_1.Attributes.CONTACT_ID);
	            element.removeAttribute(attributes_1.Attributes.BOT_ID);
	            element.removeAttribute(attributes_1.Attributes.JOIN_LINK);
	            if (definition.ConversationType === conversationType_1.default.AGENT) {
	                element.setAttribute(attributes_1.Attributes.BOT_ID, identityParser_1.default.getBotId(definition.ConversationId));
	            }
	            else if (definition.ConversationType === conversationType_1.default.PERSON) {
	                element.setAttribute(attributes_1.Attributes.CONTACT_ID, identityParser_1.default.getPersonId(definition.ConversationId));
	            }
	            else if (definition.ConversationType === conversationType_1.default.JOIN) {
	                element.setAttribute(attributes_1.Attributes.JOIN_LINK, definition.ConversationId);
	            }
	            else if (definition.ConversationType === conversationType_1.default.DIRECT_LINE) {
	                element.setAttribute(attributes_1.Attributes.TOKEN, definition.ConversationId);
	            }
	            else {
	                errorHandler_1.default.throwError(10002, 'Unsupported conversation id:' + definition.ConversationId);
	            }
	        }
	        if (definition.Locale) {
	            element.setAttribute(attributes_1.Attributes.LOCALE, definition.Locale);
	        }
	        if (definition.Theme) {
	            element.setAttribute(attributes_1.Attributes.THEME, definition.Theme);
	        }
	        if (definition.Payload) {
	            element.setAttribute(attributes_1.Attributes.PAYLOAD, definition.Payload);
	        }
	        if (definition.Avatar) {
	            element.setAttribute(attributes_1.Attributes.AVATAR, definition.Avatar);
	        }
	        if (definition.Title) {
	            element.setAttribute(attributes_1.Attributes.TITLE, definition.Title);
	        }
	        if (definition.BingDLApi) {
	            element.setAttribute(attributes_1.Attributes.BING_DL_API, definition.BingDLApi.toString());
	        }
	        if (definition.PrivacyUri) {
	            element.setAttribute(attributes_1.Attributes.PrivacyUri, definition.PrivacyUri);
	        }
	        if (definition.TermsOfUseUri) {
	            element.setAttribute(attributes_1.Attributes.TermsOfUseUri, definition.TermsOfUseUri);
	        }
	    };
	    /**
	     * Process the hosting page url searching for data- keys and sets the
	     * given config values with the provided data- attribute values.
	     *
	     * @protected
	     * @param {Definition} definition
	     * @param {KeyValuePair} params
	     *
	     * @memberOf ConfigFactory
	     */
	    ConfigFactory.prototype.parseBaseUrlParams = function (definition, params) {
	        if (params[attributes_1.Attributes.BOT_ID]) {
	            definition.ConversationId = identityParser_1.default.getBotId(params[attributes_1.Attributes.BOT_ID]);
	            definition.ConversationType = conversationType_1.default.AGENT;
	        }
	        else if (params[attributes_1.Attributes.CONTACT_ID]) {
	            definition.ConversationId = identityParser_1.default.getPersonId(params[attributes_1.Attributes.CONTACT_ID]);
	            definition.ConversationType = conversationType_1.default.PERSON;
	        }
	        else if (params[attributes_1.Attributes.THREAD_ID]) {
	            definition.ConversationId = identityParser_1.default.getThreadId(params[attributes_1.Attributes.THREAD_ID]);
	            definition.ConversationType = conversationType_1.default.GROUP;
	        }
	        else if (params[attributes_1.Attributes.JOIN_LINK]) {
	            definition.ConversationId = params[attributes_1.Attributes.JOIN_LINK];
	            definition.ConversationType = conversationType_1.default.JOIN;
	        }
	        else if (params[attributes_1.Attributes.TOKEN]) {
	            definition.ConversationId = params[attributes_1.Attributes.TOKEN];
	            definition.ConversationType = conversationType_1.default.DIRECT_LINE;
	        }
	        if (params[attributes_1.Attributes.THEME]) {
	            definition.Theme = params[attributes_1.Attributes.THEME];
	        }
	        if (params[attributes_1.Attributes.LOCALE]) {
	            definition.Locale = params[attributes_1.Attributes.LOCALE];
	        }
	        if (params[attributes_1.Attributes.PAYLOAD]) {
	            definition.Payload = params[attributes_1.Attributes.PAYLOAD];
	        }
	        if (params[attributes_1.Attributes.BING_DL_API]) {
	            definition.BingDLApi = stringUtils_1.default.toBoolean(params[attributes_1.Attributes.BING_DL_API]);
	        }
	        if (params[attributes_1.Attributes.PrivacyUri]) {
	            definition.PrivacyUri = params[attributes_1.Attributes.PrivacyUri];
	        }
	        if (params[attributes_1.Attributes.TermsOfUseUri]) {
	            definition.TermsOfUseUri = params[attributes_1.Attributes.TermsOfUseUri];
	        }
	    };
	    /**
	     * Collects the query parameters into key/value string pairs.
	     *
	     * @protected
	     * @returns {KeyValuePair}
	     *
	     * @memberOf ConfigFactory
	     */
	    ConfigFactory.prototype.getQueryStringParameters = function () {
	        var found = false;
	        var variables = window.location.search.substring(1).split('&');
	        var result = {};
	        variables.forEach(function (variable) {
	            if (variable) {
	                found = true;
	                var tuple = variable.split('=');
	                result[decodeURIComponent(tuple[0])] = decodeURIComponent(tuple[1]) || '';
	            }
	        });
	        if (found) {
	            return result;
	        }
	        else {
	            return null;
	        }
	    };
	    ConfigFactory.prototype.getBaseParams = function (definition) {
	        var query = '';
	        var separator = '';
	        if (definition.ConversationId) {
	            if (identityParser_1.default.isBotConversation(definition.ConversationId)) {
	                query += attributes_1.Attributes.BOT_ID + '=' + definition.ConversationId;
	            }
	            else if (identityParser_1.default.isPersonConversation(definition.ConversationId)) {
	                query += attributes_1.Attributes.CONTACT_ID + '=' + definition.ConversationId;
	            }
	            else if (identityParser_1.default.isThread(definition.ConversationId)) {
	                query += attributes_1.Attributes.THREAD_ID + '=' + definition.ConversationId;
	            }
	            else if (identityParser_1.default.isJoinUrl(definition.ConversationId)) {
	                query += attributes_1.Attributes.JOIN_LINK + '=' + definition.ConversationId;
	            }
	            else if (identityParser_1.default.isToken(definition.ConversationId)) {
	                query += attributes_1.Attributes.TOKEN + '=' + definition.ConversationId;
	            }
	            else {
	                errorHandler_1.default.throwError(10003, 'Not supported type of conversation id ' + definition.ConversationId);
	            }
	            separator = '&';
	        }
	        if (definition.Locale) {
	            query += separator + attributes_1.Attributes.LOCALE + '=' + definition.Locale;
	            separator = '&';
	        }
	        if (definition.Theme) {
	            query += separator + attributes_1.Attributes.THEME + '=' + definition.Theme;
	            separator = '&';
	        }
	        if (definition.Payload) {
	            query += separator + attributes_1.Attributes.PAYLOAD + '=' + definition.Payload;
	            separator = '&';
	        }
	        if (definition.BingDLApi) {
	            query += separator + attributes_1.Attributes.BING_DL_API + '=' + definition.BingDLApi;
	            separator = '&';
	        }
	        if (definition.PrivacyUri) {
	            query += separator + attributes_1.Attributes.PrivacyUri + '=' + definition.PrivacyUri;
	            separator = '&';
	        }
	        if (definition.TermsOfUseUri) {
	            query += separator + attributes_1.Attributes.TermsOfUseUri + '=' + definition.TermsOfUseUri;
	            separator = '&';
	        }
	        return query;
	    };
	    return ConfigFactory;
	}());
	exports.ConfigFactory = ConfigFactory;


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	var Attributes = (function () {
	    function Attributes() {
	    }
	    Attributes.THEME = 'data-theme';
	    Attributes.LOCALE = 'data-locale';
	    Attributes.BOT_ID = 'data-bot-id';
	    Attributes.CONTACT_ID = 'data-contact-id';
	    Attributes.CONTACT_EMAIL = 'data-contact-email';
	    Attributes.JOIN_LINK = 'data-join-link';
	    Attributes.THREAD_ID = 'data-thread-id';
	    Attributes.TOKEN = 'data-token';
	    Attributes.PAYLOAD = 'data-payload';
	    Attributes.BING_DL_API = 'data-bing-dl-api';
	    Attributes.TITLE = 'data-title';
	    Attributes.AVATAR = 'data-avatar';
	    Attributes.PrivacyUri = 'data-privacy-uri';
	    Attributes.TermsOfUseUri = 'data-tou-uri';
	    return Attributes;
	}());
	exports.Attributes = Attributes;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var conversationType_1 = __webpack_require__(14);
	var IdentityParser = (function () {
	    function IdentityParser() {
	    }
	    IdentityParser.strip = function (identity) {
	        var match = identity.match(this.idRegExp);
	        if (match) {
	            return match[2];
	        }
	        return identity;
	    };
	    IdentityParser.isPersonConversation = function (conversationId) {
	        var conversationTypeId = conversationId.split(':')[0];
	        return conversationTypeId === this.SKYPE_USER_PREFIX;
	    };
	    IdentityParser.isEmail = function (conversationId) {
	        var emailReg = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
	        return emailReg.test(conversationId);
	    };
	    IdentityParser.isThread = function (conversationId) {
	        var conversationTypeId = conversationId.split(':')[0];
	        return conversationTypeId === this.THREAD_PREFIX;
	    };
	    IdentityParser.isJoinUrl = function (conversationId) {
	        return conversationId.indexOf(this.URL_PREFIX) === 0;
	    };
	    IdentityParser.isToken = function (conversationId) {
	        return conversationId.indexOf(this.DL_PREFIX) === 0;
	    };
	    IdentityParser.isBotConversation = function (conversationId) {
	        var conversationTypeId = conversationId.split(':')[0];
	        return conversationTypeId === this.BOT_PREFIX;
	    };
	    IdentityParser.getBotId = function (identity) {
	        return this.getNormalizeId(identity);
	    };
	    IdentityParser.getPersonId = function (identity) {
	        return this.getNormalizeId(identity);
	    };
	    IdentityParser.getThreadId = function (identity) {
	        return this.getNormalizeId(identity);
	    };
	    IdentityParser.getToken = function (identity) {
	        return this.getNormalizeId(identity);
	    };
	    IdentityParser.getCompleteBotId = function (identity) {
	        return this.getCompleteId(identity, this.BOT_PREFIX);
	    };
	    IdentityParser.getCompletePersonId = function (identity) {
	        return this.getCompleteId(identity, this.SKYPE_USER_PREFIX);
	    };
	    IdentityParser.getCompleteThreadId = function (identity) {
	        return this.getCompleteId(identity, this.THREAD_PREFIX);
	    };
	    IdentityParser.addPrefix = function (prefix, identity) {
	        if (identity.indexOf(prefix + this.SPLITTER) === 0) {
	            return identity;
	        }
	        if (identity.indexOf(this.SPLITTER) === 0) {
	            return prefix + identity;
	        }
	        return prefix + this.SPLITTER + identity;
	    };
	    IdentityParser.getConversationType = function (conversationId) {
	        if (this.isPersonConversation(conversationId)) {
	            return conversationType_1.default.PERSON;
	        }
	        if (this.isBotConversation(conversationId)) {
	            return conversationType_1.default.AGENT;
	        }
	        if (this.isJoinUrl(conversationId)) {
	            return conversationType_1.default.JOIN;
	        }
	        if (this.isToken(conversationId)) {
	            return conversationType_1.default.AGENT;
	        }
	        return conversationType_1.default.UNDEFINED;
	    };
	    IdentityParser.getNormalizeId = function (id) {
	        if (id.match(this.idRegExp)) {
	            return id.replace(/\d{1,2}:/, '');
	        }
	        return id;
	    };
	    IdentityParser.getCompleteId = function (id, prefix) {
	        if (id.match(this.idRegExp)) {
	            return id;
	        }
	        return prefix + ':' + id;
	    };
	    IdentityParser.SPLITTER = ':';
	    IdentityParser.SKYPE_USER_PREFIX = '8';
	    IdentityParser.THREAD_PREFIX = '18';
	    IdentityParser.BOT_PREFIX = '28';
	    IdentityParser.URL_PREFIX = 'HTTP';
	    IdentityParser.DL_PREFIX = '99';
	    IdentityParser.idRegExp = /(\d{1,2}:)([\S]*)/;
	    return IdentityParser;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = IdentityParser;


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	var ConversationType = (function () {
	    function ConversationType() {
	    }
	    ConversationType.UNDEFINED = '';
	    ConversationType.PERSON = 'person';
	    ConversationType.AGENT = 'agent';
	    ConversationType.JOIN = 'join';
	    ConversationType.GROUP = 'group';
	    ConversationType.DIRECT_LINE = 'dl';
	    return ConversationType;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ConversationType;


/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	    }
	    ErrorHandler.throwError = function (code, message) {
	        console.log('[' + code + ']::' + message);
	        throw new Error(code + '');
	    };
	    return ErrorHandler;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ErrorHandler;


/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	var StringUtils = (function () {
	    function StringUtils() {
	    }
	    /**
	      * Converts string value to boolean value.
	      *
	      * @static
	      * @param {string} value
	      * @returns {boolean}
	      *
	      * @memberOf StringUtils
	      */
	    StringUtils.toBoolean = function (value) {
	        if (!value) {
	            return null;
	        }
	        return value.toLowerCase() === 'true';
	    };
	    /**
	    * Adds px at the end of the size if it is not already there.
	    *
	    * @static
	    * @param {string} size
	    * @returns {string}
	    *
	    * @memberOf StringUtils
	    */
	    // public static normalizeSize(size: string): string {
	    //     if (!size) {
	    //         return null;
	    //     }
	    //     if (/\d$/.test(size)) {
	    //         return size + 'px';
	    //     }
	    //     return size;
	    // }
	    StringUtils.wordAt = function (text, position) {
	        var boundaries = this.wordBoundariesAt(text, position);
	        return text.substring(boundaries.start, boundaries.end);
	    };
	    // letter at 'start' is included in word, while letter at index 'end' is excluded
	    StringUtils.wordBoundariesAt = function (text, position) {
	        var left = text.substring(0, position).search(/\S+$/);
	        var right = text.substring(position).search(/\s/);
	        if (left === -1) {
	            left = position;
	        }
	        if (right === -1) {
	            right = text.length;
	        }
	        else {
	            right += position;
	        }
	        return {
	            start: left,
	            end: right
	        };
	    };
	    StringUtils.b64DecodeUnicode = function (str) {
	        return decodeURIComponent(Array.prototype.map.call(atob(str), function (c) {
	            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
	        }).join(''));
	    };
	    StringUtils.zipString = function (a, b) {
	        if (a.length === 0) {
	            return b;
	        }
	        if (b.length === 0) {
	            return a;
	        }
	        return a[0] + b[0] + this.zipString(a.substr(1), b.substr(1));
	    };
	    return StringUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StringUtils;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var definition_1 = __webpack_require__(18);
	var ButtonDefinition = (function (_super) {
	    __extends(ButtonDefinition, _super);
	    function ButtonDefinition() {
	        _super.apply(this, arguments);
	    }
	    return ButtonDefinition;
	}(definition_1.Definition));
	exports.ButtonDefinition = ButtonDefinition;


/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";
	var Definition = (function () {
	    function Definition() {
	    }
	    Definition.prototype.MergeWith = function (definition) {
	        if (!definition) {
	            return;
	        }
	        var objectTarget = this;
	        var objectSource = definition;
	        for (var prop in objectSource) {
	            if (!objectSource.hasOwnProperty(prop)) {
	                continue;
	            }
	            if (prop.indexOf('_') === 0) {
	                continue;
	            }
	            if (objectSource[prop] !== undefined && objectSource[prop] !== null) {
	                objectTarget[prop] = objectSource[prop];
	            }
	        }
	    };
	    return Definition;
	}());
	exports.Definition = Definition;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var attributes_1 = __webpack_require__(12);
	var ButtonAttributes = (function (_super) {
	    __extends(ButtonAttributes, _super);
	    function ButtonAttributes() {
	        _super.apply(this, arguments);
	    }
	    ButtonAttributes.TEXT = 'data-text';
	    ButtonAttributes.COLOR = 'data-color';
	    return ButtonAttributes;
	}(attributes_1.Attributes));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ButtonAttributes;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var definition_1 = __webpack_require__(18);
	var ChatDefinition = (function (_super) {
	    __extends(ChatDefinition, _super);
	    function ChatDefinition() {
	        _super.apply(this, arguments);
	        this.CanClose = true;
	    }
	    return ChatDefinition;
	}(definition_1.Definition));
	exports.ChatDefinition = ChatDefinition;


/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	var PreloadType = (function () {
	    function PreloadType() {
	    }
	    PreloadType.NONE = 'none';
	    PreloadType.UIONLY = 'uionly';
	    PreloadType.FULL = 'full';
	    return PreloadType;
	}());
	exports.PreloadType = PreloadType;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var ButtonRenderEvent = (function (_super) {
	    __extends(ButtonRenderEvent, _super);
	    function ButtonRenderEvent() {
	        _super.call(this, 'kpi_button_render');
	    }
	    ButtonRenderEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('chatId', this.chatId ? this.chatId : telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return ButtonRenderEvent;
	}(telemetryEvent_1.TelemetryEvent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ButtonRenderEvent;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	var app_1 = __webpack_require__(26);
	var config_1 = __webpack_require__(27);
	var identityType_1 = __webpack_require__(29);
	var errorHandler_1 = __webpack_require__(15);
	exports.NA = 'n/a';
	/**
	 * Base telemetry event class which all the
	 * specialized events have to extend.
	 *
	 * @export
	 * @abstract
	 * @class TelemetryEvent
	 */
	var TelemetryEvent = (function () {
	    function TelemetryEvent(eventName) {
	        this.name = eventName;
	        this.timestamp = Date.now();
	        this.type = 'general';
	    }
	    /**
	     * Method providing a perf efficient way for telemetry provider
	     * to get a list of all event properties which needs to be sent.
	     *
	     * @abstract
	     * @returns {Array<TelemetryPropertyValue>}
	     *
	     * @memberOf TelemetryEvent
	     */
	    TelemetryEvent.prototype.getEventProperties = function () {
	        this.version = telemetryPropertyValue_1.TelemetryPropertyValue.Create('version', config_1.default.ECS.version, piiType_1.PIIType.NotSet);
	        this.host = telemetryPropertyValue_1.TelemetryPropertyValue.Create('host', this.gethost(), piiType_1.PIIType.NotSet);
	        this.lang = telemetryPropertyValue_1.TelemetryPropertyValue.Create('lang', app_1.default.language || exports.NA, piiType_1.PIIType.NotSet);
	        this.user = telemetryPropertyValue_1.TelemetryPropertyValue.Create('user', app_1.default.currentUserName || exports.NA, piiType_1.PIIType.Identity);
	        this.setIdentityType();
	        var properties = this.getCustomProperties();
	        return properties;
	    };
	    // public isBotRelated(): boolean {
	    //     return this.sdkMode === SDKMode.BOT || this.sdkMode === SDKMode.DIRECT_LINE_TOKEN;
	    // }
	    // public isPersonRelated(): boolean {
	    //     return this.sdkMode === SDKMode.PERSON;
	    // }
	    TelemetryEvent.prototype.getProperty = function (value) {
	        if (value === undefined || value === null) {
	            return exports.NA;
	        }
	        if (typeof (value) !== 'string') {
	            return value + '';
	        }
	        return value;
	    };
	    /**
	   * Sets the identitytype property.
	   *
	   * @private
	   *
	   * @memberOf TelemetryEvent
	   */
	    TelemetryEvent.prototype.setIdentityType = function () {
	        var type = '';
	        switch (app_1.default.currentUserIdentityType) {
	            case identityType_1.IdentityType.UNDETERMINED:
	                type = exports.NA;
	                break;
	            case identityType_1.IdentityType.GUEST:
	                type = 'Guest';
	                break;
	            case identityType_1.IdentityType.SKYPE:
	                type = 'Skype';
	                break;
	            case identityType_1.IdentityType.DL_TOKEN:
	                type = 'Direct line token';
	                break;
	            case identityType_1.IdentityType.UNDEFINED:
	                errorHandler_1.default.throwError(10030, 'Undefined identity type:' + app_1.default.currentUserIdentityType);
	            default:
	                errorHandler_1.default.throwError(10031, 'Unknown identityType:' + app_1.default.currentUserIdentityType);
	        }
	        console.log('[telemetryEvent:] ' + type);
	        this.identityType = telemetryPropertyValue_1.TelemetryPropertyValue.Create('identitytype', type, piiType_1.PIIType.NotSet);
	    };
	    TelemetryEvent.prototype.gethost = function () {
	        if (app_1.default.host && app_1.default.host !== exports.NA) {
	            return app_1.default.host;
	        }
	        try {
	            return window.location.hostname;
	        }
	        catch (e) {
	            return exports.NA;
	        }
	    };
	    return TelemetryEvent;
	}());
	exports.TelemetryEvent = TelemetryEvent;


/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	var TelemetryPropertyValue = (function () {
	    function TelemetryPropertyValue() {
	    }
	    /**
	     * Creates a new telemetry property instance.
	     *
	     * @static
	     * @param {string} key
	     * @param {(string | number | boolean)} value
	     * @param {PIIType} type
	     * @returns
	     *
	     * @memberOf TelemeteryPropertyValue
	     */
	    TelemetryPropertyValue.Create = function (key, value, type) {
	        var telemetryProperty = new TelemetryPropertyValue();
	        telemetryProperty.key = key;
	        telemetryProperty.value = value;
	        telemetryProperty.type = type;
	        return telemetryProperty;
	    };
	    return TelemetryPropertyValue;
	}());
	exports.TelemetryPropertyValue = TelemetryPropertyValue;


/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	(function (PIIType) {
	    PIIType[PIIType["NotSet"] = 0] = "NotSet";
	    // DistinguishedName = 1,
	    // GenericData = 2,
	    // IPV4Address = 3,
	    // IPv6Address = 4,
	    // MailSubject = 5,
	    // PhoneNumber = 6,
	    // QueryString = 7,
	    // SipAddress = 8,
	    // SmtpAddress = 9,
	    PIIType[PIIType["Identity"] = 10] = "Identity";
	})(exports.PIIType || (exports.PIIType = {}));
	var PIIType = exports.PIIType;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config_1 = __webpack_require__(27);
	var identityType_1 = __webpack_require__(29);
	var sdkMode_1 = __webpack_require__(30);
	var App = (function () {
	    function App() {
	    }
	    // public static isDirectLineBackend(){
	    //     return this.backend === MessagingBackend.DIRECT_LINE;
	    // }
	    App.isGuestUser = function () {
	        return this.currentUserIdentityType === identityType_1.IdentityType.GUEST;
	    };
	    /**
	     * Currect culture locale of the user - default en-us
	     *
	     * @static
	     *
	     * @memberOf App
	     */
	    App.currentLocale = config_1.default.LOCALE;
	    /**
	     * Backend service being use by the control.
	     *
	     * @static
	     * @type {MessagingBackend}
	     * @memberOf App
	     */
	    // public static backend: MessagingBackend = MessagingBackend.UNDETERMINED;
	    /**
	     * Represents the identity of the current user.
	     *
	     * @static
	     * @type {IdentityType.UNDETERMINED}
	     * @memberOf App
	     */
	    App.currentUserIdentityType = identityType_1.IdentityType.UNDETERMINED;
	    /**
	     * Mode in which SDK markup is defined.
	     *
	     * @static
	     * @type {SDKMode}
	     * @memberOf App
	     */
	    App.activeConversationSdkMode = sdkMode_1.SDKMode.UNDEFINED;
	    /**
	     * Identifier of the hosting property -
	     * 1st party - name
	     * 3rd party - guid
	     *
	     * @static
	     * @type {string}
	     * @memberOf App
	     */
	    App.host = 'N/A';
	    App.translatorEnabled = false;
	    App.frameless = false;
	    return App;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = App;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var sessionStorageKeys_1 = __webpack_require__(28);
	var errorHandler_1 = __webpack_require__(15);
	var Configuration = (function () {
	    function Configuration() {
	    }
	    Object.defineProperty(Configuration, "ECS", {
	        get: function () {
	            if (!SkypeWebControl || !SkypeWebControl.EcsConfig) {
	                errorHandler_1.default.throwError(10001, 'You need to setup ecs config context prior to using it.');
	            }
	            return SkypeWebControl.EcsConfig;
	        },
	        set: function (value) {
	            window.SkypeWebControl = window.SkypeWebControl || {};
	            window.SkypeWebControl.EcsConfig = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Configuration.APPNAME = 'SWC';
	    Configuration.LOCALE = 'en-us';
	    Configuration.ORIGIN = 'SkypeLWC';
	    Configuration.MSG_MAX_LENGTH = 2000;
	    Configuration.SKYPE_TOKEN_KEY = sessionStorageKeys_1.SKYPE_TOKEN_KEY;
	    Configuration.SKYPE_REGTOKEN_KEY = sessionStorageKeys_1.SKYPE_REGTOKEN_KEY;
	    Configuration.PLATFORM_ID = 912;
	    // NOTE: nimal, 5.10.2016 - Changing this requires rev change in Loader!
	    Configuration.BUTTON_MARKER_CLASS = '.skype-button';
	    // NOTE: nimal, 5.10.2016 - Changing this requires rev change in Loader!
	    Configuration.CHAT_MARKER_CLASS = '.skype-chat';
	    Configuration.CHAT_FRAME_MARKER_CLASS = '.lwc-chat-frame';
	    // signin manager
	    Configuration.LOGIN_CLIENT_ID = '919866';
	    Configuration.LOGIN_PAGE_URL = 'https://login.skype.com/login';
	    Configuration.LOGIN_THEME = 'skype-white';
	    Configuration.LOGOUT_PAGE_URL = 'https://login.skype.com/logout';
	    Configuration.LOGIN_POPUP_URL = 'https://demoplayground.skype.com/joinlwc?t=';
	    Configuration.LOGIN_POPUP_FEATURES = 'width=600, height=620, menubar=no, status=no, titlebar=no, toolbar=no';
	    Configuration.LOGOUT_POPUP_FEATURES = 'width=1, height=1, menubar=no, status=no, titlebar=no, toolbar=no';
	    // services/ams
	    Configuration.AMS_HOST_URL = 'https://api.asm.skype.com/v1/';
	    // services/aps
	    Configuration.APS_HOST_URL = 'https://api.aps.skype.com/v1/';
	    Configuration.CDN_SERVICE_HOST = 'secure.skypeassets.com';
	    // services/urlp
	    Configuration.URLP_SERVICE_URL = 'https://urlp.asm.skype.com';
	    // services/SkypeGraphe
	    Configuration.SKYPE_GRAPH_URL = 'https://skypegraph.skype.com/';
	    // services/invite
	    // public static INVITE_HOST_URL = 'https://latest-join.skype.com/api/v1/';
	    Configuration.INVITE_HOST_URL = 'https://join.skype.com/api/v1/';
	    // services/chat
	    // public static CHAT_MAX_RETRIES = 3;
	    Configuration.CHAT_CLIENT_INFO = 'os=Windows; osVer=10; proc=Win32; lcid=en-us; deviceType=1; country=n/a; clientName=swc; clientVer=999/0.80.0.0/swc';
	    // public static CHAT_GUEST_HOST_URL = 'https://co4-df-client-s.gateway.messenger.live.com/v1/';
	    Configuration.CHAT_GUEST_HOST_URL = 'https://client-s.gateway.messenger.live.com/v1/';
	    Configuration.CHAT_HOST_URL = 'https://client-s.gateway.messenger.live.com/v1/';
	    Configuration.CHAT_JOIN_URL = 'https://latest-join.skype.com/api/v2/conversation';
	    // services/contactss
	    Configuration.SKYPE_CALLER_ID = 'lwc';
	    Configuration.CONTACTS_HOST_URL = 'https://contacts.skype.com/contacts/v2/';
	    // services/joinagents
	    Configuration.AGENTS_HOST_URL = 'https://join.skype.com/';
	    // services/stratus
	    Configuration.STRATUS_DOMAIN_HOST_URL = 'https://api.skype.com/';
	    Configuration.ECS_CLIENT_NAME = 'skype';
	    Configuration.ECS_TEAM_NAME = 'lwc';
	    Configuration.ECS_CLIENT_VERSION = '1.00';
	    return Configuration;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Configuration;


/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";
	exports.SKYPE_TOKEN_KEY = 'skype|token';
	exports.SKYPE_REGTOKEN_KEY = 'skype|registrationtoken';


/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";
	(function (IdentityType) {
	    /**
	     * Using of this enum points to application error.
	     */
	    IdentityType[IdentityType["UNDEFINED"] = 0] = "UNDEFINED";
	    /**
	     * The identity of user is not determined at this time yet.
	     */
	    IdentityType[IdentityType["UNDETERMINED"] = 10] = "UNDETERMINED";
	    /**
	     * User is a skype guest user
	     */
	    IdentityType[IdentityType["GUEST"] = 100] = "GUEST";
	    /**
	     * User is a skype authenticated user
	     */
	    IdentityType[IdentityType["SKYPE"] = 200] = "SKYPE";
	    /**
	     * User authenticated using the DL token
	     */
	    IdentityType[IdentityType["DL_TOKEN"] = 300] = "DL_TOKEN";
	})(exports.IdentityType || (exports.IdentityType = {}));
	var IdentityType = exports.IdentityType;


/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	(function (SDKMode) {
	    /**
	     * Using of this enum points to application error.
	     */
	    SDKMode[SDKMode["UNDEFINED"] = 0] = "UNDEFINED";
	    /**
	     * Conversation is 1-1 conversation with another skype user.
	     */
	    SDKMode[SDKMode["PERSON"] = 1] = "PERSON";
	    /**
	     * Conversation is group conversation for a given threadId
	     */
	    SDKMode[SDKMode["THREAD"] = 2] = "THREAD";
	    /**
	     * Conversation is 1-1 conversation with a bot.
	     */
	    SDKMode[SDKMode["BOT"] = 3] = "BOT";
	    /**
	     * Conversation is group conversation for a given join url,
	     */
	    SDKMode[SDKMode["JOIN_URL"] = 4] = "JOIN_URL";
	    /**
	     * Direct line mode
	     */
	    SDKMode[SDKMode["DIRECT_LINE_TOKEN"] = 5] = "DIRECT_LINE_TOKEN";
	})(exports.SDKMode || (exports.SDKMode = {}));
	var SDKMode = exports.SDKMode;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var ButtonClickEvent = (function (_super) {
	    __extends(ButtonClickEvent, _super);
	    function ButtonClickEvent() {
	        _super.call(this, 'kpi_button_click');
	    }
	    ButtonClickEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('chatId', this.chatId ? this.chatId : telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return ButtonClickEvent;
	}(telemetryEvent_1.TelemetryEvent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ButtonClickEvent;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var app_1 = __webpack_require__(26);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var config_1 = __webpack_require__(27);
	var guid_1 = __webpack_require__(33);
	var piiType_1 = __webpack_require__(25);
	app_1.default.sessionId = guid_1.default.createNew();
	var SESSION_PROPERTY = telemetryPropertyValue_1.TelemetryPropertyValue.Create('sessionId', app_1.default.sessionId, piiType_1.PIIType.NotSet);
	var AriaTelemetryService = (function () {
	    function AriaTelemetryService() {
	    }
	    // todo - this can be most probably promiseless
	    AriaTelemetryService.prototype.getLogger = function () {
	        var _this = this;
	        if (this.loggerPromise) {
	            return this.loggerPromise;
	        }
	        var self = this;
	        this.loggerPromise = new Promise(function (resolve, reject) {
	            if (_this.logger) {
	                resolve(_this.logger);
	                self.loggerPromise = null;
	                return;
	            }
	            window.ariaTelemetry.LogManager.initialize(config_1.default.ECS.ariaTenantId);
	            _this.logger = new window.ariaTelemetry.Logger(config_1.default.ECS.ariaTenantId);
	            resolve(_this.logger);
	            self.loggerPromise = null;
	        });
	        return this.loggerPromise;
	    };
	    ;
	    AriaTelemetryService.prototype.sendEvent = function (event) {
	        var _this = this;
	        this.getLogger().then(function (logger) {
	            var eventProperties = new window.ariaTelemetry.EventProperties();
	            eventProperties.name = event.name;
	            eventProperties.eventType = event.type;
	            eventProperties.timestamp = event.timestamp;
	            // todo: pass served config ids from ecs and pass them here
	            var properties = event.getEventProperties();
	            properties.forEach(function (property) {
	                _this.addProperty(eventProperties, property);
	            });
	            _this.addProperty(eventProperties, event.version);
	            _this.addProperty(eventProperties, event.user);
	            _this.addProperty(eventProperties, event.identityType);
	            _this.addProperty(eventProperties, event.host);
	            _this.addProperty(eventProperties, SESSION_PROPERTY);
	            console.log(eventProperties);
	            logger.logEvent(eventProperties);
	        });
	    };
	    ;
	    AriaTelemetryService.prototype.addProperty = function (eventProperties, property) {
	        eventProperties.setProperty(property.key, property.value + '', property.type);
	    };
	    ;
	    return AriaTelemetryService;
	}());
	exports.AriaTelemetryService = AriaTelemetryService;


/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";
	var Guid = (function () {
	    function Guid() {
	    }
	    /**
	     * Creates a new guid.
	     *
	     * @static
	     * @returns {string}
	     *
	     * @memberOf Guid
	     */
	    Guid.createNew = function () {
	        var s4 = function () {
	            return Math.floor((1 + Math.random()) * 0x10000)
	                .toString(16)
	                .substring(1);
	        };
	        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	            s4() + '-' + s4() + s4() + s4();
	    };
	    return Guid;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Guid;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var actionNames_1 = __webpack_require__(35);
	var chatAttributes_1 = __webpack_require__(36);
	var chatConfigFactory_1 = __webpack_require__(37);
	var chatDefinition_1 = __webpack_require__(20);
	var messagingBackend_1 = __webpack_require__(38);
	var packageName_1 = __webpack_require__(39);
	var sdkMode_1 = __webpack_require__(30);
	var preloadType_1 = __webpack_require__(21);
	var config_1 = __webpack_require__(27);
	var frameUtils_1 = __webpack_require__(40);
	var urlHelper_1 = __webpack_require__(42);
	var conversationType_1 = __webpack_require__(14);
	var DEFAULT_LANGUAGE = 'en-us';
	var ChatBootstrapper = (function () {
	    function ChatBootstrapper() {
	        var _this = this;
	        this._chatConfigFactory = new chatConfigFactory_1.ChatConfigFactory();
	        this._startDate = Date.now();
	        this._isHidden = true;
	        this._isCollapsed = false;
	        this._onFocus = function () { return _this._postMessage({
	            origin: config_1.default.ORIGIN,
	            action: actionNames_1.default.StartActivation,
	            lifeTime: Date.now() - _this._startDate,
	        }); };
	        this._onBlur = function () { return _this._postMessage({
	            origin: config_1.default.ORIGIN,
	            action: actionNames_1.default.StopActivation,
	            lifeTime: Date.now() - _this._startDate,
	        }); };
	        this.resolveMessage = function (payload) {
	            // ui actions
	            if (!_this._hostElement) {
	                return;
	            }
	            switch (payload.action) {
	                case actionNames_1.default.HideChatWindow:
	                    _this._hideChat();
	                    break;
	                case actionNames_1.default.ShowChatWindow:
	                    _this._showChatWindow();
	                    break;
	                case actionNames_1.default.CollapseChatWindow:
	                    _this._collapseChat();
	                    break;
	                case actionNames_1.default.ExpandChatWindow:
	                    _this._expandChat();
	                    break;
	            }
	        };
	        this.onMessageHandler = function (event) {
	            if (event.data.origin !== config_1.default.ORIGIN || !/^bs:/.test(event.data.action)) {
	                return;
	            }
	            _this.resolveMessage(event.data);
	            event.stopImmediatePropagation();
	        };
	        this.startChat = function (definition) {
	            if (definition && !definition.MergeWith) {
	                var definitionObj = new chatDefinition_1.ChatDefinition();
	                definitionObj.MergeWith(definition);
	                definition = definitionObj;
	            }
	            // if (definition && this._chatAttributes){
	            //     definition.MergeWith(this._chatAttributes);
	            // }
	            if (definition) {
	                _this._chatAttributes = definition;
	            }
	            var switchConversations = _this._currentConversationId && definition.ConversationId !== _this._currentConversationId;
	            if (_this.chatControlExists() && !switchConversations) {
	                _this._isHidden ? _this._showChatWindow() : _this._hideChat();
	                return;
	            }
	            if (_this._isCollapsed) {
	                _this._expandChat();
	                _this._postMessage({
	                    origin: config_1.default.ORIGIN,
	                    action: actionNames_1.default.ExpandChatWindow,
	                    lifeTime: Date.now() - _this._startDate,
	                    isModule: _this._isModule
	                });
	            }
	            _this._openConversation(definition.ConversationId, _this.getSdkModeFromType(definition.ConversationType), null, switchConversations);
	        };
	        this.showChat = function () {
	            _this._postMessage({
	                origin: config_1.default.ORIGIN,
	                action: actionNames_1.default.LoadChatData,
	                lifeTime: Date.now() - _this._startDate,
	                isModule: _this._isModule
	            });
	            _this._showChatWindow();
	        };
	        this._fillPostMessageData = function (id, initTime) {
	            var skypeConversationPlaceholder = document.querySelector('.skype-chat');
	            var data = {
	                id: id,
	                initTime: initTime,
	                messagingBackend: null,
	                lang: null,
	                ecs: null,
	                chatConfig: _this._chatAttributes
	            };
	            if (skypeConversationPlaceholder) {
	                data.token = skypeConversationPlaceholder.getAttribute(chatAttributes_1.default.TOKEN);
	            }
	            if (config_1.default.ECS.partner && !data.chatConfig.Partner) {
	                data.chatConfig.Partner = config_1.default.ECS.partner;
	            }
	            if (config_1.default.ECS.partner && config_1.default.ECS.partner === "bing") {
	                data.chatConfig.CanCollapse = true;
	            }
	            // init data
	            data.lang = document.documentElement.lang || DEFAULT_LANGUAGE;
	            data.ecs = config_1.default.ECS;
	            return data;
	        };
	        this._openConversation = function (id, mode, initTime, switchConversations) {
	            _this._currentConversationId = id;
	            initTime = initTime || Date.now();
	            SkypeWebControl.SDK.Backend = mode === sdkMode_1.SDKMode.DIRECT_LINE_TOKEN ? messagingBackend_1.MessagingBackend.DIRECT_LINE : messagingBackend_1.MessagingBackend.SKYPE;
	            var data = _this._fillPostMessageData(id, initTime);
	            if (switchConversations) {
	                data.switchConversation = true;
	                _this._postLoadConverstionEvent(mode, data);
	            }
	            else {
	                _this._initAndPostConversationEvent(mode, data);
	            }
	        };
	        this._hideChat = function () {
	            if (!_this._hostElement) {
	                return;
	            }
	            if (_this._chatAttributes.EntryAnim) {
	                _this._hostElement.classList.remove('open-chat');
	                _this._hostElement.classList.add('close-chat');
	            }
	            else {
	                _this._hostElement.style.display = 'none';
	            }
	            _this._showSkypeButton();
	            _this._isHidden = true;
	        };
	        this._collapseChat = function () {
	            if (!_this._hostElement) {
	                return;
	            }
	            _this._hostElement.classList.add('collapsed');
	            _this._isCollapsed = true;
	        };
	        this._expandChat = function () {
	            if (!_this._hostElement) {
	                return;
	            }
	            _this._hostElement.classList.remove('collapsed');
	            _this._isCollapsed = false;
	        };
	        this._showChatWindow = function () {
	            if (!_this._hostElement) {
	                return;
	            }
	            if (_this._chatAttributes._isHidden) {
	                return;
	            }
	            if (_this._chatAttributes.EntryAnim === undefined || !!_this._chatAttributes.EntryAnim) {
	                _this._hostElement.classList.remove('close-chat');
	                _this._hostElement.classList.add('open-chat');
	                _this._hostElement.style.display = '';
	            }
	            else {
	                _this._hostElement.style.display = 'flex'; // null
	            }
	            // notify the chat about visibility || frameless
	            _this._postMessage({
	                origin: config_1.default.ORIGIN,
	                action: actionNames_1.default.OpenChatWindow,
	                lifeTime: Date.now() - _this._startDate,
	                isModule: _this._isModule
	            });
	            _this._isHidden = false;
	        };
	        this._initAndPostConversationEvent = function (mode, data) {
	            var chatFrame = document.querySelector('.lwc-chat-frame');
	            if (chatFrame) {
	                return;
	            }
	            var skypeConversationPlaceholder = document.querySelector(config_1.default.CHAT_MARKER_CLASS);
	            if (!skypeConversationPlaceholder) {
	                skypeConversationPlaceholder = document.createElement('div');
	                skypeConversationPlaceholder.setAttribute('class', 'skype-chat');
	                document.body.appendChild(skypeConversationPlaceholder);
	            }
	            _this.createChatControl(mode, data);
	        };
	        this._postLoadConverstionEvent = function (mode, data) {
	            data.chatConfig = _this._chatAttributes;
	            _this._postMessage({
	                origin: config_1.default.ORIGIN,
	                action: actionNames_1.default.ShowChatWindow,
	                lifeTime: Date.now() - _this._startDate,
	                sdkmode: mode,
	                id: data.id,
	                data: data,
	                host: SkypeWebControl.SDK.host,
	                isModule: _this._isModule
	            });
	        };
	    }
	    ChatBootstrapper.prototype.init = function (isModule) {
	        this._isModule = isModule;
	        var hasChatButtons = this.buttonControlsExists();
	        this.setupChatAttrs();
	        var hostName = window.location.hostname.replace('www.', '');
	        this._frameless = this._isModule || (!!hostName && config_1.default.ECS.frameless.indexOf(hostName) > -1);
	        !this._frameless && window.addEventListener('message', this.onMessageHandler);
	        if (!hasChatButtons && !isModule) {
	            this._chatAttributes.CanClose = false;
	            this.initChat();
	        }
	        window.addEventListener('focus', this._onFocus);
	        window.addEventListener('blur', this._onBlur);
	    };
	    ChatBootstrapper.prototype.setupChatAttrs = function () {
	        var skypeConversationPlaceholder = document.querySelector(config_1.default.CHAT_MARKER_CLASS);
	        if (!skypeConversationPlaceholder) {
	            return;
	        }
	        var domDefinition = this._chatConfigFactory.getDefinitionFromDOM(skypeConversationPlaceholder);
	        var urlDefinition = this._chatConfigFactory.getDefinitionFromUrl();
	        urlDefinition.MergeWith(domDefinition);
	        this._chatConfigFactory.setDOMFrom(urlDefinition, skypeConversationPlaceholder);
	        this._chatAttributes = urlDefinition;
	    };
	    ChatBootstrapper.prototype.initChat = function () {
	        var skypeConversationPlaceholder = document.querySelector(config_1.default.CHAT_MARKER_CLASS);
	        if (skypeConversationPlaceholder && this._chatAttributes.Preload !== preloadType_1.PreloadType.NONE) {
	            this._openConversation(this._chatAttributes.ConversationId, this.getSdkModeFromType(this._chatAttributes.ConversationType));
	        }
	    };
	    ChatBootstrapper.prototype.chatControlExists = function () {
	        return !!document.querySelector(config_1.default.CHAT_FRAME_MARKER_CLASS);
	    };
	    ChatBootstrapper.prototype.buttonControlsExists = function () {
	        return !!document.querySelector(config_1.default.BUTTON_MARKER_CLASS);
	    };
	    ChatBootstrapper.prototype.getChatAttrs = function () {
	        var skypeConversationPlaceholder = document.querySelector(config_1.default.CHAT_MARKER_CLASS);
	        if (!skypeConversationPlaceholder) {
	            return new chatDefinition_1.ChatDefinition();
	        }
	        return this._chatConfigFactory.getDefinitionFromDOM(skypeConversationPlaceholder);
	        // return this._chatAttributes;
	    };
	    ChatBootstrapper.prototype.dispose = function () {
	        window.removeEventListener('focus', this._onFocus);
	        window.removeEventListener('blur', this._onBlur);
	        window.removeEventListener('message', this.onMessageHandler);
	        var ns = window.SkypeWebControl;
	        ns.ChatContent && ns.ChatContent.dispose();
	        if (this._hostElement) {
	            var container = this._hostElement.parentElement;
	            container && container.removeChild(this._hostElement);
	        }
	    };
	    ChatBootstrapper.prototype.getSdkModeFromType = function (type) {
	        switch (type) {
	            case conversationType_1.default.PERSON:
	                return sdkMode_1.SDKMode.PERSON;
	            case conversationType_1.default.AGENT:
	                return sdkMode_1.SDKMode.BOT;
	            case conversationType_1.default.JOIN:
	                return sdkMode_1.SDKMode.JOIN_URL;
	            case conversationType_1.default.DIRECT_LINE:
	                return sdkMode_1.SDKMode.DIRECT_LINE_TOKEN;
	        }
	        return sdkMode_1.SDKMode.UNDEFINED;
	    };
	    ChatBootstrapper.prototype.createChatControl = function (mode, data) {
	        var _this = this;
	        if (this.chatControlExists()) {
	            return;
	        }
	        var chatConfigFactory = new chatConfigFactory_1.ChatConfigFactory();
	        var skypeChatPlaceholder = document.querySelector(config_1.default.CHAT_MARKER_CLASS);
	        var domDefinition = chatConfigFactory.getDefinitionFromDOM(skypeChatPlaceholder);
	        var urlDefinition = chatConfigFactory.getDefinitionFromUrl();
	        domDefinition.MergeWith(urlDefinition);
	        domDefinition.MergeWith(this._chatAttributes);
	        chatConfigFactory.setDOMFrom(domDefinition, skypeChatPlaceholder);
	        this._chatAttributes = domDefinition;
	        if (this._frameless) {
	            this._hostElement = frameUtils_1.default.injectFrameless(skypeChatPlaceholder);
	            if (this._isModule) {
	                var api = window.SkypeWebControl.API;
	                api && api.triggerEvent('createControl', this._hostElement);
	                this._postLoadConverstionEvent(mode, data);
	            }
	            else {
	                var bundleScript = document.createElement('script');
	                bundleScript.type = 'text/javascript';
	                bundleScript.src = urlHelper_1.default.getAbsoluteUrl('chat-bundle', 'js');
	                this._hostElement.appendChild(bundleScript);
	                bundleScript.onload = (function () { _this._postLoadConverstionEvent(mode, data); });
	            }
	        }
	        else {
	            var url = urlHelper_1.default.getAbsoluteUrl(packageName_1.PackageName.INDEX_CHAT, 'html');
	            var iframe = void 0;
	            iframe = frameUtils_1.default.inject(url, skypeChatPlaceholder);
	            iframe.onload = function () {
	                _this._postLoadConverstionEvent(mode, data);
	            };
	            this._hostElement = iframe;
	            this._hostElement.style.display = 'none';
	        }
	        this._hostElement.classList.add('lwc-chat-frame');
	        if (this._chatAttributes.Preload === preloadType_1.PreloadType.FULL) {
	            this.startChat();
	        }
	    };
	    ChatBootstrapper.prototype._showSkypeButton = function () {
	        var skypeButtonPlaceholders = document.querySelectorAll('.skype-button');
	        for (var i = 0; i < skypeButtonPlaceholders.length; i++) {
	            var skypeButtonPlaceholder = skypeButtonPlaceholders[i];
	            if (!skypeButtonPlaceholder.classList.contains('bubble')) {
	                return;
	            }
	            skypeButtonPlaceholder.firstElementChild.classList.remove('open-bubble');
	            skypeButtonPlaceholder.firstElementChild.classList.add('close-bubble');
	        }
	    };
	    ChatBootstrapper.prototype._postMessage = function (message) {
	        if (!this._hostElement) {
	            return;
	        }
	        if (this._frameless) {
	            window.SkypeWebControl.ChatContent.runChat(message);
	        }
	        else {
	            this._hostElement.contentWindow.postMessage(message, config_1.default.ECS.domain);
	        }
	    };
	    return ChatBootstrapper;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ChatBootstrapper;


/***/ },
/* 35 */
/***/ function(module, exports) {

	"use strict";
	var ActionNames = (function () {
	    function ActionNames() {
	    }
	    // UI handling actions
	    ActionNames.HideChatWindow = 'bs:hChat';
	    ActionNames.OpenChatWindow = 'bs:oChat';
	    ActionNames.ShowChatWindow = 'bs:sChat';
	    ActionNames.CollapseChatWindow = 'bs:chat:collapse';
	    ActionNames.ExpandChatWindow = 'bs:chat:expand';
	    ActionNames.LoadChatData = 'bs:sChat:run';
	    ActionNames.StartActivation = 'bs:sChat:startActivation';
	    ActionNames.StopActivation = 'bs:sChat:stopActivation';
	    ActionNames.MessageSent = 'lwc:mSent';
	    return ActionNames;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ActionNames;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var attributes_1 = __webpack_require__(12);
	var default_1 = (function (_super) {
	    __extends(default_1, _super);
	    function default_1() {
	        _super.apply(this, arguments);
	    }
	    default_1.CAN_COLLAPSE = "data-can-collapse";
	    default_1.CAN_CLOSE = 'data-can-close';
	    default_1.CAN_UPLOAD_FILE = 'data-can-upload-file';
	    default_1.SHOW_HEADER = 'data-show-header';
	    default_1.COLOR = 'data-color';
	    default_1.CSS_URL = 'data-css-url';
	    default_1.PARTNER = 'data-partner';
	    default_1.COLOR_MESSAGE = 'data-color-message';
	    default_1.PRELOAD = 'data-preload';
	    default_1.ENTRY_ANIM = 'data-entry-animation';
	    default_1.ENABLE_TRANSLATOR = 'data-enable-translator';
	    default_1.FRAMELESS = 'data-frameless';
	    default_1.GuestOnly = 'data-guest-only';
	    return default_1;
	}(attributes_1.Attributes));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var configFactory_1 = __webpack_require__(11);
	var chatDefinition_1 = __webpack_require__(20);
	var chatAttributes_1 = __webpack_require__(36);
	var stringUtils_1 = __webpack_require__(16);
	var ChatConfigFactory = (function (_super) {
	    __extends(ChatConfigFactory, _super);
	    function ChatConfigFactory() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Returns chat control definition built from the default values
	     * and updated with values sent through the url of the hosting page.
	     * Primarily  used to pass the config context to a hosting iframe.
	     *
	     * @returns {ChatDefinition}
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ChatConfigFactory.prototype.getDefinitionFromUrl = function () {
	        var params = this.getQueryStringParameters();
	        var definition = new chatDefinition_1.ChatDefinition();
	        if (!params) {
	            return definition;
	        }
	        this.parseBaseUrlParams(definition, params);
	        if (params[chatAttributes_1.default.AVATAR]) {
	            definition.Avatar = params[chatAttributes_1.default.AVATAR];
	        }
	        if (params[chatAttributes_1.default.CAN_UPLOAD_FILE]) {
	            definition.CanUploadFile = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.CAN_UPLOAD_FILE]);
	        }
	        if (params[chatAttributes_1.default.PARTNER]) {
	            definition.Partner = params[chatAttributes_1.default.PARTNER];
	        }
	        if (params[chatAttributes_1.default.CAN_UPLOAD_FILE]) {
	            definition.CanUploadFile = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.CAN_UPLOAD_FILE]);
	        }
	        if (params[chatAttributes_1.default.CAN_COLLAPSE]) {
	            definition.CanCollapse = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.CAN_COLLAPSE]);
	        }
	        if (params[chatAttributes_1.default.FRAMELESS]) {
	            definition.Frameless = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.FRAMELESS]);
	        }
	        if (params[chatAttributes_1.default.ENABLE_TRANSLATOR]) {
	            definition.EnableTranslator = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.ENABLE_TRANSLATOR]);
	        }
	        if (params[chatAttributes_1.default.SHOW_HEADER]) {
	            definition.ShowHeader = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.SHOW_HEADER]);
	        }
	        if (params[chatAttributes_1.default.COLOR]) {
	            definition.ColorMain = params[chatAttributes_1.default.COLOR];
	        }
	        if (params[chatAttributes_1.default.COLOR_MESSAGE]) {
	            definition.ColorMessage = params[chatAttributes_1.default.COLOR_MESSAGE];
	        }
	        if (params[chatAttributes_1.default.CSS_URL]) {
	            definition.CssUrl = params[chatAttributes_1.default.CSS_URL];
	        }
	        if (params[chatAttributes_1.default.PRELOAD]) {
	            definition.Preload = params[chatAttributes_1.default.PRELOAD];
	        }
	        if (params[chatAttributes_1.default.ENTRY_ANIM]) {
	            definition.EntryAnim = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.ENTRY_ANIM]);
	        }
	        if (params[chatAttributes_1.default.GuestOnly]) {
	            definition.GuestOnly = stringUtils_1.default.toBoolean(params[chatAttributes_1.default.GuestOnly]);
	        }
	        return definition;
	    };
	    /**
	     * Sets the attributes of the button element to represent the
	     * state of given button definition.
	     *
	     * @param {ButtonDefinition} definition
	     * @param {Element} [element]
	     *
	     * @memberOf ButtonConfigFactory
	     */
	    ChatConfigFactory.prototype.setDOMFrom = function (definition, element) {
	        this.setBaseDOM(definition, element);
	        if (definition.CanUploadFile) {
	            element.setAttribute(chatAttributes_1.default.CAN_UPLOAD_FILE, definition.CanUploadFile.toString());
	        }
	        if (definition.CanCollapse) {
	            element.setAttribute(chatAttributes_1.default.CAN_COLLAPSE, definition.CanCollapse.toString());
	        }
	        if (definition.ShowHeader) {
	            element.setAttribute(chatAttributes_1.default.SHOW_HEADER, definition.ShowHeader.toString());
	        }
	        if (definition.Partner) {
	            element.setAttribute(chatAttributes_1.default.PARTNER, definition.Partner);
	        }
	        if (definition.Frameless) {
	            element.setAttribute(chatAttributes_1.default.FRAMELESS, definition.Frameless.toString());
	        }
	        if (definition.ColorMain) {
	            element.setAttribute(chatAttributes_1.default.COLOR, definition.ColorMain);
	        }
	        if (definition.CssUrl) {
	            element.setAttribute(chatAttributes_1.default.CSS_URL, definition.CssUrl);
	        }
	        if (definition.ColorMessage) {
	            element.setAttribute(chatAttributes_1.default.COLOR_MESSAGE, definition.ColorMessage);
	        }
	        if (definition.Preload) {
	            element.setAttribute(chatAttributes_1.default.PRELOAD, definition.Preload);
	        }
	        if (definition.EntryAnim !== undefined) {
	            element.setAttribute(chatAttributes_1.default.ENTRY_ANIM, definition.EntryAnim.toString());
	        }
	        if (definition.GuestOnly !== undefined) {
	            element.setAttribute(chatAttributes_1.default.GuestOnly, definition.GuestOnly.toString());
	        }
	    };
	    /**
	    * Process the given element data- attributes searching for
	    * the values customizing the behavior of the Skype Chat.
	     *
	     * @param {HTMLElement} element
	     * @returns {ChatDefinition}
	     *
	     * @memberOf ChatConfigFactory
	     */
	    ChatConfigFactory.prototype.getDefinitionFromDOM = function (element) {
	        var definition = new chatDefinition_1.ChatDefinition();
	        this.parseBaseDom(definition, element);
	        definition.Title = element.getAttribute(chatAttributes_1.default.TITLE);
	        definition.Avatar = element.getAttribute(chatAttributes_1.default.AVATAR);
	        // definition.CanClose =  this.getValue(element, chatAttributes.CAN_CLOSE, true);
	        definition.Partner = element.getAttribute(chatAttributes_1.default.PARTNER);
	        definition.Preload = element.getAttribute(chatAttributes_1.default.PRELOAD);
	        definition.CanCollapse = this.getValue(element, chatAttributes_1.default.CAN_COLLAPSE, false);
	        definition.CanUploadFile = this.getValue(element, chatAttributes_1.default.CAN_UPLOAD_FILE, true);
	        definition.ShowHeader = this.getValue(element, chatAttributes_1.default.SHOW_HEADER, true);
	        definition.EnableTranslator = this.getValue(element, chatAttributes_1.default.ENABLE_TRANSLATOR, false);
	        definition.ColorMain = this.getStringValue(element, chatAttributes_1.default.COLOR, null);
	        definition.CssUrl = this.getStringValue(element, chatAttributes_1.default.CSS_URL, null);
	        definition.ColorMessage = this.getStringValue(element, chatAttributes_1.default.COLOR_MESSAGE, null);
	        definition.EntryAnim = this.getValue(element, chatAttributes_1.default.ENTRY_ANIM, true);
	        definition.GuestOnly = this.getValue(element, chatAttributes_1.default.GuestOnly, false);
	        return definition;
	    };
	    ChatConfigFactory.prototype.getStringValue = function (element, attribute, defaultValue) {
	        var value = element.getAttribute(attribute);
	        return (value === null) ? defaultValue : value;
	    };
	    ChatConfigFactory.prototype.getValue = function (element, attribute, defaultValue) {
	        var value = element.getAttribute(attribute);
	        if (value === null) {
	            return defaultValue;
	        }
	        else {
	            return stringUtils_1.default.toBoolean(value);
	        }
	    };
	    /**
	     * Packs the chat control customization data into a set of url params
	     *
	     * @param {ChatDefinition} definition
	     * @returns {string}
	     *
	     * @memberOf ChatConfigFactory
	     */
	    ChatConfigFactory.prototype.toUrlParams = function (definition) {
	        var query = this.getBaseParams(definition);
	        var separator = query ? '&' : '';
	        if (definition.Title) {
	            query += separator + chatAttributes_1.default.TITLE + '=' + definition.Title;
	            separator = '&';
	        }
	        if (definition.Avatar) {
	            query += separator + chatAttributes_1.default.AVATAR + '=' + definition.Avatar;
	            separator = '&';
	        }
	        // if (definition.CanClose) {
	        //     query += separator + chatAttributes.CAN_CLOSE  + '=' + definition.CanClose;
	        //     separator = '&';
	        // }
	        if (definition.CanUploadFile) {
	            query += separator + chatAttributes_1.default.CAN_UPLOAD_FILE + '=' + definition.CanUploadFile;
	            separator = '&';
	        }
	        if (definition.CanCollapse) {
	            query += separator + chatAttributes_1.default.CAN_COLLAPSE + '=' + definition.CanCollapse;
	            separator = '&';
	        }
	        if (definition.ShowHeader) {
	            query += separator + chatAttributes_1.default.SHOW_HEADER + '=' + definition.ShowHeader;
	            separator = '&';
	        }
	        if (definition.ColorMain) {
	            query += separator + chatAttributes_1.default.COLOR + '=' + definition.ColorMain;
	            separator = '&';
	        }
	        if (definition.CssUrl) {
	            query += separator + chatAttributes_1.default.CSS_URL + '=' + definition.CssUrl;
	            separator = '&';
	        }
	        if (definition.ColorMessage) {
	            query += separator + chatAttributes_1.default.COLOR_MESSAGE + '=' + definition.ColorMessage;
	            separator = '&';
	        }
	        if (definition.Preload) {
	            query += separator + chatAttributes_1.default.PRELOAD + '=' + definition.Preload;
	            separator = '&';
	        }
	        if (definition.EntryAnim) {
	            query += separator + chatAttributes_1.default.ENTRY_ANIM + '=' + definition.EntryAnim;
	            separator = '&';
	        }
	        if (definition.GuestOnly) {
	            query += separator + chatAttributes_1.default.GuestOnly + '=' + definition.GuestOnly;
	            separator = '&';
	        }
	        return query;
	    };
	    return ChatConfigFactory;
	}(configFactory_1.ConfigFactory));
	exports.ChatConfigFactory = ChatConfigFactory;


/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";
	(function (MessagingBackend) {
	    /**
	     * Using of this enum points to application error.
	     */
	    MessagingBackend[MessagingBackend["UNDEFINED"] = 0] = "UNDEFINED";
	    /**
	     * The backend service is not determined at this time yet.
	     */
	    MessagingBackend[MessagingBackend["UNDETERMINED"] = 10] = "UNDETERMINED";
	    /**
	     * Skype backend service is used (Chat Service).
	     */
	    MessagingBackend[MessagingBackend["SKYPE"] = 100] = "SKYPE";
	    /**
	     * BotFramework DirectLine endpoints are used.
	     */
	    MessagingBackend[MessagingBackend["DIRECT_LINE"] = 200] = "DIRECT_LINE";
	})(exports.MessagingBackend || (exports.MessagingBackend = {}));
	var MessagingBackend = exports.MessagingBackend;


/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";
	var PackageName = (function () {
	    function PackageName() {
	    }
	    PackageName.VENDORS_ARIA = 'https://latest-swc.cdn.skype.com/vendors/aria-web-telemetry-2.7.2.min.js';
	    PackageName.VENDORS_ES6_PROMISE = 'https://latest-swc.cdn.skype.com/vendors/es6-promise.min.js';
	    PackageName.DOM_PURIFY = 'https://latest-swc.cdn.skype.com/vendors/purify.min.js';
	    PackageName.BUTTON_CORE = 'lwc-button-core';
	    PackageName.CHAT_CORE = 'lwc-chat-core';
	    PackageName.SKYPE_LOGIN = 'lwc-login-skype';
	    PackageName.SKYPE_CHAT = 'lwc-chat-skype';
	    // public static DIRECTLINE_CHAT = 'lwc-chat-dl';
	    PackageName.DIRECTLINE_CHAT = 'directline-bundle';
	    PackageName.SDK_LOADER_CHAT = 'sdk-loader';
	    PackageName.SDK_CORE = 'sdk-core';
	    PackageName.ASSETS = 'assets-bundle';
	    PackageName.BUILDER = 'builder-bundle';
	    PackageName.BUILDER_CORE = 'builder-core';
	    // public static SDK_EXTERNAL_CHAT = 'lwc-sdk-ext';
	    // public static SDK_INTERNAL_CHAT = 'lwc-sdk-int';
	    PackageName.INDEX_BUILDER = 'index-builder';
	    PackageName.INDEX_CHAT = 'lwc-chat-index';
	    PackageName.CONNECT = 'connect';
	    PackageName.HOST_CHAT_PAGE = 'host-chat';
	    PackageName.HOST_BING_PAGE = 'host-button';
	    PackageName.HOST_BUILDER_PAGE = 'host-builder';
	    PackageName.STYLE_BUILDER = 'lwc-builder';
	    PackageName.STYLE_SDK = 'lwc-sdk';
	    PackageName.STYLE_CHAT_SKYPE = 'lwc-chat-skype';
	    PackageName.STYLE_CHAT_BING = 'lwc-chat-bing';
	    PackageName.STYLE_CHAT_THEME_DARK = 'lwc-chat-theme-dark';
	    return PackageName;
	}());
	exports.PackageName = PackageName;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var browser_1 = __webpack_require__(41);
	/**
	 * Set of utility function working with iframe
	 *
	 * @export
	 * @class frameUtils
	 */
	var FrameUtils = (function () {
	    function FrameUtils() {
	    }
	    /**
	     * Injects a iframe into the document with the given source
	     *
	     * @static
	     * @param {string} frameId  Unique identifier of the iframe
	     * @param {string} source   Url of the html page which iframe will load
	     * @param {string} width    Width of the iframe (optional)
	     * @param {string} height   Height of the iframe (optional)
	     * @returns {HTMLIFrameElement}
	     *
	     * @memberOf frameUtils
	     */
	    FrameUtils.inject = function (source, parent) {
	        var document = browser_1.default.getDocument();
	        var iframe = document.createElement('iframe');
	        iframe.src = encodeURI(source);
	        iframe.setAttribute('frameborder', '0');
	        iframe.setAttribute('seamless', 'seamless');
	        iframe.setAttribute('border-radius', '6px');
	        iframe.setAttribute('allowFullScreen', 'true');
	        if (parent) {
	            parent.appendChild(iframe);
	        }
	        else {
	            document.body.appendChild(iframe);
	        }
	        return iframe;
	    };
	    FrameUtils.injectFrameless = function (skypeChatPlaceholder) {
	        var conversation = document.createElement('div');
	        var dlConversation = document.createElement('div');
	        var chatContainer = document.createElement('div');
	        chatContainer.id = 'main';
	        chatContainer.classList.add('swc', 'frameless');
	        chatContainer.style.display = 'none';
	        conversation.className = 'conversation skype-conversation';
	        conversation.setAttribute('data-bind', 'component: {name: "conversation", params: {conversation: conversation, enable: enable, topic: topic}}');
	        conversation.style.display = 'none';
	        chatContainer.appendChild(conversation);
	        dlConversation.className = 'conversation directline-conversation';
	        dlConversation.setAttribute('data-bind', 'component: {name: "dl-conversation", params: {conversation: conversation, enable: enable, topic: topic}}');
	        dlConversation.style.display = 'none';
	        chatContainer.appendChild(dlConversation);
	        skypeChatPlaceholder.appendChild(chatContainer);
	        return chatContainer;
	    };
	    return FrameUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FrameUtils;


/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	var Browser = (function () {
	    function Browser() {
	    }
	    Browser.getWindow = function () {
	        return window;
	    };
	    Browser.getDocument = function () {
	        return window.document;
	    };
	    return Browser;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Browser;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorHandler_1 = __webpack_require__(15);
	var packageName_1 = __webpack_require__(39);
	var UrlHelper = (function () {
	    function UrlHelper() {
	    }
	    /**
	     * Combines the two fragments making sure that '/' is added when needed in between.
	     *
	     * @static
	     * @param {string} path
	     * @param {string} query
	     * @returns
	     *
	     * @memberOf UrlHelper
	     */
	    UrlHelper.combine = function (path, query) {
	        if (path.lastIndexOf('/') !== path.length - 1) {
	            if (query.substring(0, 1) !== '/') {
	                return path + '/' + query;
	            }
	        }
	        return SkypeWebControl.EcsConfig.appUri + path + query;
	    };
	    /**
	     * Gets the absolute path by combining the given relative path and the ecs define
	     * appropriate root folder.
	     *
	     * @static
	     * @param {string} relativePath
	     * @param {string} ext
	     * @returns
	     *
	     * @memberOf UrlHelper
	     */
	    UrlHelper.getAbsoluteUrl = function (relativePath, ext) {
	        var completePath = this.getCompletePath(relativePath, ext);
	        switch (relativePath) {
	            case packageName_1.PackageName.ASSETS:
	            case packageName_1.PackageName.SDK_CORE:
	            case packageName_1.PackageName.BUILDER_CORE:
	            case packageName_1.PackageName.DIRECTLINE_CHAT:
	            case packageName_1.PackageName.INDEX_CHAT:
	            case packageName_1.PackageName.BUILDER:
	            case 'chat-bundle':
	                return this.combine('', completePath);
	            case packageName_1.PackageName.SDK_LOADER_CHAT:
	                return this.combine(SkypeWebControl.EcsConfig.loaderUrl, completePath);
	            case packageName_1.PackageName.STYLE_BUILDER:
	            case packageName_1.PackageName.STYLE_SDK:
	            case packageName_1.PackageName.STYLE_CHAT_SKYPE:
	            case packageName_1.PackageName.STYLE_CHAT_BING:
	            case packageName_1.PackageName.STYLE_CHAT_THEME_DARK:
	                return this.combine(SkypeWebControl.EcsConfig.cssHostUrl, completePath);
	            case packageName_1.PackageName.CONNECT:
	                return SkypeWebControl.EcsConfig.connectPageUrl;
	            default:
	                errorHandler_1.default.throwError(10051, 'Not supported, yet!' + relativePath);
	                return '';
	        }
	    };
	    UrlHelper.getCompletePath = function (relativePath, ext) {
	        var suffix = '';
	        var prefix = '';
	        switch (SkypeWebControl.EcsConfig.environment) {
	            case 'dev':
	                break;
	            case '':
	            case 'int':
	            case 'qa':
	                break;
	            case 'df':
	            case 'prod':
	                suffix = '.min';
	                break;
	        }
	        return prefix + relativePath + suffix + '.' + ext;
	    };
	    return UrlHelper;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = UrlHelper;


/***/ },
/* 43 */
/***/ function(module, exports) {

	"use strict";
	var SVG = (function () {
	    function SVG() {
	    }
	    SVG.IconHexagon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" class="hexagon"><path fill-rule="evenodd" d="M0 0h30v30H0V0zm28.83 13.14c.55.95.55 2.5 0 3.45l-5.46 9.45c-.55.96-1.9 1.73-3 1.73H9.46c-1.1 0-2.44-.77-3-1.73L1 16.6c-.55-.96-.55-2.5 0-3.46l5.46-9.46c.55-.96 1.9-1.73 3-1.73h10.92c1.1 0 2.44.77 3 1.73l5.45 9.46z"/></svg>';
	    SVG.SkypeLogo = '<svg xmlns="http://www.w3.org/2000/svg" height="100%" viewbox="0 0 100 44.17"><defs><clipPath id="a"><path d="M0 0h595.28v841.9H0V0z"/></clipPath></defs><g clip-path="url(#a)" transform="matrix(1.25 0 0 -1.25 -505.57 975.1)"><path fill="#A9A9A9" d="M467.1 764.5h7.33c-.23 1.9-1.66 3.3-3.52 3.3-2.1 0-3.35-1.28-3.8-3.3m-11.24-6.24c2.66.03 3.32 2.7 3.32 4.65 0 2.48-1.1 4.54-3.32 4.57-2.44.03-3.36-2.18-3.36-4.56 0-2.14.8-4.64 3.36-4.64M484.38 769c0 2.43-1.96 4.4-4.4 4.4-1.25 0-2.37-.54-3.17-1.38-1.85 1.3-4.1 2.05-6.53 2.05-2.46 0-4.73-.77-6.6-2.1-.84.8-1.96 1.26-3.2 1.26-.9 0-1.77-.26-2.5-.72-1.7 3.08-4.98 5.14-8.73 5.14-3.44 0-6.47-1.72-8.28-4.34-1.5 1.55-3.63 2.52-5.97 2.52-1.56 0-3-.43-4.24-1.17-.03 2.96-2.43 5.35-5.4 5.35-2.98 0-5.4-2.42-5.4-5.4l.02-.2c-.58.08-1.17.13-1.77.13-1.75 0-3.4-.4-4.9-1.08-.84.45-1.8.7-2.82.7-3.27 0-5.94-2.65-5.94-5.93 0-1.74.75-3.3 1.94-4.4-.03-.34-.05-.7-.05-1.07 0-6.5 5.28-11.77 11.78-11.77 2.54 0 4.88.8 6.8 2.15 1.72-2.36 4.5-3.9 7.66-3.9h.22c.9-2.57 3.35-4.4 6.24-4.4 2.9 0 5.4 1.88 6.26 4.5 1-1.9 3-3.18 5.28-3.18 2.87 0 5.26 2.02 5.84 4.7.4-.04.83-.08 1.26-.08 2.33 0 4.45.9 6.07 2.33 1.83-1.25 4.05-1.98 6.44-1.98 6.34 0 11.47 5.14 11.47 11.48 0 .78-.07 1.55-.23 2.3 1.68.6 2.88 2.2 2.88 4.1m-6-5.12c0-1.43-.42-1.8-1.83-1.8h-9.45c0-2.2 1.43-3.82 3.86-3.82 3.16 0 3.16 2.07 4.85 2.07 1 0 1.73-.86 1.73-1.64 0-2.53-4.05-3.7-6.57-3.7-4.76 0-7.1 2.62-7.8 5.56-.64-3.08-2.66-5.56-6.25-5.56-1.9 0-3.33.77-4.1 2.12h-.07v-5.6c0-1.36-.83-2.08-2.1-2.08-1.25 0-2.08.72-2.08 2.1v15.58l-4.7-13.33c-1-2.87-2.16-4.36-4.8-4.36-1.86 0-2.63.9-2.63 1.92 0 1.12.8 1.7 1.92 1.7h.43c.54 0 1.15.02 1.46 1.3l-4.35 12.42-.36 1.07c-.1-.13-.2-.25-.34-.38l-3.1-3.24 4.37-5.85c.14-.2.43-.66.43-1.35 0-1.06-.86-2.03-1.98-2.03-1.03 0-1.58.52-1.9.97l-3.95 5.6-1.46-1.3v-3.18c0-1.38-.84-2.1-2.1-2.1-1.27 0-2.1.72-2.1 2.1v1.53c-.75-2.47-3.54-3.63-6.24-3.63-3.78 0-6.94 1.7-6.94 3.76 0 .9.52 1.74 1.7 1.74 1.8 0 1.97-2.58 5.07-2.58 1.47 0 2.42.66 2.42 1.52 0 1.06-.92 1.23-2.4 1.6l-2.47.6c-2.43.6-4.33 1.62-4.33 4.43 0 3.4 3.4 4.67 6.28 4.67 3.18 0 6.4-1.27 6.4-3.2 0-.96-.67-1.82-1.76-1.82-1.63 0-1.7 1.92-4.33 1.92-1.45 0-2.4-.4-2.4-1.3 0-.96.95-1.2 2.24-1.48l1.75-.4c2-.46 4.33-1.25 5-3.24v13.07c0 1.36.83 2.08 2.1 2.08 1.26 0 2.1-.72 2.1-2.1v-9.5l4.63 5.15c.43.46.98.8 1.6.8.7 0 1.4-.43 1.77-1.07.33.65 1 1.08 1.8 1.08 1.1 0 1.9-.64 2.14-1.58l2.7-9.78h.06l2.55 9.5c.3 1.05.86 1.86 2 1.86 1 0 1.57-.5 1.87-1 .25.65.8 1 1.72 1 1.23 0 1.9-.7 1.9-1.98v-.66h.05c.68 1.78 2.37 2.64 4.4 2.64 3 0 5.65-1.88 6.37-5.8.8 3.55 3.54 5.8 7.65 5.8 4.82 0 7.57-3.4 7.57-6.86m1.3 6.56h.8l.63-1.82.6 1.82h.8v-2.64H482s-.02 0-.02 1.87l-.65-1.87h-.45l-.65 1.85v-1.85h-.54v2.64zm-2.47-.5v.5h2.15v-.5h-.78v-2.14h-.6v2.15h-.77z"/></g></svg>';
	    SVG.IconSent = '<svg class="icon-sen" width="50px" viewBox="0 0 50 50"><use xlink:href="#C2_0_151" transform="matrix(0.032 , 0, 0 , -0.032, 0, 50)" stroke="none"/><defs><path d="M116.1,131.4c0,0,-19.8,0,-36.7,7.6c0,0,-18.3,7.7,-30.5,19.9c0,0,-13.8,13.7,-21.4,30.5c0,0,-7.6,18.4,-7.6,36.7c0,0,0,12.2,3,22.9l107,466l967,0l0,96.3l-967,0l-107,465.9c0,0,-3,10.7,-3,22.9c0,0,0,18.4,6.1,35.2c0,0,7.6,18.3,21.4,30.5c0,0,13.7,13.8,30.5,21.4c0,0,16.8,7.7,36.7,7.7c0,0,19.8,0,41.2,-9.2L1449.9,851c0,0,25.9,-10.7,41.2,-35.2c0,0,15.3,-24.4,15.3,-53.4c0,0,0,-26,-13.8,-50.5c0,0,-15.2,-24.4,-41.2,-35.1L154.3,139c0,0,-19.9,-7.6,-38.2,-7.6Z" id="C2_0_151"/></defs></svg>';
	    SVG.IconClose = '<svg xmlns="http://www.w3.org/2000/svg" style="width:100%;" viewBox="0 0 20 20" width="32"><path fill-rule="evenodd" d="M10 20c5.5 0 10-4.5 10-10S15.5 0 10 0 0 4.5 0 10s4.5 10 10 10zm2-10l2.6-2.6c.5-.6.5-1.4 0-2-.6-.5-1.4-.5-2 0L10 8 7.4 5.4c-.6-.5-1.4-.5-2 0-.5.6-.5 1.4 0 2L8 10l-2.6 2.6c-.5.6-.5 1.4 0 2 .6.5 1.4.5 2 0L10 12l2.6 2.6c.6.5 1.4.5 2 0 .5-.6.5-1.4 0-2L12 10z"/></svg>';
	    SVG.iconArrow = '<svg xmlns="http://www.w3.org/2000/svg" width="16px" viewBox="0 0 19 30" class="arrow"><path fill-rule="evenodd" d="M18.9 15c0-.54-.08-1.05-.27-1.53-.2-.47-.48-.9-.86-1.24L6.67 1.13C5.93.4 5 0 3.92 0c-1.07 0-2 .38-2.76 1.14C.38 1.9 0 2.84 0 3.9 0 5 .38 5.93 1.14 6.7L9.46 15l-8.32 8.32C.38 24.08 0 25 0 26.1c0 1.07.38 2 1.14 2.76.76.76 1.7 1.14 2.77 1.14 1.1 0 2.02-.38 2.78-1.14l11.1-11.13c.37-.35.66-.77.85-1.24.2-.5.28-.98.28-1.5z"/></svg>';
	    SVG.iconFileUpload = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 84 100" class="icon-file"><path fill-rule="evenodd" d="M84 18c0 2.6-.4 5-1.4 7.2-1 2.2-2.2 4.2-3.8 6L40 71.6c-.2.3-.5.5-1 .7l-1.2.2c-1 0-1.7-.3-2.3-1-.7-.6-1-1.4-1-2.3 0-1 .3-1.7 1-2.4L74 26.6c1-1 2-2.4 2.5-4 .6-1.4 1-3 1-4.5s-.4-3-1-4c-.7-1.3-1.5-3-2.5-4s-2.4-1.4-3.8-2c-1.4-.5-3-1-4.5-1s-3 .5-4.4 1c-1.3 0-2.7 1-3.7 2L13 56.7c-2 2-3.6 4.4-4.7 7-1 2.8-1.7 5.5-1.7 8.4 0 2.8.6 5.6 1.7 8.2 1.2 2.6 2.7 5 4.7 6.8 2 2 4.2 3.5 6.8 4.6 2.6 1.2 5.4 1.7 8.3 1.7 3 0 6-.5 9-1.6 2.7-1 5-2.7 7-4.7l32-31.4c.3-.3.6-.6 1-.7.5-1 1-1 1.3-1 1 0 1.7.3 2.3 1 .7.6 1 1.4 1 2.3 0 1-.3 1.6-1 2.2L48 91.5c-2.6 2.8-5.6 4.8-9 6-3.6 1.7-7.2 2-11 2-3.7 0-7.4-.3-10.8-2-3.4-1.3-6.3-3.3-9-6-2.4-2.4-4.5-5.4-6-9S0 76 0 72s.7-7.4 2-11c1.6-3.4 3.6-6.5 6.2-9.2L53 5.4c1.6-1.8 3.6-3 5.8-4 2.3-1 4.6-1.4 7-1.4 2.5 0 4.8.5 7 1.4 2.2 1 4.2 2.3 5.8 4 1.7 1.6 3 3.5 4 5.7 1 3 1.4 5 1.4 7z"/></svg>';
	    SVG.iconDownload = '<svg class="icon-download" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 736 960"><path fill-rule="evenodd" d="M736 592c0 26.67-9.33 49.33-28 68L440 927c-10.67 10.67-21.67 18.83-33 24.5-11.33 5.67-24.67 8.5-40 8.5-15.33 0-28.5-3-39.5-9s-21.83-14-32.5-24L28 660c-9.33-8.67-16.33-18.83-21-30.5-4.67-11.67-7-24.17-7-37.5 0-12.67 2.5-24.83 7.5-36.5 5-11.67 11.83-22 20.5-31s18.83-16 30.5-21c11.67-5 24.17-7.5 37.5-7.5 26 0 48.67 9.67 68 29l108 107V96c0-26.67 9.33-49.33 28-68s41.33-28 68-28c12.67 0 24.83 2.5 36.5 7.5 11.67 5 22 11.83 31 20.5s16 18.83 21 30.5c5 11.67 7.5 24.17 7.5 37.5v537l108-109c18.67-18.67 41.33-28 68-28s49.33 9.33 68 28 28 41.33 28 68z"/></svg>';
	    SVG.iconError = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 110 110"><path fill-rule="evenodd" d="M107 89.25c0 1.6-.32 3.1-.95 4.53-.63 1.43-1.5 2.67-2.57 3.73-1.08 1.1-2.33 2-3.73 2.6-1.4.7-2.9 1-4.5 1h-83.5c-1.6 0-3.1-.3-4.5-.9-1.4-.6-2.65-1.5-3.73-2.5S1.58 95.4.95 94C.32 92.5 0 90.98 0 89.4c0-2 .47-3.84 1.4-5.6L43.16 6.2c1.02-1.88 2.46-3.38 4.34-4.5C49.38.55 51.38 0 53.5 0s4.12.56 6 1.68c1.88 1.13 3.32 2.63 4.34 4.5l41.75 77.5c.9 1.75 1.4 3.6 1.4 5.57zm-7.84 0c0-.12-.36-.92-1.1-2.4L95.1 81c-1.25-2.44-2.7-5.3-4.38-8.53-1.68-3.25-3.47-6.7-5.4-10.35-1.9-3.65-3.9-7.42-5.93-11.3l-6.1-11.4-5.7-10.66c-1.8-3.37-3.5-6.38-5-9.03-1.5-2.64-2.7-4.83-3.7-6.54-1-1.7-1.7-2.8-2.1-3.3-.5-.6-1-1.1-1.5-1.5-.6-.4-1.2-.6-2-.6-.7 0-1.4.2-2 .5-.7.4-1.1.9-1.5 1.5-.5.9-1.3 2.4-2.4 4.3-1.1 1.92-2.4 4.3-3.9 7.1l-5.05 9.1-5.5 10.6C31 44.5 29 48.17 27 51.9l-5.8 10.8c-1.84 3.5-3.6 6.8-5.2 9.9l-4.3 8.2c-1.2 2.4-2.17 4.3-2.86 5.8-.7 1.5-1.04 2.4-1.04 2.7 0 1.1.4 2 1.18 2.8.7.8 1.7 1.2 2.7 1.2h83.5c1 0 2-.4 2.7-1.18.7-.77 1.1-1.7 1.1-2.75zm-41.74-19.6h-7.84V30.5h7.84v39.18zm1.96 11.76c0 .8-.17 1.6-.5 2.3-.32.7-.75 1.4-1.28 1.9-.53.6-1.15 1-1.87 1.3-.7.4-1.45.5-2.23.5s-1.52-.1-2.23-.5c-.72-.3-1.34-.7-1.87-1.3s-.96-1.1-1.3-1.8c-.3-.7-.48-1.4-.48-2.2 0-.7.17-1.5.5-2.2.32-.7.75-1.3 1.28-1.8s1.15-.9 1.87-1.22c.7-.34 1.45-.5 2.23-.5s1.52.16 2.23.5c.72.3 1.34.74 1.87 1.27.53.56.96 1.18 1.3 1.9.3.7.48 1.46.48 2.2z"/></svg>';
	    SVG.iconMute = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon-media"><g fill-rule="evenodd"><path stroke-width="2" stroke="none" d="M6.67 13c.86 1.8 2.48 3 4.33 3V4C9.15 4 7.53 5.2 6.67 7H5c-1.65 0-3 1.34-3 3 0 1.65 1.34 3 3 3h1.67z"/><g><path d="M13.55 12.2c.7-.6 1.15-1.42 1.15-2.34 0-.92-.44-1.75-1.15-2.32m1.75 6.66c1.3-1.06 2.13-2.6 2.13-4.3 0-1.72-.83-3.26-2.14-4.32"/><path d="M17.3 16.32c1.97-1.6 3.2-3.88 3.2-6.43 0-2.57-1.23-4.87-3.2-6.45"/></g><path d="M20.5.5l-19 19"/></g></svg>';
	    SVG.iconUnmute = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon-media"><g fill-rule="evenodd"><path stroke-width="2" stroke="none" d="M6.67 13c.86 1.8 2.48 3 4.33 3V4C9.15 4 7.53 5.2 6.67 7H5c-1.65 0-3 1.34-3 3 0 1.65 1.34 3 3 3h1.67z"/><g><path d="M13.55 12.2c.7-.6 1.15-1.42 1.15-2.34 0-.92-.44-1.75-1.15-2.32m1.75 6.66c1.3-1.06 2.13-2.6 2.13-4.3 0-1.72-.83-3.26-2.14-4.32"/><path d="M17.3 16.32c1.97-1.6 3.2-3.88 3.2-6.43 0-2.57-1.23-4.87-3.2-6.45"/></g><path stroke="#CAE2EB" stroke-width="2" d="M16 3L1 18"/><path d="M20.5.5l-19 19"/></g></svg>';
	    SVG.iconExitFullscreen = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="icon-media"><path fill-rule="evenodd" d="M0 12c0-.18.07-.34.2-.47.13-.13.3-.2.47-.2H8c.18 0 .34.07.47.2.13.13.2.3.2.47v7.33c0 .18-.07.34-.2.47-.13.13-.3.2-.47.2-.18 0-.34-.07-.47-.2-.13-.13-.2-.3-.2-.47V13.6L1.8 19.15c-.13.13-.3.2-.47.2-.18 0-.33-.07-.47-.2-.13-.14-.2-.3-.2-.47 0-.18.07-.34.2-.47l5.54-5.5H.65c-.18 0-.34-.07-.47-.2-.14-.13-.2-.3-.2-.47zM10.67.67c0-.18.06-.34.2-.47.13-.13.28-.2.46-.2s.34.07.47.2c.13.13.2.3.2.47V6.4L17.53.85c.13-.13.3-.2.47-.2.18 0 .34.07.47.2.13.14.2.3.2.47 0 .18-.07.34-.2.47l-5.52 5.5h6.38c.18 0 .34.07.47.2.13.13.2.3.2.47 0 .17-.07.33-.2.46s-.3.2-.47.2h-8c-.18 0-.33-.07-.47-.2-.13-.13-.2-.3-.2-.47V.66z"/></svg>';
	    SVG.iconEnterFullscreen = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" class="icon-media"><path fill-rule="evenodd" d="M0 11.43c0-.2.07-.36.2-.5.15-.15.32-.22.5-.22.2 0 .38.1.52.26.14.14.2.3.2.5v6.13l5.93-5.93c.15-.14.3-.2.5-.2s.37.06.5.2c.15.14.22.3.22.5s-.07.36-.2.5L2.44 18.6H9.3c.18 0 .35.06.5.2.13.14.2.3.2.5s-.07.36-.2.5c-.15.14-.32.2-.5.2H.7c-.18 0-.35-.06-.5-.2-.13-.14-.2-.3-.2-.5v-7.86zM10.7.7c0-.18.08-.35.23-.5.14-.13.3-.2.5-.2h7.86c.15 0 .32.07.5.2.1.15.2.32.2.5v7.87c0 .2-.1.36-.2.5-.18.15-.35.22-.5.22-.2 0-.4-.1-.55-.26-.14-.14-.2-.3-.2-.5v-6.1l-5.93 5.9c-.15.15-.3.2-.5.2s-.37-.05-.5-.2c-.15-.13-.22-.3-.22-.5s.08-.35.2-.5l5.94-5.92H11.4c-.2 0-.35-.07-.5-.2-.14-.15-.2-.32-.2-.52z"/></svg>';
	    SVG.iconPlay = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon-media"><path fill-rule="evenodd" d="M1 17l14.97-8L1 1z" stroke-linejoin="round"/></svg>';
	    SVG.iconPause = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="icon-media"><g fill-rule="evenodd" stroke-width="2" stroke="none" transform="translate(1 1)"><rect width="5" height="14" rx="1"/><rect width="5" height="14" x="9" rx="1"/></g></svg>';
	    SVG.iconGroupAvatar = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="240px" height="240px" viewBox="0 0 240 240" enable-background="new 0 0 240 240" xml:space="preserve"><rect fill="none" width="240" height="240"/><g><path fill="#FFFFFF" d="M90.938,109.86c7.341,0,13.292-7.52,13.292-16.111s-5.951-15-13.292-15s-13.292,6.409-13.292,15   S83.597,109.86,90.938,109.86z"/><path fill="#FFFFFF" d="M131.25,117.958c10.125,0,18.334-10.384,18.334-22.247s-8.208-20.713-18.334-20.713   s-18.334,8.85-18.334,20.713S121.125,117.958,131.25,117.958z"/><path fill="#FFFFFF" d="M109.007,116.737c-1.729-0.848-3.622-1.322-5.609-1.322c-1.17,0-2.306,0.17-3.397,0.477L100,115.884   c-2.208,0.643-5.597,1.755-9.062,1.753c-3.466,0.001-6.854-1.111-9.062-1.753l-0.001,0.009c-1.091-0.307-2.227-0.477-3.397-0.477   c-8.133,0-14.726,7.835-14.726,17.5v2.405c0,1.893,1.521,3.428,3.398,3.428h18.827C89.45,127.406,98.247,118.815,109.007,116.737z"/><path fill="#FFFFFF" d="M157.244,127.981c-2.664-1.511-5.651-2.357-8.806-2.357c-1.575,0-3.102,0.225-4.571,0.624   c-0.038,0.01-0.076,0.017-0.114,0.028l-0.002-0.012c-2.244,0.647-5.374,1.638-8.777,2.116c-0.059,0.008-0.116,0.02-0.175,0.028   c-0.361,0.049-0.73,0.079-1.096,0.115c-0.221,0.022-0.439,0.053-0.662,0.069c-0.288,0.021-0.58,0.021-0.87,0.033   c-0.307,0.012-0.612,0.034-0.919,0.034h-0.001h-0.001c-0.31,0-0.617-0.022-0.926-0.034c-0.288-0.011-0.578-0.011-0.864-0.032   c-0.334-0.024-0.662-0.068-0.992-0.104c-0.254-0.028-0.512-0.046-0.763-0.08c-3.473-0.468-6.672-1.487-8.956-2.144l-0.002,0.012   c-1.505-0.419-3.071-0.652-4.685-0.652c-11.218,0-20.312,10.703-20.312,23.906v3.285c0,2.586,2.098,4.683,4.687,4.683h0.001h65.624   h0.001h0.001c2.589,0,4.687-2.097,4.687-4.683v-3.285C168.75,140.04,164.052,131.842,157.244,127.981z"/></g></svg>';
	    SVG.iconGlobus = '<svg width="12" height="12" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg"><path d="M12 6c0-.6 0-1-.2-1.6L11.2 3c-.3-.5-.6-1-1-1.2-.3-.4-.7-.7-1.2-1L7.6.2 6 0c-.6 0-1 0-1.6.2L3 .8c-.5.3-1 .6-1.2 1-.4.3-.7.7-1 1.2L.2 4.4 0 6c0 .6 0 1 .2 1.6L.8 9c.3.5.6 1 1 1.2.3.4.7.7 1.2 1l1.4.6L6 12c.6 0 1 0 1.6-.2l1.4-.6c.5-.3 1-.6 1.2-1 .4-.3.7-.7 1-1.2l.6-1.4L12 6zm-1.4 2.4l-.6 1-.8.6c-.2.3-.5.5-.8.6l-1 .4.5-1.3V8.4h2.3zm-3.2 0v.4l-.2.6-.3.6-.6.6c0 .2-.2.3-.3.4l-.3.2s-.4 0-.5-.2l-.3-.4V10c0-.2 0-.4-.3-.6v-.6l-.2-.4h2.8zM11.2 6c0 .5 0 1-.3 1.6H8V4.4h3V6zm-6.6 5c-.3 0-.6-.2-1-.4-.3 0-.6-.3-1-.6 0-.2-.4-.4-.6-.7l-.6-1h2.4c0 .6.2 1 .3 1.4L5 11zm3-5v1.6h-3l-.2-.8V4.4h3l.2.8V6zm3-2.4H8.2c0-.5-.2-1-.3-1.3L7 1c.3 0 .6.2 1 .4.3 0 .6.3.8.6l1 .7.5 1zm-7 4H1v-.8C.7 6.5.7 6.3.7 6v-.8c0-.3.2-.6.3-.8h2.7v3.2zm3.8-4H4.6v-.4l.2-.6L5 2l.3-.6c0-.2.2-.3.3-.4L6 .8s.3 0 .4.2l.3.4.3.6c0 .2 0 .4.2.6v.6l.2.4zM4.6 1L4 2.3v1.3H1.4l.6-1 .7-.6c.3-.3.6-.5 1-.6l1-.4z" fill="#949494"/></svg>';
	    SVG.iconCallStart = '<svg width="18" height="17" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon-action"><path class="cls-1" d="M8.05,6A7.16,7.16,0,0,0,6.91,7.5a7,7,0,0,0,0,6.91A7.05,7.05,0,0,0,9.54,17a7,7,0,0,0,6.91,0A7.16,7.16,0,0,0,18,15.9l1.41,1.42a8.82,8.82,0,0,1-1.92,1.46,9.11,9.11,0,0,1-2.16.88,9,9,0,0,1-4.56,0,9.11,9.11,0,0,1-2.16-.88A9,9,0,0,1,5.17,15.4a9.11,9.11,0,0,1-.88-2.16,9,9,0,0,1,0-4.56,9.11,9.11,0,0,1,.88-2.16A8.82,8.82,0,0,1,6.63,4.59Z"/></svg>';
	    SVG.iconOpenUrl = '<svg width="20" height="17" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon-action"><path class="cls-1" d="M8,17H4a2.92,2.92,0,0,1-1.17-.23,3,3,0,0,1-1.6-1.6A2.92,2.92,0,0,1,1,14v-4a2.92,2.92,0,0,1,.23-1.17,3,3,0,0,1,1.6-1.6A2.92,2.92,0,0,1,4,6.95H8a2.92,2.92,0,0,1,1.17.23,3,3,0,0,1,1.6,1.6A2.92,2.92,0,0,1,11,9.95H9A1,1,0,0,0,8,9H4a1,1,0,0,0-1,1v4a1,1,0,0,0,1,1H8a1,1,0,0,0,1-1h2a2.92,2.92,0,0,1-.23,1.17,3,3,0,0,1-1.6,1.6A2.92,2.92,0,0,1,8,17Zm-2-4H18V11H6Zm14,4H16a2.92,2.92,0,0,1-1.17-.23,3,3,0,0,1-1.6-1.6A2.92,2.92,0,0,1,13,14h2a1,1,0,0,0,1,1h4a1,1,0,0,0,1-1v-4a1,1,0,0,0-1-1H16a1,1,0,0,0-1,1H13a2.92,2.92,0,0,1,.23-1.17,3,3,0,0,1,1.6-1.6A2.92,2.92,0,0,1,16,6.95h4a2.92,2.92,0,0,1,1.17.23,3,3,0,0,1,1.6,1.6A2.92,2.92,0,0,1,23,9.95v4a2.92,2.92,0,0,1-.23,1.17,3,3,0,0,1-1.6,1.6A2.92,2.92,0,0,1,20,17Z"/></svg>';
	    SVG.iconSpeaker = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36 36" wdith="20" height="20" class="icon-media"><g transform="scale(0.03125 0.03125)"><path fill="rgb(0, 175, 240)" d="M719.53 831.53c-12.286 0-24.566-4.686-33.942-14.056-18.744-18.744-18.744-49.136 0-67.882 131.006-131.006 131.006-344.17 0-475.176-18.744-18.746-18.744-49.138 0-67.882 18.744-18.742 49.138-18.744 67.882 0 81.594 81.59 126.53 190.074 126.53 305.466 0 115.39-44.936 223.876-126.53 305.47-9.372 9.374-21.656 14.060-33.94 14.060v0zM549.020 741.020c-12.286 0-24.566-4.686-33.942-14.058-18.746-18.746-18.746-49.134 0-67.88 81.1-81.1 81.1-213.058 0-294.156-18.746-18.746-18.746-49.138 0-67.882s49.136-18.744 67.882 0c118.53 118.53 118.53 311.392 0 429.922-9.372 9.368-21.656 14.054-33.94 14.054z"></path><path fill="rgb(0, 175, 240)" d="M416.006 960c-8.328 0-16.512-3.25-22.634-9.374l-246.626-246.626h-114.746c-17.672 0-32-14.326-32-32v-320c0-17.672 14.328-32 32-32h114.746l246.626-246.628c9.154-9.154 22.916-11.89 34.874-6.936 11.958 4.952 19.754 16.622 19.754 29.564v832c0 12.944-7.796 24.612-19.754 29.564-3.958 1.64-8.118 2.436-12.24 2.436z"></path></g></svg>';
	    return SVG;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SVG;


/***/ },
/* 44 */
/***/ function(module, exports) {

	"use strict";
	var API = (function () {
	    function API() {
	    }
	    API.registry = {};
	    API.registerEvent = function (eventName, callback) {
	        if (!eventName || !callback) {
	            return;
	        }
	        var r = API.registry;
	        if (!r[eventName]) {
	            r[eventName] = [];
	        }
	        else {
	            if (r[eventName].indexOf(callback) !== -1) {
	                return;
	            }
	            ;
	        }
	        r[eventName].push(callback);
	    };
	    API.unregisterEvent = function (eventName, callback) {
	        if (!eventName || !callback) {
	            return;
	        }
	        var r = API.registry;
	        if (!r[eventName] || !r[eventName].length) {
	            return;
	        }
	        var i = r[eventName].indexOf(callback);
	        i !== -1 && r[eventName].splice(i, 1);
	    };
	    API.triggerEvent = function (eventName, payload) {
	        var ret = false;
	        var r = API.registry;
	        r[eventName] && r[eventName].forEach(function (fn) {
	            try {
	                fn(payload);
	                ret = true;
	            }
	            catch (e) {
	                console.log('api call failed:');
	                console.log(e);
	            }
	        });
	        return ret;
	    };
	    API.dispose = function () {
	        for (var key in API.registry) {
	            delete API.registry[key];
	        }
	    };
	    return API;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = API;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var escape = __webpack_require__(46);
	var api_1 = __webpack_require__(44);
	var actionNames_1 = __webpack_require__(35);
	var app_1 = __webpack_require__(26);
	var application_1 = __webpack_require__(47);
	var componentsRegistrar_1 = __webpack_require__(106);
	var conversationType_1 = __webpack_require__(14);
	var identityType_1 = __webpack_require__(29);
	var packageName_1 = __webpack_require__(39);
	var sdkMode_1 = __webpack_require__(30);
	var theme_1 = __webpack_require__(170);
	var preloadType_1 = __webpack_require__(21);
	var sessionEndEvent_1 = __webpack_require__(171);
	var serviceQosEvent_1 = __webpack_require__(55);
	var sessionStartEvent_1 = __webpack_require__(172);
	var visibilityChangedEvent_1 = __webpack_require__(173);
	var endpoint = __webpack_require__(86);
	var skypeComponentsRegistrar_1 = __webpack_require__(174);
	var directLineComponentsRegistrar_1 = __webpack_require__(188);
	var config_1 = __webpack_require__(27);
	var i18n_1 = __webpack_require__(112);
	var styleLoader_1 = __webpack_require__(193);
	var Conversation_1 = __webpack_require__(194);
	var signinState_1 = __webpack_require__(71);
	var identityParser_1 = __webpack_require__(13);
	var stringUtils_1 = __webpack_require__(16);
	var Chat = (function () {
	    function Chat(element) {
	        var _this = this;
	        this._conversationId = ko.observable();
	        this._chatSessionStartTime = Date.now();
	        this._theme = theme_1.Theme.DEFAULT;
	        this._chatInstances = {};
	        this._stylesReady = false;
	        this.enable = ko.observable();
	        this.isInitialized = false;
	        this._loadConversation = function (id, topic, avatar, sdkmode) {
	            _this._createConversationID(id, sdkmode);
	            _this._topic = topic;
	            _this._avatar = avatar;
	        };
	        this._runChat = function (lifeTime) {
	            var isDl = _this._chatDataConfig.ConversationType === conversationType_1.default.DIRECT_LINE;
	            if (!_this._baseTemplate) {
	                _this._baseTemplate = _this._baseParent.querySelector('.conversation.skype-conversation').cloneNode(true);
	                _this._baseDLTemplate = _this._baseParent.querySelector('.conversation.directline-conversation').cloneNode(true);
	            }
	            var newConversationNode;
	            var conversationExists = false;
	            var conversation;
	            for (var key in _this._chatInstances) {
	                if (key === _this._conversationId()) {
	                    var chat = _this._chatInstances[key];
	                    conversation = chat.model;
	                    conversationExists = true;
	                    chat.view.style.display = 'flex';
	                }
	                else {
	                    _this._chatInstances[key].view.style.display = 'none';
	                }
	            }
	            _this._lastConversationId = _this._conversationId();
	            if (!conversationExists) {
	                conversation = new Conversation_1.default(_this._conversationId(), _this._chatDataConfig);
	                conversation.topic = _this._topic === 'null' ? '' : _this._topic;
	                conversation.avatar = !!_this._avatar ? _this._avatar : conversation.avatar;
	                newConversationNode = isDl ? _this._baseDLTemplate.cloneNode(true) : _this._baseTemplate.cloneNode(true);
	                _this._baseParent.appendChild(newConversationNode);
	                _this._chatInstances[_this._conversationId()] = { view: newConversationNode, model: conversation };
	                ko.applyBindings({
	                    conversation: conversation,
	                    enable: _this.enable,
	                    topic: _this._topic
	                }, newConversationNode);
	                conversation.start();
	                _this.enable(true);
	                _this.sendSessionStartTelemetry(_this._conversationId(), lifeTime);
	                newConversationNode.style.display = 'flex';
	            }
	            else if (conversation.isDisposed) {
	                console.log('[chat] activating conversation after disposing');
	                conversation.start();
	            }
	            (_this._stylesReady || _this._isModule) && _this._openChatWindow();
	            if (isDl) {
	                endpoint.stopActivation();
	            }
	            else {
	                endpoint.startActivation();
	            }
	        };
	        this._forceExpandChat = function () {
	            api_1.default.triggerEvent('forceExpandChat');
	        };
	        this._openChatWindow = function () {
	            if (app_1.default.frameless) {
	                window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.ShowChatWindow }); /// consider reference to namespace
	            }
	            else if (parent) {
	                parent.postMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.ShowChatWindow }, '*');
	            }
	        };
	        this.sendSessionStartTelemetry = function (conversationId, lifeTime) {
	            if (!sessionStartEvent_1.SessionStartEvent.isAvailable) {
	                return;
	            }
	            if (conversationId.indexOf('99:') === 0) {
	                app_1.default.currentUserIdentityType = identityType_1.IdentityType.DL_TOKEN;
	                app_1.default.currentUserName = 'guest:directline';
	            }
	            var evtData = new sessionStartEvent_1.SessionStartEvent();
	            evtData.tts = lifeTime;
	            evtData.theme = _this._theme;
	            application_1.default.instance.TelemetryService.sendEvent(evtData);
	        };
	        this.setup = function (payload, lifeTime, switchConversation) {
	            window.onbeforeunload = function () {
	                var evtData = new sessionEndEvent_1.SessionEndEvent();
	                evtData.ttc = Date.now() - _this._chatSessionStartTime;
	                evtData.chatsCount = Object.keys(_this._chatInstances).length;
	                application_1.default.instance.TelemetryService.sendEvent(evtData);
	                serviceQosEvent_1.manager().flushAll();
	                _this.disposeConversations();
	                application_1.default.instance.SignInManager.state = signinState_1.SigninState.SignedOut;
	            };
	            _this._initPromises = [new Promise(function (resolve) {
	                    _this._i18nInitDone = resolve;
	                })];
	            i18n_1.default.init(payload.lang).then(_this._i18nInitDone, _this._i18nInitDone);
	            if (!_this._isModule) {
	                var mainStylesheet = _this._chatDataConfig.Partner === "bing" ? packageName_1.PackageName.STYLE_CHAT_BING : packageName_1.PackageName.STYLE_CHAT_SKYPE;
	                !_this._stylesReady && styleLoader_1.default.addStyle(mainStylesheet, true, function () {
	                    _this._openChatWindow();
	                    _this._stylesReady = true;
	                    if (_this._baseParent) {
	                        _this._baseParent.style.display = '';
	                    }
	                });
	                if (payload.data.chatConfig.Theme && payload.data.chatConfig.Theme === theme_1.Theme.DARK) {
	                    styleLoader_1.default.addStyle(packageName_1.PackageName.STYLE_CHAT_THEME_DARK, true);
	                    _this._baseParent.classList.add(payload.data.chatConfig.Theme);
	                    _this._theme = payload.data.chatConfig.Theme;
	                }
	                if (payload.data.chatConfig.CssUrl) {
	                    styleLoader_1.default.addStyle(payload.data.chatConfig.CssUrl);
	                }
	            }
	            componentsRegistrar_1.default.register(_this._chatDataConfig);
	            directLineComponentsRegistrar_1.default.register(payload.data.chatConfig);
	            skypeComponentsRegistrar_1.default.register(_this._chatDataConfig);
	            if (payload.data.switchConversation || _this.isInitialized) {
	                app_1.default.activeConversationSdkMode = payload.sdkmode;
	                _this._loadConversation(escape(payload.id), escape(payload.data.chatConfig.Title), escape(payload.data.chatConfig.Avatar), payload.sdkmode);
	                _this.enable() && _this._runChat(lifeTime);
	            }
	            else {
	                Promise.all(_this._initPromises).then(function () {
	                    app_1.default.activeConversationSdkMode = payload.sdkmode;
	                    _this._loadConversation(escape(payload.id), escape(payload.data.chatConfig.Title), escape(payload.data.chatConfig.Avatar), payload.sdkmode);
	                    _this.enable() && _this._runChat(lifeTime);
	                });
	            }
	        };
	        this._onMessageReceived = function (event) {
	            // NOTE: this is checking origin of host, but our own assigned value, to just filter out other messages
	            // so it accepts messages from any host -> do not use sensitive data and always do validation of data
	            if (event.data.origin !== config_1.default.ORIGIN ||
	                !/^bs:[so]Chat.*/.test(event.data.action)) {
	                return;
	            }
	            _this.runChat(event.data);
	        };
	        this.runChat = function (payload) {
	            if (payload.action === actionNames_1.default.StartActivation) {
	                _this.onClientFocused();
	                return;
	            }
	            if (payload.action === actionNames_1.default.StopActivation) {
	                _this.onClientBlurred();
	                return;
	            }
	            if (payload.action === actionNames_1.default.ExpandChatWindow) {
	                _this._forceExpandChat();
	                return;
	            }
	            if (payload.data && payload.data.ecs) {
	                config_1.default.ECS = payload.data.ecs;
	            }
	            var isGuestOnlyMode = stringUtils_1.default.toBoolean(config_1.default.ECS.guestOnly) && payload.data && payload.data.chatConfig.GuestOnly;
	            app_1.default.isGuestOnlyMode = isGuestOnlyMode;
	            if (identityParser_1.default.isEmail(payload.id)) {
	                application_1.default.instance.SearchManager.searchSkypeContacts(payload.id).then(function (profiles) {
	                    var strongMatches = profiles.filter(function (item) {
	                        return item.match === 1 || item.match === 2;
	                    });
	                    if (strongMatches.length === 0) {
	                        console.log('No profile was found for ', payload.id);
	                        return;
	                    }
	                    var id = strongMatches[0].skypeid.replace('8:', '');
	                    payload.id = id;
	                    payload.data.chatConfig.ConversationId = id;
	                    _this.runChat(payload);
	                });
	                return;
	            }
	            if (!_this.isInitialized) {
	                _this._isModule = payload.isModule;
	            }
	            if (payload.action === actionNames_1.default.LoadChatData) {
	                !_this.enable() && _this._runChat(payload.lifeTime);
	                _this._baseParent.style.display = null;
	                return;
	            }
	            if (payload.action === actionNames_1.default.ShowChatWindow) {
	                _this._chatDataConfig = payload.data.chatConfig;
	                var hostName = window.location.hostname.replace('www.', '');
	                app_1.default.frameless = _this._isModule || (!_this.inIframe() && hostName && config_1.default.ECS.frameless.indexOf(hostName) > -1);
	                app_1.default.host = payload.host || 'n/a';
	                app_1.default.language = payload.data.lang;
	                app_1.default.translatorEnabled = _this._chatDataConfig.EnableTranslator;
	                _this._createConversationID(escape(payload.id), payload.sdkmode);
	                _this.enable(_this._chatDataConfig.Preload !== preloadType_1.PreloadType.UIONLY);
	                if (!_this.isInitialized) {
	                    _this.setup(payload, payload.lifeTime);
	                    _this.isInitialized = true;
	                    api_1.default.triggerEvent('ready', true);
	                }
	                else {
	                    _this.setup(payload, payload.lifeTime);
	                }
	            }
	            if (payload.action === actionNames_1.default.OpenChatWindow) {
	                // all was set up before. only changing visibility of the client
	                var visibilityChangedEvent = new visibilityChangedEvent_1.VisibilityChangedEvent(true);
	                application_1.default.instance.TelemetryService.sendEvent(visibilityChangedEvent);
	                window.setTimeout(function () { return api_1.default.triggerEvent('chat-open', true); }, 5);
	            }
	        };
	        this.onClientFocused = function () {
	            console.log('[userActivityTracker] on client focused');
	            if (_this.isSkypeClientVisible()) {
	                application_1.default.instance.isFocused = true;
	                endpoint.startActivation();
	            }
	        };
	        this.onClientBlurred = function () {
	            console.log('[userActivityTracker] on client blured');
	            application_1.default.instance.isFocused = false;
	            endpoint.stopActivation();
	        };
	        app_1.default.currentUserIdentityType = identityType_1.IdentityType.UNDETERMINED;
	        window.addEventListener('message', this._onMessageReceived);
	        this._baseParent = element || document.querySelector('#main.swc');
	        application_1.default.instance.SignInManager.subscribe('state', this.signinStateChangedHandler.bind(this));
	        application_1.default.instance.setRestoreOfLastConversation(this.restoreLastConversation.bind(this));
	    }
	    Chat.prototype.dispose = function () {
	        application_1.default.instance.SignInManager.unsubscribe('state', this.signinStateChangedHandler.bind(this));
	        this.enable(false);
	        ko.cleanNode(this._baseParent);
	        this.disposeConversations();
	        application_1.default.instance.SignInManager.state = signinState_1.SigninState.SignedOut;
	        this._baseParent.innerHTML = null;
	    };
	    Chat.prototype.disposeConversations = function () {
	        for (var key in this._chatInstances) {
	            var conversation = this._chatInstances[key].model;
	            conversation.dispose();
	            delete this._chatInstances[key];
	        }
	    };
	    Chat.prototype._addPrefix = function (id, sdkMode) {
	        var prefix = '';
	        switch (sdkMode) {
	            case sdkMode_1.SDKMode.PERSON:
	                prefix = '8:';
	                break;
	            case sdkMode_1.SDKMode.BOT:
	                prefix = '28:';
	                break;
	            case sdkMode_1.SDKMode.THREAD:
	                prefix = '19:';
	                break;
	            case sdkMode_1.SDKMode.DIRECT_LINE_TOKEN:
	                prefix = '99:';
	                break;
	        }
	        return prefix + id;
	    };
	    Chat.prototype._createConversationID = function (id, sdkmode) {
	        this._conversationId(this._addPrefix(id, sdkmode));
	    };
	    Chat.prototype.signinStateChangedHandler = function (value) {
	        if (value === signinState_1.SigninState.SignedOut || value === signinState_1.SigninState.SigningIn) {
	            this.disposeConversationsOnRelogin();
	        }
	    };
	    Chat.prototype.restoreLastConversation = function () {
	        if (!this._lastConversationId) {
	            console.warn('[chat] restoreLastConversation: nothing to restore');
	            return;
	        }
	        var chat = this._chatInstances[this._lastConversationId];
	        if (!chat) {
	            return;
	        }
	        chat.model.start();
	        if (this.isSkypeClientVisible()) {
	            endpoint.startActivation();
	        }
	    };
	    Chat.prototype.disposeConversationsOnRelogin = function () {
	        console.log('[chat] reset: disposeConversations');
	        for (var key in this._chatInstances) {
	            var conversation = this._chatInstances[key].model;
	            if (conversation.sdkMode === sdkMode_1.SDKMode.DIRECT_LINE_TOKEN) {
	                continue;
	            }
	            conversation.dispose();
	        }
	        endpoint.stopActivation();
	    };
	    Chat.prototype.inIframe = function () {
	        try {
	            return window.self != window.top;
	        }
	        catch (e) {
	            return true;
	        }
	    };
	    Chat.prototype.isSkypeClientVisible = function () {
	        if (!this._lastConversationId) {
	            console.log('[chat] isSkypeClientVisible: _lastConversationId is not defined');
	            return false;
	        }
	        var chat = this._chatInstances[this._lastConversationId];
	        if (!chat) {
	            return false;
	        }
	        if (chat.model.sdkMode === sdkMode_1.SDKMode.DIRECT_LINE_TOKEN) {
	            console.log('[chat] isSkypeClientVisible: last active chat is DL ');
	            return false;
	        }
	        console.log('[chat] isSkypeClientVisible: last active chat display style is ' + chat.view.style.display);
	        return chat.view.style.display !== 'none';
	    };
	    return Chat;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Chat;


/***/ },
/* 46 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"'`]/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '`': '&#96;'
	};
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	var escapeHtmlChar = basePropertyOf(htmlEscapes);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	/**
	 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
	 * their corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional
	 * characters use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value. See
	 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * Backticks are escaped because in IE < 9, they can break out of
	 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	 * [#133](https://html5sec.org/#133) of the
	 * [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
	 *
	 * When working with HTML you should always
	 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	 * XSS vectors.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbles'
	 */
	function escape(string) {
	  string = toString(string);
	  return (string && reHasUnescapedHtml.test(string))
	    ? string.replace(reUnescapedHtml, escapeHtmlChar)
	    : string;
	}
	
	module.exports = escape;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var skypeAgentsManager_1 = __webpack_require__(48);
	var skypeAmsManager_1 = __webpack_require__(59);
	var skypeContactsManager_1 = __webpack_require__(66);
	var skypeConversationsManager_1 = __webpack_require__(73);
	var skypeSignInManager_1 = __webpack_require__(90);
	var skypeStratusManager_1 = __webpack_require__(96);
	var ObservableBase_1 = __webpack_require__(76);
	var storageService_1 = __webpack_require__(101);
	var skypeSearchManager_1 = __webpack_require__(102);
	var ariaTelemetryService_1 = __webpack_require__(32);
	var Application = (function (_super) {
	    __extends(Application, _super);
	    function Application() {
	        _super.apply(this, arguments);
	        this._isFocused = true;
	    }
	    Object.defineProperty(Application, "instance", {
	        get: function () {
	            if (!Application._instance) {
	                Application._instance = new Application();
	            }
	            return Application._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Application.prototype.dispose = function () {
	        // disposing managers that have user's context
	        if (this._contactsManager) {
	            this._contactsManager.dispose();
	            this._contactsManager = null;
	        }
	        if (this._conversationsManager) {
	            this._conversationsManager.dispose();
	            this._conversationsManager = null;
	        }
	        if (this._amsManager) {
	            this._amsManager.dispose();
	            this._amsManager = null;
	        }
	        if (this._stratusManager) {
	            this._stratusManager.dispose();
	            this._stratusManager = null;
	        }
	        this._isReady = false;
	        this._isCleared = false;
	    };
	    Object.defineProperty(Application, "performanceData", {
	        get: function () {
	            return Application._performanceData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "AgentsManager", {
	        get: function () {
	            if (!this._agentsManager) {
	                this._agentsManager = new skypeAgentsManager_1.default();
	            }
	            return this._agentsManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "AmsManager", {
	        get: function () {
	            if (!this._amsManager) {
	                this._amsManager = new skypeAmsManager_1.default();
	            }
	            return this._amsManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "ContactsManager", {
	        get: function () {
	            if (!this._contactsManager) {
	                this._contactsManager = new skypeContactsManager_1.default();
	            }
	            return this._contactsManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "Messaging", {
	        // Messaging
	        get: function () {
	            if (!this._conversationsManager) {
	                this._conversationsManager = new skypeConversationsManager_1.SkypeConversationsManager();
	            }
	            return this._conversationsManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "SignInManager", {
	        get: function () {
	            if (!this._signInManager) {
	                this._signInManager = new skypeSignInManager_1.default();
	            }
	            return this._signInManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "StratusManager", {
	        get: function () {
	            if (!this._stratusManager) {
	                this._stratusManager = new skypeStratusManager_1.default();
	            }
	            return this._stratusManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "TelemetryService", {
	        get: function () {
	            if (!this._telemetryService) {
	                this._telemetryService = new ariaTelemetryService_1.AriaTelemetryService();
	            }
	            return this._telemetryService;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "SearchManager", {
	        get: function () {
	            if (!this._searchManager) {
	                this._searchManager = new skypeSearchManager_1.default();
	            }
	            return this._searchManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "Storage", {
	        get: function () {
	            return storageService_1.default.get();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "isReady", {
	        /// *******************************************************************************
	        /// Application considered as ready when it finished all setting up operations like
	        /// signing in, creating endpoint
	        /// *******************************************************************************
	        get: function () {
	            return this._isReady;
	        },
	        set: function (value) {
	            if (value === this._isReady) {
	                return;
	            }
	            console.log('[application] setting isReady state to ' + value);
	            this._isReady = value;
	            this.publish('isReady', value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Application.prototype, "isCleared", {
	        get: function () {
	            return this._isCleared;
	        },
	        set: function (value) {
	            if (value === this._isCleared) {
	                return;
	            }
	            console.log('[application] ***************** setting isCleared state to ' + value);
	            this._isCleared = value;
	            this.publish('isCleared', value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Application.prototype.setRestoreOfLastConversation = function (callback) {
	        this._lastConversationCallback = callback;
	    };
	    Application.prototype.restoreLastConversation = function () {
	        if (!this._lastConversationCallback) {
	            console.log('[application] nothing to restore');
	            return;
	        }
	        console.log('[allpication] restoring conversation');
	        this._lastConversationCallback();
	    };
	    Object.defineProperty(Application.prototype, "isFocused", {
	        get: function () {
	            return this._isFocused;
	        },
	        set: function (value) {
	            this._isFocused = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Application._performanceData = {};
	    return Application;
	}(ObservableBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Application;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var main_1 = __webpack_require__(49);
	var main_2 = __webpack_require__(56);
	var SkypeAgentsManager = (function () {
	    function SkypeAgentsManager() {
	        var _this = this;
	        this.addAgent = function (id) {
	            return _this._botsService.addAgentToContacts(id);
	        };
	        this.getAgent = function (id) {
	            return _this._agentsService.getAgentDetails(id);
	        };
	        this._agentsService = new main_1.default();
	        this._botsService = new main_2.default();
	    }
	    return SkypeAgentsManager;
	}());
	exports.SkypeAgentsManager = SkypeAgentsManager;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeAgentsManager;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(50);
	var AgentsService = (function () {
	    function AgentsService() {
	        this.addAgentToContacts = function (agentId, meUserName) {
	            var uri = 'relationship/' + meUserName + '/' + agentId;
	            return requestHelper.put('addAgentToContacts', uri);
	        };
	        this.getAgentDetails = function (agentId) {
	            var uri = 'agents?agentId=' + agentId;
	            return requestHelper.get('getAgentDetails', uri);
	        };
	    }
	    return AgentsService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AgentsService;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(51);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	var request = function (serviceName, url, params) {
	    return requestCommon_1.default('aps-' + serviceName, config_1.default.APS_HOST_URL + url, params);
	};
	var requestJson = function (serviceName, url, params) {
	    return requestCommon_1.default('aps-' + serviceName, config_1.default.APS_HOST_URL + url, params)
	        .then(function (response) {
	        return response.json();
	    });
	};
	exports.get = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        return requestJson(serviceName, uri, getParams);
	    });
	};
	exports.put = function (serviceName, uri, payload) {
	    if (payload === void 0) { payload = ''; }
	    return auth.putHeaders().then(function (headers) {
	        var putParams = {};
	        putParams.method = 'PUT';
	        putParams.body = payload;
	        putParams.headers = headers;
	        return request(serviceName, uri, putParams);
	    });
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	exports.getHeaders = function () {
	    var headers = new Headers();
	    var token;
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            headers.append('X-Skypetoken', token);
	            headers.append('Pragma', 'no-cache');
	            headers.append('Cache-Control', 'no-cache, no-store, must-revalidate');
	            resolve(headers);
	        });
	    });
	};
	exports.putHeaders = function () {
	    var headers = new Headers();
	    var token;
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            headers.append('X-Skypetoken', token);
	            resolve(headers);
	        });
	    });
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(fetch) {"use strict";
	var serviceFaultEvent_1 = __webpack_require__(54);
	var serviceQosEvent_1 = __webpack_require__(55);
	function fetchRequest(serviceName, url, params) {
	    var startTime = Date.now();
	    return fetch(url, params).then(function (response) {
	        var ttc = Date.now() - startTime;
	        if (!response.ok) {
	            serviceFaultEvent_1.ServiceFaultEvent.report(serviceName, response, ttc);
	        }
	        serviceQosEvent_1.manager().register(serviceName, ttc, response.ok);
	        return Promise.resolve(response);
	    }, function (response) {
	        var ttc = Date.now() - startTime;
	        serviceFaultEvent_1.ServiceFaultEvent.report(serviceName, response, ttc);
	        response = response || new Response();
	        response.ok = response.ok || false;
	        serviceQosEvent_1.manager().register(serviceName, ttc, false);
	        return Promise.reject(response);
	    });
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = fetchRequest;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    reader.readAsArrayBuffer(blob)
	    return fileReaderReady(reader)
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    reader.readAsText(blob)
	    return fileReaderReady(reader)
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (!body) {
	        this._bodyText = ''
	      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
	        // Only support ArrayBuffers for POST method.
	        // Receiving ArrayBuffers happens via Blobs, instead.
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        return this.blob().then(readBlobAsArrayBuffer)
	      }
	
	      this.text = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return readBlobAsText(this._bodyBlob)
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as text')
	        } else {
	          return Promise.resolve(this._bodyText)
	        }
	      }
	    } else {
	      this.text = function() {
	        var rejected = consumed(this)
	        return rejected ? rejected : Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	    if (Request.prototype.isPrototypeOf(input)) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = input
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this)
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function headers(xhr) {
	    var head = new Headers()
	    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
	    pairs.forEach(function(header) {
	      var split = header.trim().split(':')
	      var key = split.shift().trim()
	      var value = split.join(':').trim()
	      head.append(key, value)
	    })
	    return head
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = options.status
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = options.statusText
	    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request
	      if (Request.prototype.isPrototypeOf(input) && !init) {
	        request = input
	      } else {
	        request = new Request(input, init)
	      }
	
	      var xhr = new XMLHttpRequest()
	
	      function responseURL() {
	        if ('responseURL' in xhr) {
	          return xhr.responseURL
	        }
	
	        // Avoid security warnings on getResponseHeader when not allowed by CORS
	        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	          return xhr.getResponseHeader('X-Request-URL')
	        }
	
	        return
	      }
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: headers(xhr),
	          url: responseURL()
	        }
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);
	
	
	/*** EXPORTS FROM exports-loader ***/
	module.exports = global.fetch;
	}.call(global));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	var application_1 = __webpack_require__(47);
	/**
	 * Event being published when user starts the
	 * chat session by loading either skype or directline PackageName.
	 *
	 * @export
	 * @class ServiceFaultEvent
	 * @extends {TelemetryEvent}
	 */
	var ServiceFaultEvent = (function (_super) {
	    __extends(ServiceFaultEvent, _super);
	    // public retryCount: number;
	    function ServiceFaultEvent() {
	        _super.call(this, 'service_fault_qos');
	    }
	    ServiceFaultEvent.report = function (serviceName, response, ttc) {
	        response = response || {};
	        var evtData = new ServiceFaultEvent();
	        evtData.serviceName = serviceName;
	        evtData.errorCode = response.status;
	        evtData.errorMessage = response.statusText || response.message;
	        if (response.headers && typeof (response.headers.get) === 'function') {
	            evtData.contextId = response.headers.get('contextid');
	        }
	        evtData.tts = ttc;
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	    };
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf TelemetryEvent
	     */
	    ServiceFaultEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('serviceName', this.getProperty(this.serviceName), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorCode', this.getProperty(this.errorCode), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorMessage', this.getProperty(this.errorMessage), piiType_1.PIIType.NotSet));
	        // props.push(TelemetryPropertyValue.Create('verb', this.getProperty(this.verb), PIIType.NotSet));
	        // props.push(TelemetryPropertyValue.Create('serviceHost', this.getProperty(this.serviceHost), PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('contextId', this.getProperty(this.contextId), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('tts', this.getProperty(this.tts), piiType_1.PIIType.NotSet));
	        // props.push(TelemetryPropertyValue.Create('tts', this.retryCount + '', PIIType.NotSet));
	        return props;
	    };
	    return ServiceFaultEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.ServiceFaultEvent = ServiceFaultEvent;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var application_1 = __webpack_require__(47);
	/**
	 * An event being published after a message sending
	 * completes and reports QoS and KPI factors.
	 *
	 * @export
	 * @class MessageSentEvent
	 * @extends {TelemetryEvent}
	 */
	var ServiceQOSEvent = (function (_super) {
	    __extends(ServiceQOSEvent, _super);
	    function ServiceQOSEvent(serviceName) {
	        _super.call(this, 'service_qos');
	        /**
	         * Average duration (in ms) of how long it took server to response
	         * to successfuly execute a request.
	         *
	         * @type {number}
	         * @memberOf ServiceQOSEvent
	         */
	        this.ttsSuccess = 0;
	        /**
	         * Average duration (in ms) of how long it took server to response
	         * to execute a request with failure.
	         *
	         * @type {number}
	         * @memberOf ServiceQOSEvent
	         */
	        this.ttsFailure = 0;
	        /**
	         * Number of succeeded calles to a service
	         *
	         * @type {number}
	         * @memberOf ServiceQOSEvent
	         */
	        this.successCount = 0;
	        /**
	         * Number of failed calles to a service
	         *
	         * @type {number}
	         * @memberOf ServiceQOSEvent
	         */
	        this.totalCount = 0;
	        this.serviceName = serviceName;
	    }
	    ServiceQOSEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('serviceName', this.serviceName, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('successCount', this.successCount, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('totalCount', this.totalCount, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttsSuccess', this.ttsSuccess, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttsFailure', this.ttsFailure, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return ServiceQOSEvent;
	}(telemetryEvent_1.TelemetryEvent));
	var ServiceQosReporterManager = (function () {
	    function ServiceQosReporterManager() {
	        this.services = {};
	        this.threshold = 10;
	    }
	    ServiceQosReporterManager.prototype.register = function (serviceName, time, isSuccess) {
	        if (!this.services[serviceName]) {
	            this.services[serviceName] = new ServiceQOSEvent(serviceName);
	        }
	        if (isSuccess) {
	            this.services[serviceName].successCount++;
	            this.services[serviceName].ttsSuccess += time;
	        }
	        else {
	            this.services[serviceName].ttsFailure += time;
	        }
	        this.services[serviceName].totalCount++;
	        if (this.services[serviceName].totalCount >= this.threshold) {
	            this.publishEvent(serviceName);
	        }
	    };
	    ServiceQosReporterManager.prototype.flushAll = function () {
	        for (var key in this.services) {
	            this.publishEvent(key);
	        }
	    };
	    ServiceQosReporterManager.prototype.publishEvent = function (serviceName) {
	        var serviceEvent = this.services[serviceName];
	        if (serviceEvent.successCount > 0) {
	            serviceEvent.ttsSuccess = serviceEvent.ttsSuccess / serviceEvent.successCount;
	        }
	        if (serviceEvent.ttsFailure > 0) {
	            serviceEvent.ttsFailure = serviceEvent.ttsFailure / (serviceEvent.totalCount - serviceEvent.successCount);
	        }
	        application_1.default.instance.TelemetryService.sendEvent(serviceEvent);
	        delete this.services[serviceName];
	    };
	    return ServiceQosReporterManager;
	}());
	var serviceQosReporterManager;
	function manager() {
	    if (!serviceQosReporterManager) {
	        serviceQosReporterManager = new ServiceQosReporterManager();
	    }
	    return serviceQosReporterManager;
	}
	exports.manager = manager;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(57);
	var BotsService = (function () {
	    function BotsService() {
	        // TODO: can this be replaced by the APS?
	        this.addAgentToContacts = function (botId) {
	            var uri = 'api/v1/bots/add/' + botId;
	            return requestHelper.put('addAgentToContacts', uri);
	        };
	    }
	    return BotsService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BotsService;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(58);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	var request = function (serviceName, url, params) {
	    return requestCommon_1.default('joinAgents-' + serviceName, config_1.default.AGENTS_HOST_URL + url, params);
	};
	var requestJson = function (serviceName, url, params) {
	    return requestCommon_1.default('joinAgents-' + serviceName, config_1.default.AGENTS_HOST_URL + url, params)
	        .then(function (response) {
	        return response.json();
	    });
	};
	exports.getResponse = function (serviceName, uri) {
	    return request(serviceName, uri);
	};
	exports.get = function (serviceName, uri) {
	    var getParams = {};
	    getParams.method = 'GET';
	    return requestJson(serviceName, uri, getParams);
	};
	exports.put = function (serviceName, uri, payload) {
	    if (payload === void 0) { payload = ''; }
	    return auth.putHeaders().then(function (headers) {
	        var putParams = {};
	        putParams.method = 'PUT';
	        putParams.body = payload;
	        putParams.headers = headers;
	        return request(serviceName, uri, putParams);
	    });
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	exports.putHeaders = function () {
	    var headers = new Headers();
	    var token;
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            headers.append('X-Skypetoken', token);
	            resolve(headers);
	        });
	    });
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var main_1 = __webpack_require__(60);
	var config_1 = __webpack_require__(27);
	var application_1 = __webpack_require__(47);
	var fileUploadEvent_1 = __webpack_require__(64);
	var SkypeAmsManager = (function () {
	    function SkypeAmsManager() {
	        var _this = this;
	        this._amsService = main_1.default;
	        this.createImageMessage = function (content, newDocument) {
	            var uri = config_1.default.AMS_HOST_URL + 'objects/' + newDocument.id;
	            var thumbnail = config_1.default.AMS_HOST_URL + 'objects/' + newDocument.id + '/views/imgt1';
	            var backupLink = 'https://login.skype.com/login/sso?go=webclient.xmm&amp;pic=' + newDocument.id;
	            var fileName = content.name;
	            var result = '<URIObject type="Picture.1" ';
	            result += 'uri="' + uri + '" ';
	            result += 'url_thumbnail="' + thumbnail + '">';
	            result += 'To view this shared photo, go to: <a href="' + backupLink + '">' + backupLink + '</a>';
	            result += '<OriginalName v="' + fileName + '"/><meta type="photo" originalName="' + fileName + '"/>';
	            result += '</URIObject>';
	            return result;
	        };
	        this.createFileMessage = function (content, newDocument) {
	            var uri = config_1.default.AMS_HOST_URL + 'objects/' + newDocument.id;
	            var thumbnail = config_1.default.AMS_HOST_URL + 'objects/' + newDocument.id + '/views/thumbnail';
	            var backupLink = 'https://login.skype.com/login/sso?go=webclient.xmm&amp;docid=' + newDocument.id;
	            var fileName = content.name, fileSize = content.size;
	            var result = '<URIObject type="File.1" ';
	            result += 'uri="' + uri + '" ';
	            result += 'url_thumbnail="' + thumbnail + '">';
	            result += '<Title>Title: ' + fileName + '</Title>';
	            result += '<Description> Description: ' + fileName + '</Description> ';
	            result += '<a href="' + backupLink + '">' + backupLink + '</a>';
	            result += '<OriginalName v="' + fileName + '"/>';
	            result += '<FileSize v="' + fileSize + '"/>';
	            result += '</URIObject>';
	            return result;
	        };
	        this.authenticate = function () {
	            if (!_this._authenticated) {
	                _this._authenticated = true;
	                return _this._authenticate();
	            }
	            return Promise.resolve();
	        };
	        this._authenticate = function () {
	            var headers = new Headers();
	            return _this._amsService.authenticate();
	        };
	        this._authenticated = false;
	        this._authenticate();
	    }
	    SkypeAmsManager.prototype.sendFile = function (conversation, content) {
	        var _this = this;
	        return this.authenticate().then(function () {
	            return _this._amsService.createNewDocument(conversation.id, content).then(function (newDocument) {
	                var dateStart = Date.now();
	                return _this._amsService.sendFile(newDocument.id, content).then(function (response) {
	                    // send telemetry
	                    var fileUpload = new fileUploadEvent_1.default(conversation, content);
	                    fileUpload.status = response.status;
	                    fileUpload.ttc = Date.now() - dateStart;
	                    application_1.default.instance.TelemetryService.sendEvent(fileUpload);
	                    if (_this._amsService.isDocumentTypeImage(content.type)) {
	                        return conversation.sendImage(_this.createImageMessage(content, newDocument));
	                    }
	                    else {
	                        return conversation.sendFile(_this.createFileMessage(content, newDocument));
	                    }
	                });
	            });
	        });
	    };
	    SkypeAmsManager.prototype.downloadPictureThumbnail = function (pictureId) {
	        var _this = this;
	        return this.authenticate().then(function () {
	            return _this._amsService.downloadPictureThumbnail(pictureId);
	        });
	    };
	    SkypeAmsManager.prototype.getPictureThumbnail = function (url) {
	        var _this = this;
	        return this.authenticate().then(function () {
	            return _this._amsService.getPictureThumbnail(url);
	        });
	    };
	    SkypeAmsManager.prototype.downloadPicture = function (pictureId) {
	        var _this = this;
	        return this.authenticate().then(function () {
	            return _this._amsService.downloadPicture(pictureId);
	        });
	    };
	    SkypeAmsManager.prototype.dispose = function () {
	        // todo: ams logout!
	        this._authenticated = false;
	        console.log('[skypeAmsManager] TODO::logout!');
	    };
	    return SkypeAmsManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeAmsManager;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(61);
	var interfaces_1 = __webpack_require__(63);
	var config_1 = __webpack_require__(27);
	var application_1 = __webpack_require__(47);
	var THUMBNAIL_VIEW = 'imgt1', ORIGINAL_VIEW = 'imgpsh_fullsize';
	// PHOTOSHARING_CONTENT = 'imgpsh',
	// AVATAR_CONTENT = 'avatar',
	// AVATAR_IMAGE_VIEW = 'avatar_fullsize',
	// FILE_TRANSFER_CONTENT = 'original',
	// FILE_THUMBNAIL_VIEW = 'thumbnail',
	// VIDEO_CONTENT = 'video',
	// AUDIO_CONTENT = 'audio';
	var INITIAL_REQUEST_DELAY = 0, RETRIED_REQUEST_DELAY = 500, RETRY_COUNT = 3;
	var AgentsService = (function () {
	    function AgentsService() {
	        var _this = this;
	        this.createNewDocument = function (conversationId, file) {
	            var uri = 'objects';
	            var body = {
	                type: _this.getDocumentTypeFromContentType(file.type),
	                permissions: {}
	            };
	            body.filename = file.name;
	            body.permissions[conversationId] = [interfaces_1.Permission[interfaces_1.Permission.read]];
	            return requestHelper.post('createNewDocument', uri, JSON.stringify(body)).then(function (response) {
	                return response.json();
	            });
	        };
	        this.sendFile = function (documentId, data) {
	            var cloudDataContent = _this.isDocumentTypeImage(data.type) ? 'imgpsh' : 'original';
	            var uri = 'objects/' + documentId + '/content/' + cloudDataContent;
	            return requestHelper.putData('sendFile', uri, data);
	        };
	        this.downloadPictureThumbnail = function (documentId) {
	            var uri = config_1.default.AMS_HOST_URL + 'objects/' + documentId;
	            // let uri = config.AMS_HOST_URL + 'objects/' + documentId + '/views/imgt1';
	            return new Promise(function (resolve) {
	                _this.getViewStatus(uri, THUMBNAIL_VIEW).then(function (vUrl) {
	                    requestHelper.getData('downloadPictureThumbnail', vUrl).then(resolve);
	                });
	            });
	        };
	        this.downloadPicture = function (documentId) {
	            // let uri = 'objects/' + documentId + '/views/imgpsh_fullsize';
	            var uri = config_1.default.AMS_HOST_URL + 'objects/' + documentId;
	            return new Promise(function (resolve) {
	                _this.getViewStatus(uri, ORIGINAL_VIEW).then(function (vUrl) {
	                    return requestHelper.getData('downloadPicture', vUrl).then(resolve);
	                });
	            });
	        };
	        this.getPictureThumbnail = function (url) {
	            return new Promise(function (resolve) {
	                return requestHelper.get('getPictureThumbnail', url).then(function (response) { return requestHelper.parseJson(response); }).then(resolve);
	            });
	        };
	        this.authenticate = function () {
	            return new Promise(function (resolve) {
	                application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	                    var uri = 'skypetokenauth', body = 'skypetoken=' + token;
	                    return requestHelper.postForm('authenticate', uri, body).then(resolve);
	                });
	            });
	        };
	        this.logout = function () {
	            // todo: was not tested yet
	            var uri = 'skypetokenauth/expire';
	            return requestHelper.get('logout', uri);
	        };
	        this.isDocumentTypeImage = function (contentType) {
	            // TODO marud: switch to swx way? ['image/png', 'image/x-png', 'image/jpeg']
	            return contentType.indexOf('image') !== -1;
	        };
	        this.getDocumentTypeFromContentType = function (contentType) {
	            if (_this.isDocumentTypeImage(contentType)) {
	                return 'pish/image';
	            }
	            else {
	                return 'sharing/file';
	            }
	        };
	        this.getViewStatus = function (uri, view, delay, retries) {
	            if (delay === void 0) { delay = INITIAL_REQUEST_DELAY; }
	            if (retries === void 0) { retries = RETRY_COUNT; }
	            var viewUri = uri + '/views/' + view, statusUri = viewUri + '/status';
	            if (retries === 0) {
	                return Promise.reject({});
	            }
	            var onSuccess = function (response) {
	                if (response.view_location) {
	                    return Promise.resolve(response.view_location);
	                }
	                var isScanFailed = response.scan && response.scan.status !== 'in progress' && response.scan.status !== 'ready', isReadyWithNoScanning = response.view_state === 'ready' && !response.scan, isReadyIncludingScanning = response.view_state === 'ready' && response.scan && response.scan.status === 'passed';
	                if (response.status_location && !response.view_state) {
	                    uri = response.status_location.replace('/views/' + view + '/status', '');
	                    return _this.getViewStatus(uri, view, delay, retries);
	                }
	                else if (isReadyWithNoScanning || isReadyIncludingScanning) {
	                    return Promise.resolve(viewUri);
	                }
	                else if (response.view_state === 'failed' || isScanFailed) {
	                    return Promise.reject({});
	                }
	                else if (response.content_state !== 'expired') {
	                    return _this.getViewStatus(uri, view, RETRIED_REQUEST_DELAY, retries);
	                }
	                else {
	                    // TODO: define behaviour when expired
	                    return Promise.reject({});
	                }
	            };
	            var onError = function (response) {
	                if (response.status === 401 || response.status === 403) {
	                    retries--;
	                    return _this.authenticate().then(function () {
	                        return _this.getViewStatus(uri, view, delay, retries);
	                    });
	                }
	                return Promise.reject({});
	            };
	            return new Promise(function (resolve) {
	                setTimeout(resolve, delay);
	            }).then(function () {
	                return requestHelper.getJson('getViewStatus', statusUri).then(onSuccess, onError);
	            });
	        };
	    }
	    return AgentsService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new AgentsService();


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(62);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	exports.request = function (serviceName, url, params) {
	    var hostUrl = url.indexOf('http') === 0 ? url : config_1.default.AMS_HOST_URL + url;
	    return requestCommon_1.default('ams-' + serviceName, hostUrl, params);
	};
	exports.putData = function (serviceName, uri, payload) {
	    return auth.getHeaders().then(function (headers) {
	        var putParams = {};
	        putParams.method = 'PUT';
	        putParams.body = payload;
	        putParams.headers = headers;
	        return exports.request(serviceName, uri, putParams);
	    });
	};
	exports.getData = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Accept', 'image/webp,image/*,*/*;q=0.8');
	        headers.append('Accept-Encoding', 'gzip, deflate, sdch, br');
	        var putParams = {};
	        putParams.method = 'GET';
	        putParams.headers = headers;
	        return exports.request(serviceName, uri, putParams).then(function (response) {
	            return response.blob();
	        });
	    });
	};
	exports.getJson = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Accept', 'image/webp,image/*,*/*;q=0.8');
	        headers.append('Accept-Encoding', 'gzip, deflate, sdch, br');
	        var putParams = {};
	        putParams.method = 'GET';
	        putParams.headers = headers;
	        return exports.request(serviceName, uri, putParams).then(function (response) {
	            return response.json();
	        });
	    });
	};
	exports.post = function (serviceName, uri, payload) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Content-Type', 'application/json');
	        var postParams = {};
	        postParams.method = 'POST';
	        postParams.body = payload;
	        postParams.headers = headers;
	        return exports.request(serviceName, uri, postParams);
	    });
	};
	exports.postForm = function (serviceName, uri, body) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Content-Type', 'application/x-www-form-urlencoded');
	        var postParams = {};
	        postParams.method = 'POST';
	        postParams.headers = headers;
	        if (body) {
	            postParams.body = body;
	        }
	        return exports.request(serviceName, uri, postParams);
	    });
	};
	exports.get = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Content-Type', 'application/json');
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        return exports.request(serviceName, uri, getParams);
	    });
	};
	exports.parseJson = function (response) {
	    return response.json().then(function (json) {
	        if (response.ok) {
	            return Promise.resolve(json);
	        }
	        return Promise.reject(json);
	    });
	};


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var config_1 = __webpack_require__(27);
	exports.getHeaders = function () {
	    var headers = new Headers();
	    var token;
	    var platformVersion = getClientVersion();
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            headers.append('Authorization', 'skype_token ' + token);
	            if (config_1.default.ECS.version) {
	                headers.append('X-MS-Client-Version', platformVersion);
	            }
	            resolve(headers);
	        });
	    });
	};
	function getClientVersion() {
	    var version = config_1.default.ECS.version;
	    if (/^\d+\.\d+\.\d+$/.test(version)) {
	        version += '.0';
	    }
	    return config_1.default.PLATFORM_ID + '/' + version;
	}


/***/ },
/* 63 */
/***/ function(module, exports) {

	"use strict";
	(function (Permission) {
	    Permission[Permission["read"] = 0] = "read";
	})(exports.Permission || (exports.Permission = {}));
	var Permission = exports.Permission;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var telemetryEvent_1 = __webpack_require__(23);
	var conversationDataEvent_1 = __webpack_require__(65);
	var piiType_1 = __webpack_require__(25);
	/**
	 * An event being published after every file upload
	 * completes.
	 *
	 * @export
	 * @class FileUploadEvent
	 * @extends {TelemetryEvent}
	 */
	var FileUploadEvent = (function (_super) {
	    __extends(FileUploadEvent, _super);
	    function FileUploadEvent(conversation, file) {
	        _super.call(this, 'kpi_file_upload', conversation);
	        var exRegEx = /\.([a-zA-Z\d]*)$/i;
	        var exMatch = file.name.match(exRegEx);
	        this.size = file.size;
	        this.fileType = (exMatch) ? exMatch[1] : telemetryEvent_1.NA;
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf MessagesFetchEvent
	     */
	    FileUploadEvent.prototype.getCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('size', this.size, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('type', this.type, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttc', this.ttc, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.status, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('contentType', this.getContentType(), piiType_1.PIIType.NotSet));
	        return props;
	    };
	    FileUploadEvent.prototype.getContentType = function () {
	        switch (this.type) {
	            case 'png':
	            case 'jpg':
	            case 'gif':
	            case 'bmp':
	            case 'tiff':
	                return 'Picture';
	            case 'avi':
	            case 'mp4':
	            case 'mkv':
	            case 'wmv':
	            case 'm4v':
	                return 'Video';
	            case 'mp3':
	            case 'cda':
	            case 'm4a':
	            case 'wav':
	                return 'Audio';
	            case 'xls':
	            case 'xlsx':
	            case 'xlsm':
	            case 'doc':
	            case 'docx':
	            case 'ppt':
	            case 'pptx':
	                return 'MSOffice';
	            case 'zip':
	            case 'rar':
	            case 'ace':
	            case '7z':
	            case 'dmg':
	                return 'Archive';
	            case 'exe':
	            case 'msi':
	            case 'iso':
	                return 'Binary';
	            case 'html':
	            case 'htm':
	            case 'txt':
	                return 'Text';
	            case 'pdf':
	                return 'Pdf';
	            default:
	                return 'Other';
	        }
	    };
	    return FileUploadEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FileUploadEvent;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var messagingBackend_1 = __webpack_require__(38);
	var sdkMode_1 = __webpack_require__(30);
	var errorHandler_1 = __webpack_require__(15);
	var conversationType_1 = __webpack_require__(14);
	/**
	 * An event being published in the moment user
	 * loaded the conversation in the chat control.
	 *
	 * @export
	 * @class ConversationLoadEvent
	 * @extends {TelemetryEvent}
	 */
	var ConversationDataEvent = (function (_super) {
	    __extends(ConversationDataEvent, _super);
	    function ConversationDataEvent(eventName, conversation) {
	        var _this = this;
	        _super.call(this, eventName);
	        this.conversation = conversation;
	        this._topic = telemetryEvent_1.NA;
	        this._topic = conversation.topic;
	        conversation.subscribe('topic', function (value) {
	            _this._topic = value;
	        });
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignInEvent
	     */
	    ConversationDataEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('conversationId', this.conversation.id, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('conversationType', this.conversation.getConversationType(), piiType_1.PIIType.NotSet));
	        props.push(this.getSDKMode());
	        props.push(this.getBackend());
	        props.push(this.getConversationTopic());
	        return props;
	    };
	    ConversationDataEvent.prototype.getConversationTopic = function () {
	        var topic = telemetryEvent_1.NA;
	        if (this.conversation.getConversationType() === conversationType_1.default.AGENT ||
	            this.conversation.getConversationType() === conversationType_1.default.DIRECT_LINE) {
	            topic = this._topic;
	        }
	        return telemetryPropertyValue_1.TelemetryPropertyValue.Create('conversationTopic', topic, piiType_1.PIIType.NotSet);
	    };
	    ConversationDataEvent.prototype.getBackend = function () {
	        var backendService = '';
	        var backend = this.conversation.getBackend();
	        switch (backend) {
	            case messagingBackend_1.MessagingBackend.UNDETERMINED:
	                backendService = telemetryEvent_1.NA;
	                break;
	            case messagingBackend_1.MessagingBackend.SKYPE:
	                backendService = 'Skype';
	                break;
	            case messagingBackend_1.MessagingBackend.DIRECT_LINE:
	                backendService = 'DirectLine';
	                break;
	            case messagingBackend_1.MessagingBackend.UNDEFINED:
	                backendService = telemetryEvent_1.NA;
	                break;
	            default:
	                errorHandler_1.default.throwError(10033, 'Unknown backend:' + backend);
	        }
	        return telemetryPropertyValue_1.TelemetryPropertyValue.Create('backend', backendService, piiType_1.PIIType.NotSet);
	    };
	    ConversationDataEvent.prototype.getSDKMode = function () {
	        var modeStr = '';
	        var mode = this.conversation.getSDKMode();
	        switch (mode) {
	            case sdkMode_1.SDKMode.BOT:
	                modeStr = 'bot';
	                break;
	            case sdkMode_1.SDKMode.DIRECT_LINE_TOKEN:
	                modeStr = 'DirectLine';
	                break;
	            case sdkMode_1.SDKMode.JOIN_URL:
	                modeStr = 'url';
	                break;
	            case sdkMode_1.SDKMode.PERSON:
	                modeStr = 'person';
	                break;
	            case sdkMode_1.SDKMode.THREAD:
	                modeStr = 'thread';
	                break;
	            case sdkMode_1.SDKMode.UNDEFINED:
	                modeStr = telemetryEvent_1.NA;
	                break;
	            default:
	                errorHandler_1.default.throwError(10037, 'Unknown identityType:' + mode);
	        }
	        // this.sdkMode = mode;
	        return telemetryPropertyValue_1.TelemetryPropertyValue.Create('sdkMode', modeStr, piiType_1.PIIType.NotSet);
	    };
	    return ConversationDataEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.ConversationDataEvent = ConversationDataEvent;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var app_1 = __webpack_require__(26);
	var main_1 = __webpack_require__(67);
	var tokenUtility_1 = __webpack_require__(70);
	var identityType_1 = __webpack_require__(29);
	var signinState_1 = __webpack_require__(71);
	var personHelper_1 = __webpack_require__(72);
	var SkypeContactsManager = (function () {
	    function SkypeContactsManager() {
	        var _this = this;
	        this.isPersonContact = function (mri) {
	            return new Promise(function (resolve, reject) {
	                _this._isPersonContactPromiseRejectCallback = reject;
	                application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	                    var tokenParser = new tokenUtility_1.default();
	                    var meUserName = tokenParser.retrieveMeName(token);
	                    if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST) {
	                        return resolve(true);
	                    }
	                    var onSuccess = function (rawContacts) {
	                        _this._isPersonContactPromiseRejectCallback = null;
	                        resolve(_this.isContact(rawContacts, mri));
	                    };
	                    var onFailure = function (reason) {
	                        console.error('[skypeContactsManager] failed to fetch a contact');
	                        console.log(reason);
	                        _this._isPersonContactPromiseRejectCallback(false);
	                        _this._isPersonContactPromiseRejectCallback = null;
	                    };
	                    return _this._contactsService.fetchContact(meUserName, personHelper_1.default.normalizePersonId(mri)).then(onSuccess, onFailure);
	                }, _this._isPersonContactPromiseRejectCallback.bind(_this, { source: 'onSigninFailed' }));
	            });
	        };
	        this.addContact = function (mri, greetingsMessage) {
	            return _this._contactsService.addContact(mri, greetingsMessage);
	        };
	        this.dispose = function () {
	            console.log('[skypeContactsManager] dispose');
	            if (_this._isPersonContactPromiseRejectCallback) {
	                _this._isPersonContactPromiseRejectCallback({ source: 'onDispose' });
	            }
	            application_1.default.instance.SignInManager.unsubscribe('state', _this.signinStateChangedHandler);
	        };
	        this.signinStateChangedHandler = function () {
	            console.log('[skypeContactsManager] signed out state handler');
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedOut
	                && _this._isPersonContactPromiseRejectCallback) {
	                console.log('[skypeContactsManager] signed out state handler: rejecting promise');
	                _this._isPersonContactPromiseRejectCallback({ source: 'signout' });
	            }
	        };
	        this.isContact = function (contacts, mri) {
	            if (!contacts || !contacts.contacts) {
	                return false;
	            }
	            var contact = contacts.contacts.filter(function (rawContact) {
	                return rawContact.mri === mri && rawContact.authorized;
	            })[0];
	            return !!contact && contact.authorized;
	        };
	        this._contactsService = new main_1.default();
	        application_1.default.instance.SignInManager.subscribe('state', this.signinStateChangedHandler);
	    }
	    return SkypeContactsManager;
	}());
	exports.SkypeContactsManager = SkypeContactsManager;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeContactsManager;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(68);
	var application_1 = __webpack_require__(47);
	var ContactsService = (function () {
	    function ContactsService() {
	        this.fetchContacts = function (meUserName) {
	            var uri = 'users/' + meUserName + '/contacts?reason=default';
	            return requestHelper.get('fetchContacts', uri);
	        };
	        this.fetchContact = function (meUserName, userName) {
	            var uri = 'users/' + meUserName + '/contacts?$filter=mri%2Fidentifier%20eq%20%27' + userName + '%27';
	            return requestHelper.get('fetchContact', uri);
	        };
	    }
	    ContactsService.prototype.addContact = function (id, greetingsMessage) {
	        var uri = 'users/' + application_1.default.instance.Messaging.mePerson.id + '/contacts';
	        var payload = {
	            mri: id,
	            greeting: greetingsMessage
	        };
	        return requestHelper.post('addContact', uri, JSON.stringify(payload));
	    };
	    ;
	    return ContactsService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContactsService;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(69);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	var requestJson = function (serviceName, url, params) {
	    return requestCommon_1.default('contacts-' + serviceName, config_1.default.CONTACTS_HOST_URL + url, params);
	};
	exports.get = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        getParams.cache = 'no-cache';
	        return requestJson(serviceName, uri, getParams).then(function (response) {
	            return response.json();
	        });
	    });
	};
	exports.post = function (serviceName, uri, payload) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Content-Type', 'application/json');
	        var postParams = {};
	        postParams.method = 'POST';
	        postParams.body = payload;
	        postParams.headers = headers;
	        return requestJson(serviceName, uri, postParams);
	    });
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var config_1 = __webpack_require__(27);
	exports.getHeaders = function () {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            var headers = new Headers();
	            headers.append('X-Skypetoken', token);
	            headers.append('X-Skype-Caller', config_1.default.SKYPE_CALLER_ID);
	            resolve(headers);
	        });
	    });
	};


/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	var TokenParser = (function () {
	    function TokenParser() {
	        this.retrieveMeName = function (token) {
	            if (!token) {
	                return '';
	            }
	            var userPart = token.substring(token.indexOf('.') + 1);
	            userPart = userPart.substring(0, userPart.indexOf('.'));
	            return JSON.parse(atob(userPart)).skypeid;
	        };
	    }
	    return TokenParser;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TokenParser;


/***/ },
/* 71 */
/***/ function(module, exports) {

	"use strict";
	(function (SigninState) {
	    /**
	     * User is signed out of skype
	     */
	    SigninState[SigninState["SignedOut"] = 0] = "SignedOut";
	    /**
	     * User is signin in skype
	     */
	    SigninState[SigninState["SigningIn"] = 1] = "SigningIn";
	    /**
	     * User is signed in skype
	     */
	    SigninState[SigninState["SignedIn"] = 2] = "SignedIn";
	    /**
	    * User is signing out of skype
	    */
	    SigninState[SigninState["SigningOut"] = 3] = "SigningOut";
	})(exports.SigninState || (exports.SigninState = {}));
	var SigninState = exports.SigninState;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var PersonUtils = (function () {
	    function PersonUtils() {
	    }
	    PersonUtils.isMePerson = function (id) {
	        var mePerson = application_1.default.instance.Messaging.mePerson;
	        if (!mePerson) {
	            return false;
	        }
	        if (mePerson.id === id || mePerson.msaId === id) {
	            return true;
	        }
	        return mePerson.msaId === id;
	    };
	    PersonUtils._personIdRegExp = /(\d+:)([\S]*)/;
	    PersonUtils.normalizePersonId = function (personId) {
	        var match = personId.match(PersonUtils._personIdRegExp);
	        if (match) {
	            return match[2];
	        }
	        return personId;
	    };
	    PersonUtils.parsePersonId = function (personId) {
	        var match = personId.match(PersonUtils._personIdRegExp);
	        if (!match) {
	            return { id: personId, type: null };
	        }
	        return { id: match[2], type: parseInt(match[1], 0) };
	    };
	    return PersonUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PersonUtils;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var app_1 = __webpack_require__(26);
	var application_1 = __webpack_require__(47);
	var MePerson_1 = __webpack_require__(74);
	var chat_1 = __webpack_require__(77);
	var conversation_1 = __webpack_require__(83);
	var tokenUtility_1 = __webpack_require__(70);
	var signinState_1 = __webpack_require__(71);
	var identityType_1 = __webpack_require__(29);
	var conversationLoadEvent_1 = __webpack_require__(89);
	var SkypeConversationsManager = (function () {
	    function SkypeConversationsManager() {
	        var _this = this;
	        this._signInManager = application_1.default.instance.SignInManager;
	        // **********************************************************************************
	        // ************************* ME PERSON **********************************************
	        // **********************************************************************************
	        this.getMePerson = function () {
	            return _this._mePersonPromise;
	        };
	        this.fetchMePerson = function () {
	            if (_this.mePerson) {
	                //ErrorHandler.throwError(10007, '[skypeConversationsManager] mePerson has been already fetched');
	                return;
	            }
	            _this._signInManager.getSkypeToken().then(function (token) {
	                _this.__fetchMePerson();
	            }).catch(function (error) {
	                // todo: add runtime error telemtry here
	                console.error('[skypeConversationsManager] unable to fetch mePerson');
	                console.error(error);
	            });
	        };
	        // **********************************************************************************
	        // ************************* Backend   **********************************************
	        // **********************************************************************************
	        this.signinStateChangedHandler = function (value) {
	            console.log('[skypeConversationsManager] signinStateChangedHandler::', value);
	            switch (value) {
	                case signinState_1.SigninState.SignedOut:
	                    _this.resetSkypeBackend();
	                    application_1.default.instance.isReady = false;
	                    // todo: when app will be disposed then Application.isReady should be true
	                    break;
	                case signinState_1.SigninState.SigningIn:
	                case signinState_1.SigninState.SignedIn:
	                case signinState_1.SigninState.SigningOut:
	                    break;
	            }
	        };
	        this.dispose = function () {
	            _this._signInManager.unsubscribe('state', _this.signinStateChangedHandler);
	        };
	        this.resetSkypeBackend = function () {
	            console.log('[skypeConversationsMnager] reseting skype backend...');
	            conversationLoadEvent_1.ConversationLoadEvent.isAvailable = true;
	            var onSuccess = function () {
	                console.log('[skypeConversationsMnager] resetting of chat service is complete. Disposing application');
	                application_1.default.instance.dispose();
	                if (_this._signInManager.reloginContext.canRelogin) {
	                    var bindedInit = function () {
	                        console.log('[skypeConversationsMnager] relogin: fetch me person');
	                        application_1.default.instance.Messaging.fetchMePerson();
	                        application_1.default.instance.restoreLastConversation();
	                    };
	                    _this._signInManager.reloginContext.execCallback()
	                        .then(bindedInit, bindedInit);
	                }
	                else {
	                    application_1.default.instance.isCleared = true;
	                }
	            };
	            return chat_1.reset().then(onSuccess);
	        };
	        application_1.default.instance.SignInManager.subscribe('state', this.signinStateChangedHandler);
	        this._mePersonPromise = new Promise(function (resolve, reject) {
	            _this._mePersonPromiseResolveCallback = resolve;
	        });
	    }
	    SkypeConversationsManager.prototype.__fetchMePerson = function () {
	        var _this = this;
	        if (this.mePerson) {
	            //ErrorHandler.throwError(10007, '[skypeConversationsManager] mePerson has been already fetched..');
	            return;
	        }
	        console.log('[skypeConversetionsManager] fetching me person from skype token');
	        this._signInManager.getSkypeToken().then(function (token) {
	            var tokenParser = new tokenUtility_1.default();
	            var meUserName = tokenParser.retrieveMeName(token);
	            _this.mePerson = new MePerson_1.default(meUserName);
	            if (app_1.default.currentUserIdentityType !== identityType_1.IdentityType.GUEST) {
	                conversation_1.fetchMeProperties().then(function (rawMeProperties) {
	                    _this.mePerson.msaId = rawMeProperties.primaryMemberName;
	                });
	                application_1.default.instance.StratusManager.getPersonData(_this.mePerson.id, _this.mePerson, true);
	            }
	            _this._mePersonPromiseResolveCallback(_this.mePerson);
	        });
	    };
	    return SkypeConversationsManager;
	}());
	exports.SkypeConversationsManager = SkypeConversationsManager;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Person_1 = __webpack_require__(75);
	var MePerson = (function (_super) {
	    __extends(MePerson, _super);
	    function MePerson(id) {
	        _super.call(this, id, false);
	    }
	    Object.defineProperty(MePerson.prototype, "msaId", {
	        get: function () {
	            return this._msaId;
	        },
	        set: function (value) {
	            if (value !== this._msaId) {
	                this._msaId = value;
	                this.publish('msaId', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return MePerson;
	}(Person_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MePerson;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ObservableBase_1 = __webpack_require__(76);
	var application_1 = __webpack_require__(47);
	var Person = (function (_super) {
	    __extends(Person, _super);
	    function Person(_id, isAgent) {
	        if (isAgent === void 0) { isAgent = false; }
	        _super.call(this);
	        this._id = _id;
	        this._isAgent = false;
	        this._isAgent = isAgent;
	        this._displayName = this._id;
	        this._description = '';
	        // TODO: this breaks the possibility to have another service than skype
	        // if (this.isAgent) {
	        //     botService.getDisplayName(this._id).then((displayName: string) => {
	        //         this._displayName = displayName;
	        //         this.publish('displayName', this._displayName);
	        //     });
	        // }
	        this.fetchDisplayName();
	    }
	    Person.prototype.fetchDisplayName = function () {
	        var _this = this;
	        if (this.isAgent) {
	            application_1.default.instance.AgentsManager.getAgent(this._id).then(function (agent) {
	                if (agent && agent.agentDescriptions && agent.agentDescriptions.length === 1) {
	                    _this._displayName = agent.agentDescriptions[0].displayName;
	                    _this._description = agent.agentDescriptions[0].description;
	                    _this.publish('displayName', _this._displayName);
	                    _this.publish('description', _this._description);
	                }
	            });
	        }
	        else {
	            application_1.default.instance.StratusManager.getPersonData(this._id, this);
	        }
	    };
	    Object.defineProperty(Person.prototype, "isAgent", {
	        get: function () {
	            return this._isAgent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Person.prototype, "id", {
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Person.prototype, "displayName", {
	        get: function () {
	            return this._displayName;
	        },
	        set: function (value) {
	            if (value !== this._displayName) {
	                this._displayName = value;
	                this.publish('displayName', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Person.prototype, "description", {
	        get: function () {
	            return this._description;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Person.prototype, "avatarData", {
	        get: function () {
	            return this._avatarData;
	        },
	        set: function (value) {
	            if (value !== this._avatarData) {
	                this._avatarData = value;
	                this.publish('avatarData', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Person.prototype, "extraLargeAvatarUrl", {
	        get: function () {
	            return this.extraLargeAvatarUrl;
	        },
	        set: function (value) {
	            if (value !== this._extraLargeAvatarUrl) {
	                this._extraLargeAvatarUrl = value;
	                this.publish('extraLargeAvatarUrl', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Person;
	}(ObservableBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Person;


/***/ },
/* 76 */
/***/ function(module, exports) {

	"use strict";
	var ObservableBase = (function () {
	    function ObservableBase() {
	        this.callbacks = {};
	    }
	    ObservableBase.prototype.subscribe = function (name, callback) {
	        if (this.callbacks[name] === undefined) {
	            this.callbacks[name] = new Array();
	        }
	        this.callbacks[name].push(callback);
	    };
	    ObservableBase.prototype.unsubscribe = function (name, callback) {
	        if (this.callbacks[name] === undefined) {
	            return;
	        }
	        var callbackIndex = this.callbacks[name].indexOf(callback);
	        if (callbackIndex > -1) {
	            this.callbacks[name].splice(callbackIndex, 1);
	        }
	    };
	    ObservableBase.prototype.dispose = function () {
	        for (var index in this.callbacks) {
	            if (this.callbacks.hasOwnProperty(index)) {
	                this.callbacks[index] = null;
	            }
	        }
	        this.callbacks = {};
	    };
	    ObservableBase.prototype.publish = function (name, value) {
	        if (this.callbacks[name] === undefined) {
	            return;
	        }
	        // copy the callbacks as if there is unsubscribe in one of callback, it would mess up with indexing in for loop
	        var callbacks = this.callbacks[name].map(function (callback) { return callback; });
	        callbacks.forEach(function (callback) {
	            callback(value);
	        });
	    };
	    return ObservableBase;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ObservableBase;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var joining_1 = __webpack_require__(78);
	exports.joinConversation = joining_1.joinConversation;
	var conversation_1 = __webpack_require__(83);
	exports.checkIfConversationExist = conversation_1.checkIfConversationExist;
	exports.fetchRecentConversations = conversation_1.fetchRecentConversations;
	exports.fetchConversation = conversation_1.fetchConversation;
	exports.fetchThread = conversation_1.fetchThread;
	exports.fetchMessages = conversation_1.fetchMessages;
	exports.fetchMessagesByLink = conversation_1.fetchMessagesByLink;
	exports.sendMessage = conversation_1.sendMessage;
	exports.subscribeConversation = conversation_1.subscribeConversation;
	exports.fetchMeProperties = conversation_1.fetchMeProperties;
	exports.unsubscribeConversation = conversation_1.unsubscribeConversation;
	var contact_1 = __webpack_require__(88);
	exports.subscribeContactPersence = contact_1.subscribeContactPersence;
	exports.unsubscribeContactPresence = contact_1.unsubscribeContactPresence;
	var conversation_2 = __webpack_require__(83);
	exports.reset = function () {
	    return conversation_2.reset();
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(79);
	var tokenUtility_1 = __webpack_require__(70);
	var application_1 = __webpack_require__(47);
	exports.joinConversation = function (conversationId) {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            var tokenParser = new tokenUtility_1.default();
	            var meUserName = tokenParser.retrieveMeName(token);
	            var url = 'threads/' + conversationId + '/members/8:' + meUserName;
	            requestHelper.put('joinConversation', url, { body: JSON.stringify({ role: 'User' }) }).then(function () {
	                resolve();
	            });
	        });
	    });
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _this = this;
	var auth = __webpack_require__(80);
	var utils = __webpack_require__(81);
	__webpack_require__(82);
	var config_1 = __webpack_require__(27);
	var application_1 = __webpack_require__(47);
	var signinState_1 = __webpack_require__(71);
	var requestCommon_1 = __webpack_require__(52);
	var MAX_RETRIES = 3;
	var defaultHeaders = {
	    ClientInfo: config_1.default.CHAT_CLIENT_INFO,
	    Pragma: 'no-cache',
	    Expires: 0,
	    ContextId: 'tcid=' + new Date().getTime() + (Math.floor(Math.random() * 90000) + 10000),
	    BehaviorOverride: 'redirectAs404'
	};
	var getParams = function (method, params) {
	    if (params === void 0) { params = {}; }
	    var requestParams = Object.assign({}, params);
	    return auth.getHeaders().then(function (headers) {
	        requestParams.method = method;
	        requestParams.headers = requestParams.headers || {};
	        Object.assign(requestParams.headers, defaultHeaders, headers);
	        return requestParams;
	    });
	};
	var handleError = function (serviceName, response, url, params, retriesLeft) {
	    if (retriesLeft === void 0) { retriesLeft = MAX_RETRIES; }
	    var canBeRetried = response.status === 429 || response.status === 500 || response.status === 503;
	    if (!canBeRetried) {
	        return Promise.resolve(response);
	    }
	    if (retriesLeft === 0) {
	        return Promise.reject(response);
	    }
	    return requestCommon_1.default('webapi-' + serviceName, url, params).then(function (retriedResponse) {
	        return new Promise(function (resolve) {
	            setTimeout(function () {
	                resolve(handleError(serviceName, retriedResponse, url, params, retriesLeft - 1));
	            }, (MAX_RETRIES - retriesLeft + 1) * 2000);
	        });
	    });
	};
	var request = function (serviceName, method, url, inputParams) {
	    return getParams(method, inputParams).then(function (params) {
	        if (!utils.getDomain()) {
	            console.error('[requestHelper] request:: domain in undefined!');
	            application_1.default.instance.SignInManager.logout();
	            // todo: RuntimeErrorEvent
	            return Promise.reject({ message: 'Domain is undefined' });
	        }
	        return requestCommon_1.default('webapi-' + serviceName, utils.getDomain() + url, params)
	            .then(auth.handleRegTokenExpiry)
	            .catch(function (response) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedOut) {
	                console.log('[chatRequestHelper] returning as logged out.');
	                return Promise.reject(response);
	            }
	            return getParams(method, inputParams).then(function (params2) {
	                return requestCommon_1.default('webapi-' + serviceName, utils.getDomain() + url, params2);
	            });
	        })
	            .then(auth.handleSkypeTokenExpiry)
	            .catch(function (response) {
	            return Promise.reject(response);
	        })
	            .then(function (response) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedOut) {
	                console.log('[chatRequestHelper] returning as logged out..');
	                return Promise.reject(response);
	            }
	            return getParams(method, inputParams).then(function (params3) {
	                return handleError(serviceName, response, utils.getDomain() + url, params3);
	            });
	        })
	            .then(auth.processHeaders)
	            .then(function (response) {
	            return utils.handle404Redirect(response, request.bind(_this, serviceName, method, url, inputParams));
	        });
	    });
	};
	/**
	* Accepts uri (without domain)
	*/
	exports.get = function (serviceName, uri, params) {
	    return request(serviceName, 'GET', uri, params);
	};
	/**
	* Accepts uri (without domain)
	*/
	exports.put = function (serviceName, uri, params) {
	    return request(serviceName, 'PUT', uri, params);
	};
	/**
	* Accepts uri (without domain)
	*/
	exports.del = function (serviceName, uri, params) {
	    return request(serviceName, 'DELETE', uri, params);
	};
	/**
	* Accepts uri (without domain)
	*/
	exports.post = function (serviceName, uri, params) {
	    return request(serviceName, 'POST', uri, params);
	};
	exports.parseJson = function (response) {
	    return response.json().then(function (json) {
	        if (response.ok) {
	            return Promise.resolve(json);
	        }
	        return Promise.reject(json);
	    });
	};
	exports.reset = function () {
	    console.log('[chatRequestHelper] resetting ');
	    auth.reset();
	    utils.reset();
	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var registrationToken;
	// registration token should be new for each session (session starts when user opens or refreshes the tab)
	sessionStorage.removeItem('skype|registrationtoken');
	var storedRegToken = sessionStorage.getItem('skype|registrationtoken');
	if (storedRegToken) {
	    try {
	        storedRegToken = JSON.parse(storedRegToken);
	    }
	    catch (e) {
	        console.error(e);
	    }
	}
	if (storedRegToken && storedRegToken.value && storedRegToken.expiry) {
	    registrationToken = storedRegToken;
	}
	else {
	    registrationToken = {
	        value: null,
	        expiry: null
	    };
	}
	exports.handleRegTokenExpiry = function (response) {
	    if (response.status === 403) {
	        registrationToken = {
	            value: null,
	            expiry: null
	        };
	        application_1.default.instance.Storage.setItem('skype|registrationtoken', JSON.stringify(registrationToken));
	        return Promise.reject(response);
	    }
	    return Promise.resolve(response);
	};
	exports.handleSkypeTokenExpiry = function (response) {
	    if (response.status === 401) {
	        application_1.default.instance.SignInManager.logout();
	        return Promise.reject(response);
	    }
	    return Promise.resolve(response);
	};
	exports.processHeaders = function (response) {
	    var regTokenHeader = response.headers.get('set-registrationtoken');
	    if (regTokenHeader) {
	        var regToken = regTokenHeader.match(/registrationToken=(.+); expires=(\d+)/);
	        if (regToken) {
	            registrationToken.value = regToken[1];
	            registrationToken.expiry = parseInt(regToken[2], 10);
	            if (registrationToken.expiry < 10000000000) {
	                registrationToken.expiry *= 1000;
	            }
	            application_1.default.instance.Storage.setItem('skype|registrationtoken', JSON.stringify(registrationToken));
	        }
	    }
	    return response;
	};
	exports.getHeaders = function () {
	    if (registrationToken.expiry < Date.now()) {
	        registrationToken = {
	            value: null,
	            expiry: null
	        };
	    } // TODO: skypetoken expiration
	    var headers = {};
	    if (registrationToken.value) {
	        headers.RegistrationToken = 'registrationToken=' + registrationToken.value;
	        return Promise.resolve(headers);
	    }
	    else {
	        return new Promise(function (resolve, reject) {
	            application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	                headers.Authentication = 'skypetoken=' + token;
	                resolve(headers);
	            }, function () { return reject(); });
	        });
	    }
	};
	exports.reset = function () {
	    registrationToken = {
	        value: null,
	        expiry: null
	    };
	};
	;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config_1 = __webpack_require__(27);
	var app_1 = __webpack_require__(26);
	var identityType_1 = __webpack_require__(29);
	var serviceQosEvent_1 = __webpack_require__(55);
	var parseDomain = function (url) {
	    if (url === void 0) { url = ''; }
	    var match = url.match(/^(https?:.+?\.live\.com\/V\d+\/)/i);
	    if (match) {
	        return match[1];
	    }
	    return null;
	};
	exports.handle404Redirect = function (response, redirectedRequest) {
	    var newLocation = response.headers.get('location');
	    if (!(response.status === 404) || !newLocation || !parseDomain(newLocation)) {
	        return Promise.resolve(response);
	    }
	    config_1.default.CHAT_HOST_URL = parseDomain(newLocation);
	    return redirectedRequest();
	};
	exports.getDomain = function () {
	    if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST
	        && config_1.default.CHAT_GUEST_HOST_URL !== config_1.default.CHAT_HOST_URL) {
	        console.warn('[chatUtils] DUEST domain is redirected to DOGFOOD');
	        serviceQosEvent_1.manager().register('webapi-guestInDogfood', 0, false);
	    }
	    return config_1.default.CHAT_HOST_URL;
	};
	exports.getConversationIdFromUrl = function (url) {
	    var matches = url && url.match(/\/(\d+:[^?/]*)/);
	    return (matches && matches[1]) ? matches[1] : undefined;
	};
	exports.reset = function () {
	    console.log('[chatUtils] resetting to default domain: ' + config_1.default.CHAT_GUEST_HOST_URL);
	    config_1.default.CHAT_HOST_URL = config_1.default.CHAT_GUEST_HOST_URL;
	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	if (typeof Object.assign !== 'function') {
	    Object.assign = function (target) {
	        'use strict';
	        if (target == null) {
	            console.error('Cannot convert undefined or null to object');
	            throw new TypeError();
	        }
	        target = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source != null) {
	                for (var key in source) {
	                    if (Object.prototype.hasOwnProperty.call(source, key)) {
	                        target[key] = source[key];
	                    }
	                }
	            }
	        }
	        return target;
	    };
	}


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(79);
	var polling_1 = __webpack_require__(84);
	/**
	 * This function is a stub. If error need to be propagated higher, then remove it
	 */
	var onErrorStub_removeIfNeeded = function (error) {
	    console.warn('[conversation] ErrorHandler. reason:');
	    console.warn(error);
	};
	exports.fetchRecentConversations = function () {
	    var uri = 'users/ME/conversations?view=msnp24Equivalent&targetType=All';
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchRecents', uri).then(function (response) {
	            return requestHelper.parseJson(response);
	        });
	    }, onErrorStub_removeIfNeeded);
	};
	exports.checkIfConversationExist = function (conversationId) {
	    return new Promise(function (resolve, reject) {
	        exports.fetchRecentConversations().then(function (response) {
	            var existingConversation = response.conversations.filter(function (conversation) {
	                return conversation.id === conversationId;
	            });
	            resolve(existingConversation[0]);
	        });
	    });
	};
	exports.fetchConversation = function (conversationId) {
	    var uri = 'users/ME/conversations/' + conversationId + '?view=msnp24Equivalent&targetType=All';
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchConversation', uri).then(function (response) { return requestHelper.parseJson(response); });
	    }, onErrorStub_removeIfNeeded);
	};
	exports.fetchThread = function (conversationId) {
	    var uri = 'threads/' + conversationId + '?view=msnp24Equivalent';
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchThread', uri).then(function (response) {
	            return requestHelper.parseJson(response);
	        });
	    }, onErrorStub_removeIfNeeded);
	};
	exports.fetchMessages = function (conversationId, pageSize, startTime) {
	    if (pageSize === void 0) { pageSize = 20; }
	    if (startTime === void 0) { startTime = 0; }
	    var uri = 'users/ME/conversations/' + conversationId + '/messages?pageSize=' + pageSize + '&view=msnp24Equivalent&startTime=' + startTime;
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchMessages', uri).then(function (response) { return requestHelper.parseJson(response).then(function (result) {
	            return result;
	        }); });
	    });
	};
	exports.fetchMessagesByLink = function (uri) {
	    uri = uri.substring(uri.indexOf('users/ME/conversations/')); // we need to do this now because helper fills it for us - todo: fix this systematically 
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchMessagesByLink', uri).then(function (response) { return requestHelper.parseJson(response); });
	    }, onErrorStub_removeIfNeeded);
	};
	exports.subscribeConversation = function (conversationId, callback) {
	    return polling_1.Polling.get.subscribeConversation(conversationId, callback);
	};
	exports.unsubscribeConversation = function (conversationId) {
	    return polling_1.Polling.get.unsubscribeConversation(conversationId);
	};
	exports.sendMessage = function (conversationId, messageData) {
	    var url = 'users/ME/conversations/' + conversationId + '/messages';
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.post('sendMessage', url, { body: JSON.stringify(messageData) }).then(function (response) { return requestHelper.parseJson(response); });
	    });
	};
	exports.sendDataToBot = function (id, payload) {
	    var url = 'agents/' + id + '/invoke';
	    return requestHelper.post('invoke', url, { body: JSON.stringify(payload) }).then(function (response) { return requestHelper.parseJson(response); });
	};
	exports.fetchMeProperties = function () {
	    var uri = 'users/ME/properties';
	    return polling_1.Polling.get.authorization.then(function () {
	        return requestHelper.get('fetchMeProperties', uri).then(function (response) { return requestHelper.parseJson(response); });
	    }, onErrorStub_removeIfNeeded);
	};
	exports.reset = function () {
	    return polling_1.Polling.get.reset().then(null, function () {
	        console.warn('[conversation] catching reject from polling');
	    });
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(79);
	var utils_1 = __webpack_require__(81);
	var errorHandler_1 = __webpack_require__(15);
	var application_1 = __webpack_require__(47);
	var exponentianTimeoutRetry = __webpack_require__(85);
	var endpoint = __webpack_require__(86);
	var CancelablePromise_1 = __webpack_require__(87);
	var Polling = (function () {
	    function Polling() {
	        var _this = this;
	        this._interestedConversations = {};
	        this._interestedContacts = {};
	        this._isPolling = false;
	        this.reset = function () {
	            console.log('[polling] resetting');
	            endpoint.stopActivation();
	            _this._interestedConversations = {};
	            _this._interestedContacts = {};
	            _this._stopPolling();
	            _this._authPromise.promise.then(null, function () { });
	            _this._authPromise.cancel();
	            return _this._removeEndpoint();
	        };
	        this.subscribeConversation = function (conversationId, callback) {
	            console.log('[polling] subscribeConversation ' + conversationId);
	            if (_this._interestedConversations[conversationId]) {
	                errorHandler_1.default.throwError(11000, 'Conversation ' + conversationId + ' is already subscribed');
	            }
	            else {
	                _this._interestedConversations[conversationId] = callback;
	            }
	            if (!_this._endpointCreationPromise || _this._endpointCreationPromise.isCanceled) {
	                _this._startPollingSequence();
	            }
	            return _this._endpointCreationPromise.promise;
	        };
	        this.unsubscribeConversation = function (conversationId) {
	            console.log('[polling] unsubscribeConversation ' + conversationId);
	            if (!_this._interestedConversations[conversationId]) {
	                return;
	            }
	            delete _this._interestedConversations[conversationId];
	        };
	        this.subscribeContactPersence = function (contactId, callback) {
	            if (_this._interestedContacts[contactId]) {
	                errorHandler_1.default.throwError(10008, 'Contact ' + contactId + ' is already subscribed');
	            }
	            else {
	                _this._interestedContacts[contactId] = callback;
	            }
	            if (!_this._endpointCreationPromise || _this._endpointCreationPromise.isCanceled) {
	                _this._startPollingSequence();
	            }
	            return _this._endpointCreationPromise.promise;
	        };
	        this.unsubscribeContactPresence = function (contactId) {
	            if (!_this._interestedContacts[contactId]) {
	                return;
	            }
	            delete _this._interestedContacts[contactId];
	        };
	        this._storeEpid = function (locationHeader) {
	            locationHeader = locationHeader || '';
	            var epidMatch = locationHeader.match(/endpoints\/(%7B[\da-z\-]+%7D)/);
	            if (epidMatch && epidMatch[1]) {
	                Polling._epid = epidMatch[1];
	                application_1.default.instance.Storage.setItem('skype|epid', Polling._epid);
	            }
	        };
	        // TODO: handle infinite retry on failures
	        this._createEndpoint = function () {
	            var endpointBody = {
	                endpointFeatures: 'Agent'
	            };
	            var onSuccess = function (response) {
	                _this._storeEpid(response.headers.get('location'));
	                var authResolve = _this._authPromise.resolve.bind(_this._authPromise);
	                endpoint.activationRequest().then(authResolve, authResolve);
	                endpoint.startActivation();
	                return response;
	            };
	            if (Polling._epid) {
	                return requestHelper.put('endpointCreation', 'users/ME/endpoints/' + Polling._epid, { body: JSON.stringify(endpointBody), headers: { 'Content-Type': 'application/json' } }).then(onSuccess);
	            }
	            return requestHelper.post('endpointCreation', 'users/ME/endpoints', { body: JSON.stringify(endpointBody), headers: { 'Content-Type': 'application/json' } }).then(onSuccess);
	        };
	        // TODO: handle failures
	        this._subscribe = function () {
	            // TODO: can be improved to check changes only on 1 contact
	            var requestBody = {
	                channeltype: 'httpLongPoll',
	                interestedResources: [
	                    '/v1/users/ME/conversations/ALL/messages',
	                    '/v1/users/ME/contacts/ALL'
	                ]
	            };
	            return requestHelper.post('endpointSubscription', 'users/ME/endpoints/SELF/subscriptions', { body: JSON.stringify(requestBody) });
	        };
	        // TODO: handle failures
	        this._poll = function (subscriptionId) {
	            if (!application_1.default.instance.isReady) {
	                console.log('[polling] got subscription! starting polling. app is ready!!!!!!!!');
	                application_1.default.instance.isReady = true;
	            }
	            _this._isPolling = true;
	            _this._pollingPromise = new CancelablePromise_1.CancelablePromise(requestHelper.post('polling', 'users/ME/endpoints/SELF/subscriptions/' + subscriptionId + '/poll', { body: JSON.stringify({}) }));
	            _this._pollingPromise.promise.then(function (response) {
	                _this._isPolling = false;
	                response.json().then(function (eventData) {
	                    if (_this._pollingPromise.isCanceled) {
	                        console.log('[polling] aborted *********************');
	                        return;
	                    }
	                    _this._handlePollData(eventData);
	                    if (response.ok && _this._endpointCreationPromise && _this._endpointCreationPromise.status === CancelablePromise_1.PromiseStatus.Resolved) {
	                        _this._poll(subscriptionId);
	                    }
	                    else if (eventData.errorCode === 729) {
	                        // recreate an endpoint
	                        _this._startPollingSequence();
	                    }
	                }).catch(function (error2) {
	                    console.error('[polling] Unable to parse polling result:');
	                    console.log(error2);
	                    // TODO: add retry policy
	                    _this._poll(subscriptionId);
	                }), function (result) {
	                    console.error('[polling] Polling request was rejected');
	                };
	            }, function (error) {
	                if (error && error.isCanceled) {
	                    console.log('[polling] promisedd was cancelled');
	                }
	            });
	        };
	        this._handlePollData = function (eventData) {
	            if (!eventData || !eventData.eventMessages) {
	                return;
	            }
	            var handleNewMessageEvent = function (eventMessage) {
	                //console.log('[polling] handleNewMessageEvent');
	                var eventResource = utils_1.getConversationIdFromUrl(eventMessage.resourceLink), callback = _this._interestedConversations[eventResource];
	                if (!callback) {
	                    return;
	                }
	                // TODO: batch resources instead of calling callback for single resource update within 1 polling?
	                callback(eventMessage.resourceType, eventMessage.resource);
	            };
	            var handleContactPresenceEvent = function (eventMessage) {
	                var contactId = utils_1.getConversationIdFromUrl(eventMessage.resourceLink);
	                if (!contactId) {
	                    return;
	                }
	                contactId = contactId.replace('8:', '');
	                var callback = _this._interestedContacts[contactId];
	                if (!callback) {
	                    return;
	                }
	                callback(eventMessage.resourceType, eventMessage.resource);
	            };
	            eventData.eventMessages.forEach(function (eventMessage) {
	                // console.log('[polling] _handlePollData: ' + eventMessage.resourceType);
	                // console.log(eventMessage);
	                if (eventMessage.resourceType === 'NewMessage') {
	                    handleNewMessageEvent(eventMessage);
	                }
	                else if (eventMessage.resourceType === 'UserPresence') {
	                    handleContactPresenceEvent(eventMessage);
	                }
	            });
	        };
	        this._startPollingSequence = function () {
	            console.log('[polling] _startPollingSequence');
	            if (_this._isPolling) {
	                return Promise.resolve();
	            }
	            _this._pollingRemoved = false;
	            if (_this._authPromise.status !== CancelablePromise_1.PromiseStatus.Pending) {
	                console.log('[polling] recreating auth promise');
	                _this._authPromise = new CancelablePromise_1.CancelablePromise();
	            }
	            console.log('[polling] about to create an endpoint');
	            var onSuccess = function (endpointResponse) {
	                console.log('[polling] _startPollingSequence: new endpoint id = ' + Polling._epid);
	                endpointResponse.json().then(function (endpointJson) {
	                    if (_this._endpointCreationPromise.isCanceled) {
	                        console.log('[polling] endpoint creation was canceled.');
	                        return;
	                    }
	                    if (endpointJson.subscriptions && endpointJson.subscriptions.length > 0) {
	                        _this._poll(endpointJson.subscriptions[0].id);
	                        return;
	                    }
	                    return _this._subscribe().then(function (subscriptionResponse) {
	                        console.log('[polling] sbscription response');
	                        console.log(subscriptionResponse);
	                        if (_this._endpointCreationPromise.isCanceled) {
	                            console.log('[polling] endpoint creation was canceled..');
	                            return;
	                        }
	                        var location = subscriptionResponse.headers.get('location') || '';
	                        var subscriptionId = location.match(/\/(\d+)$/);
	                        if (subscriptionId) {
	                            _this._poll(subscriptionId[1]);
	                        }
	                    }, function (response) {
	                        console.log('[polling] failed to add subscription');
	                        console.log(response);
	                        if (!response) {
	                            return;
	                        }
	                        response.json().then(function (result) {
	                            if (result && result.errorCode === 729) {
	                                // recreate an endpoint
	                                _this._startPollingSequence();
	                            }
	                        }, function () {
	                            console.log('[polling] unable to create a subscription');
	                        });
	                    });
	                });
	            };
	            var onFailure = function () {
	                console.log('[polling] failed to create an endpoint');
	                if (_this._endpointCreationPromise.isCanceled) {
	                    console.log('[polling] endpoint creation was canceled.');
	                    return;
	                }
	                exponentianTimeoutRetry.execute(_this._startPollingSequence.bind(_this));
	            };
	            _this._endpointCreationPromise = new CancelablePromise_1.CancelablePromise(_this._createEndpoint().then(onSuccess, onFailure));
	            return _this._endpointCreationPromise.promise;
	        };
	        Polling._epid = application_1.default.instance.Storage.getItem('skype|epid');
	        this._authPromise = new CancelablePromise_1.CancelablePromise();
	    }
	    Object.defineProperty(Polling, "get", {
	        get: function () {
	            if (!Polling._polling) {
	                Polling._polling = new Polling();
	            }
	            return Polling._polling;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Polling.prototype, "authorization", {
	        get: function () {
	            return this._authPromise.promise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Polling.prototype._removeEndpoint = function () {
	        if (this._pollingRemoved) {
	            return Promise.resolve();
	        }
	        this._pollingRemoved = true;
	        function endpointRemoved() {
	            console.log('[polling] endpoint was removed');
	            requestHelper.reset();
	            Polling._epid = null;
	        }
	        console.log('[polling] removing an endpoint');
	        if (!Polling._epid) {
	            Polling._epid = application_1.default.instance.Storage.getItem('skype|epid');
	        }
	        if (!Polling._epid) {
	            console.log('[polling] there is no need to remove an endpoint');
	            requestHelper.reset();
	            return Promise.resolve();
	        }
	        return requestHelper.del('deleteEndpoint', 'users/ME/endpoints/' + Polling._epid).then(endpointRemoved, endpointRemoved);
	    };
	    Polling.prototype._stopPolling = function () {
	        if (this._endpointCreationPromise) {
	            this._endpointCreationPromise.cancel();
	        }
	        if (this._pollingPromise) {
	            this._pollingPromise.cancel();
	            this._isPolling = false;
	        }
	    };
	    return Polling;
	}());
	exports.Polling = Polling;
	;


/***/ },
/* 85 */
/***/ function(module, exports) {

	"use strict";
	var endpointRetryDelay = null, endpointRetryCount = 1, retryTimeout;
	function clearRetryTimeout() {
	    if (retryTimeout) {
	        clearTimeout(retryTimeout);
	    }
	}
	function execute(callback) {
	    var BASE_DELAY = 1000, MAX_DELAY_LIMIT = 120000, NOISE_FACTOR = 0.5;
	    clearRetryTimeout();
	    if (endpointRetryDelay === null) {
	        endpointRetryDelay = BASE_DELAY;
	    }
	    retryTimeout = setTimeout(callback, endpointRetryDelay + Math.random() * NOISE_FACTOR * endpointRetryDelay); // NOISE_FACTOR is [0..)
	    if (endpointRetryDelay < MAX_DELAY_LIMIT) {
	        endpointRetryCount++;
	        endpointRetryDelay = endpointRetryDelay * endpointRetryCount;
	    }
	}
	exports.execute = execute;
	;
	function reset() {
	    clearRetryTimeout();
	    endpointRetryDelay = null;
	    endpointRetryCount = 1;
	}
	exports.reset = reset;
	;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var requestHelper = __webpack_require__(79);
	var app_1 = __webpack_require__(26);
	var identityType_1 = __webpack_require__(29);
	var signinState_1 = __webpack_require__(71);
	var polling_1 = __webpack_require__(84);
	var ACTIVATION_TIMEOUT = 12 * 1000;
	var DEACTIVATION_TIMEOUT = 15;
	var activationTimeout;
	var activate = function () {
	    console.log('[endpoint] activate ');
	    polling_1.Polling.get.authorization.then(function () {
	        console.log('[endpoint] active: endpoint is authorized');
	        exports.activationRequest().then(function (response) {
	            exports.stopActivation();
	            if (response && response.ok) {
	                console.log('[endpoint] setting timeout');
	                activationTimeout = setTimeout(activate, ACTIVATION_TIMEOUT);
	            }
	        }, function () {
	            // stop timer in case of error
	            exports.stopActivation();
	        });
	    });
	};
	exports.activationRequest = function () {
	    var endpointId = application_1.default.instance.Storage.getItem('skype|epid'), resource = 'users/ME/endpoints/' + endpointId + '/active', options = { payload: { timeout: DEACTIVATION_TIMEOUT } };
	    if (!endpointId && canBeActivated()) {
	        console.warn('Unable to activate an endpoint');
	        return Promise.reject({});
	    }
	    console.log('[endpoint] activating endpoint: ' + new Date());
	    return requestHelper.post('active', resource, { body: JSON.stringify({ timeout: DEACTIVATION_TIMEOUT }) });
	};
	exports.startActivation = function () {
	    if (activationTimeout) {
	        return;
	    }
	    if (!canBeActivated()) {
	        console.log('[endpoint] startActivation: not activating guest endpoint or not sign in user');
	        return;
	    }
	    console.log('[endpoint] startActivation: starting endpoint activation');
	    activate();
	};
	exports.stopActivation = function () {
	    if (activationTimeout) {
	        console.log('[endpoint] clearing endpoint activation timeout');
	        clearTimeout(activationTimeout);
	        activationTimeout = null;
	    }
	};
	function canBeActivated() {
	    return app_1.default.currentUserIdentityType === identityType_1.IdentityType.SKYPE
	        && application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn
	        && application_1.default.instance.isFocused;
	}


/***/ },
/* 87 */
/***/ function(module, exports) {

	"use strict";
	var CancelablePromise = (function () {
	    function CancelablePromise(promise) {
	        var _this = this;
	        this._isCanceled = false;
	        this._status = PromiseStatus.Pending;
	        this.cancel = function () {
	            if (_this._isCanceled) {
	                return;
	            }
	            _this._isCanceled = true;
	            if (_this._isShallow) {
	                _this._status = PromiseStatus.Rejected;
	                _this._reject({ isCanceled: true });
	            }
	        };
	        this._isShallow = !promise;
	        this._promise = new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            if (promise) {
	                promise.then(function (val) {
	                    console.log('[polling] promise result was canceled: ' + _this._isCanceled);
	                    if (_this._isCanceled) {
	                        _this._status = PromiseStatus.Rejected;
	                        reject({ isCanceled: true });
	                    }
	                    else {
	                        _this._status = PromiseStatus.Resolved;
	                        resolve(val);
	                    }
	                }, function (response) {
	                    console.warn('[polling] CancelablePromise was canceled');
	                    _this._status = PromiseStatus.Rejected;
	                    reject(response);
	                });
	                promise.catch(function (error) {
	                    _this._status = PromiseStatus.Rejected;
	                    _this._isCanceled ? reject({ isCanceled: true }) : reject(error);
	                });
	            }
	        });
	    }
	    Object.defineProperty(CancelablePromise.prototype, "promise", {
	        get: function () {
	            return this._promise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CancelablePromise.prototype, "isCanceled", {
	        get: function () {
	            return this._isCanceled;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CancelablePromise.prototype, "status", {
	        get: function () {
	            return this._status;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CancelablePromise.prototype.resolve = function () {
	        if (this._status === PromiseStatus.Resolved) {
	            return;
	        }
	        this._status = PromiseStatus.Resolved;
	        this._resolve();
	    };
	    return CancelablePromise;
	}());
	exports.CancelablePromise = CancelablePromise;
	;
	(function (PromiseStatus) {
	    PromiseStatus[PromiseStatus["Pending"] = 0] = "Pending";
	    PromiseStatus[PromiseStatus["Resolved"] = 1] = "Resolved";
	    PromiseStatus[PromiseStatus["Rejected"] = 2] = "Rejected";
	})(exports.PromiseStatus || (exports.PromiseStatus = {}));
	var PromiseStatus = exports.PromiseStatus;
	;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var polling_1 = __webpack_require__(84);
	exports.subscribeContactPersence = function (contactId, callback) {
	    return polling_1.Polling.get.subscribeContactPersence(contactId, callback);
	};
	exports.unsubscribeContactPresence = function (contactId) {
	    polling_1.Polling.get.unsubscribeContactPresence(contactId);
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var conversationDataEvent_1 = __webpack_require__(65);
	/**
	 * An event being published in the moment user
	 * loaded the conversation in the chat control.
	 *
	 * @export
	 * @class ConversationLoadEvent
	 * @extends {TelemetryEvent}
	 */
	var ConversationLoadEvent = (function (_super) {
	    __extends(ConversationLoadEvent, _super);
	    function ConversationLoadEvent(conversation) {
	        _super.call(this, 'kpi_conversation_load', conversation);
	        /**
	         * Status code of the conversation load operation.
	         * 4xx/5xx - Point to the errors in data fetching.
	         * This is QoS parameter
	         *
	         * @type {number}
	         * @memberOf ConversationLoadEvent
	         */
	        this.status = 200;
	        /**
	         * True - if the data are retrieved from cache,
	         * otherwise false.
	         *
	         * @type {boolean}
	         * @memberOf ConversationLoadEvent
	         */
	        this.cached = false;
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignInEvent
	     */
	    ConversationLoadEvent.prototype.getCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.getProperty(this.status), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('timeLoad', this.getProperty(this.timeToLoad), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('timeRender', this.getProperty(this.timeToRender), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messages', this.messagesCount || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('cached', this.cached, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    ConversationLoadEvent.isAvailable = true;
	    return ConversationLoadEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	exports.ConversationLoadEvent = ConversationLoadEvent;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var config_1 = __webpack_require__(27);
	var app_1 = __webpack_require__(26);
	var tokenUtility_1 = __webpack_require__(70);
	var urlHelper_1 = __webpack_require__(42);
	var packageName_1 = __webpack_require__(39);
	var signinState_1 = __webpack_require__(71);
	var ObservableBase_1 = __webpack_require__(76);
	var application_1 = __webpack_require__(47);
	var reloginContext_1 = __webpack_require__(91);
	var signInEvent_1 = __webpack_require__(92);
	var signOutEvent_1 = __webpack_require__(93);
	var inviteService_1 = __webpack_require__(94);
	var identityType_1 = __webpack_require__(29);
	var sdkMode_1 = __webpack_require__(30);
	__webpack_require__(95);
	var SkypeSignInManager = (function (_super) {
	    __extends(SkypeSignInManager, _super);
	    function SkypeSignInManager() {
	        var _this = this;
	        _super.call(this);
	        this._reloginContext = new reloginContext_1.default(false);
	        this._tokenParser = new tokenUtility_1.default();
	        this.getMeUserName = function () {
	            var promise = new Promise(function (resolve) {
	                _this.getSkypeToken().then(function (skypetoken) {
	                    if (!skypetoken) {
	                        resolve(null);
	                    }
	                    var tokenParser = new tokenUtility_1.default();
	                    resolve(tokenParser.retrieveMeName(skypetoken));
	                });
	            });
	            return promise;
	        };
	        this.login = function (callback) {
	            var signInUrl = config_1.default.LOGIN_PAGE_URL;
	            signInUrl += '?client_id=' + config_1.default.LOGIN_CLIENT_ID;
	            signInUrl += '&redirect_uri=' + encodeURI(config_1.default.ECS.connectPageUrl);
	            signInUrl += '&lang=' + config_1.default.LOCALE;
	            signInUrl += '&response_type=token';
	            _this.showLoginPopup(signInUrl, callback);
	        };
	        // public joinFlow = (joinUrl: string, callback: (token: string) => void): void => {
	        //     let parser = document.createElement('a');
	        //     parser.href = joinUrl;
	        //     let shortId = parser.pathname.substr(1);
	        //     this.showLoginPopup(config.LOGIN_POPUP_URL + shortId, callback);
	        // }
	        this.getGuestToken = function () {
	            if (_this._guestUserPromise) {
	                console.log('REUSE THE GUEST TOKEN');
	                return _this._guestUserPromise;
	            }
	            console.log('GUEST FOR THE FIRST TIME');
	            var dateStart = Date.now();
	            _this._guestUserPromise = inviteService_1.default.getGuestToken('Guest').then(function (response) {
	                app_1.default.currentUserIdentityType = identityType_1.IdentityType.GUEST;
	                console.log('[GUEST TOKEN DATA]::', response);
	                _this.setTokenDataToCache(response.SkypeToken, 86400, true);
	                _this.sendSignedInTelemetry(response.SkypeToken, 'guest', dateStart);
	                return response;
	            }, function (error) {
	                _this.sendSignedInTelemetry(undefined, 'guest', dateStart, error.message);
	                _this.clearUserDataFromCache();
	            });
	            return _this._guestUserPromise;
	        };
	        this.showLoginPopup = function (popUpUrl, callback) {
	            var dateStart = Date.now();
	            var token;
	            var expiresIn;
	            var isLoggedOut = _this.state === signinState_1.SigninState.SignedOut;
	            var onmessage = function (e) {
	                var regex = /(?:access_token=)([\S]*)(?:&)(?:expires_in=)([\d*]*)/g;
	                var tokenDataMatch = regex.exec(e.data);
	                if (tokenDataMatch) {
	                    token = tokenDataMatch[1];
	                    expiresIn = tokenDataMatch[2];
	                }
	                if (!tokenDataMatch) {
	                    token = e.data.token;
	                    expiresIn = Date.now() + 86400 * 1000 + '';
	                }
	                if (!token) {
	                    _this.state = signinState_1.SigninState.SignedOut;
	                    window.removeEventListener('message', onmessage);
	                    return;
	                }
	                if (isLoggedOut) {
	                    _this.setTokenDataToCache(token, parseInt(expiresIn), false);
	                    application_1.default.instance.dispose();
	                    application_1.default.instance.Messaging.fetchMePerson();
	                    application_1.default.instance.restoreLastConversation();
	                }
	                if (!isLoggedOut) {
	                    _this._reloginContext.setContext(true, function () {
	                        console.log('[skypeSigninManager] logging in after logout');
	                        app_1.default.currentUserIdentityType = identityType_1.IdentityType.SKYPE;
	                        _this.setTokenDataToCache(token, parseInt(expiresIn), false);
	                        _this.sendSignedInTelemetry(token, 'popup', dateStart);
	                        if (callback) {
	                            callback(token);
	                        }
	                        return Promise.resolve();
	                    });
	                    _this.logout();
	                }
	                else if (callback) {
	                    callback(token);
	                }
	                window.removeEventListener('message', onmessage);
	            };
	            window.addEventListener('message', onmessage, false);
	            var singInPopup = window.open(popUpUrl, '_blank', config_1.default.LOGIN_POPUP_FEATURES);
	            if (singInPopup && window.focus) {
	                singInPopup.focus();
	            }
	        };
	        this.logout = function (origin) {
	            if (_this.state === signinState_1.SigninState.SigningOut) {
	                console.log('[skypeSigninManager] logout: already signing out');
	                return Promise.resolve();
	            }
	            var dateStart = Date.now();
	            if (!_this._reloginContext.canRelogin) {
	                _this._reloginContext.setContext(app_1.default.activeConversationSdkMode === sdkMode_1.SDKMode.BOT, function () {
	                    return _this.getGuestToken();
	                });
	            }
	            _this.state = signinState_1.SigninState.SigningOut;
	            console.log('[skypeSigninManager] logout: logging out');
	            var signOutUrl = config_1.default.LOGOUT_PAGE_URL;
	            signOutUrl += '?';
	            signOutUrl += '&client_id=' + config_1.default.LOGIN_CLIENT_ID;
	            signOutUrl += '&redirect_uri=' + config_1.default.ECS.connectPageUrl;
	            signOutUrl += '&redirect=true';
	            signOutUrl += '&response_type=token';
	            var singInPopup = window.open(signOutUrl, '_blank', config_1.default.LOGOUT_POPUP_FEATURES);
	            if (singInPopup && window.focus) {
	                singInPopup.focus();
	            }
	            _this.state = signinState_1.SigninState.SignedOut;
	            _this.reset();
	            _this.sendSignedOutTelemetry(origin, dateStart);
	            return Promise.resolve();
	        };
	        this._state = signinState_1.SigninState.SignedOut; // TODO: is this necessary ? default should be already SignedOut
	    }
	    SkypeSignInManager.prototype.getSkypeToken = function () {
	        var _this = this;
	        var tokenData = this.getTokenDataFromCache();
	        if (app_1.default.isGuestOnlyMode && tokenData && !tokenData.isGuest) {
	            tokenData = null;
	        }
	        if (tokenData) {
	            console.log('[SIGNIN]::Using token from the cache');
	            app_1.default.currentUserName = this._tokenParser.retrieveMeName(tokenData.token);
	            app_1.default.currentUserIdentityType = tokenData.isGuest ? identityType_1.IdentityType.GUEST : identityType_1.IdentityType.SKYPE;
	            if (this._signedIn === undefined) {
	                this.sendSignedInTelemetry(tokenData.token, 'cache', Date.now());
	            }
	            this.state = signinState_1.SigninState.SignedIn;
	            return Promise.resolve(tokenData.token);
	        }
	        this.state = signinState_1.SigninState.SigningIn;
	        this.clearUserDataFromCache();
	        return new Promise(function (resolve, reject) {
	            var self = _this;
	            function guestToken() {
	                if (app_1.default.activeConversationSdkMode === sdkMode_1.SDKMode.BOT) {
	                    if (self.state !== signinState_1.SigninState.SignedIn) {
	                        self.state = signinState_1.SigninState.SigningIn;
	                    }
	                    self.getGuestToken()
	                        .then(function (response) {
	                        self.state = signinState_1.SigninState.SignedIn;
	                        resolve(response.SkypeToken);
	                    })
	                        .catch(function () {
	                        self.clearUserDataFromCache();
	                        self.state = signinState_1.SigninState.SignedOut;
	                        reject();
	                    });
	                }
	                else {
	                    self.state = signinState_1.SigninState.SignedOut;
	                    reject();
	                }
	            }
	            function onSuccess(token) {
	                this.state = signinState_1.SigninState.SignedIn;
	                resolve(token);
	            }
	            function onFailure(error) {
	                console.error('[SkypeSigninManager] failed to obtain a st! ' + error);
	                guestToken();
	            }
	            if (_this.state !== signinState_1.SigninState.SignedIn) {
	                _this.state = signinState_1.SigninState.SigningIn;
	            }
	            if (app_1.default.isGuestOnlyMode) {
	                guestToken();
	            }
	            else {
	                _this.silentLogin().then(onSuccess.bind(_this), onFailure.bind(_this));
	            }
	        });
	    };
	    ;
	    Object.defineProperty(SkypeSignInManager.prototype, "state", {
	        get: function () {
	            return this._state;
	        },
	        set: function (value) {
	            if (value !== this._state) {
	                console.log('[signinManager] setting new state ' + value);
	                this._state = value;
	                this.publish('state', value);
	                this._signedIn = this._state === signinState_1.SigninState.SignedIn;
	                this.publish('isSignedIn', this._state === signinState_1.SigninState.SignedIn);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkypeSignInManager.prototype, "isSignedIn", {
	        get: function () {
	            return this._signedIn;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SkypeSignInManager.prototype.sendSignedInTelemetry = function (token, origin, dateStart, errorMessage) {
	        app_1.default.currentUserName = token ? this._tokenParser.retrieveMeName(token) : '';
	        var evtData = new signInEvent_1.SignInEvent();
	        evtData.authOrigin = origin;
	        evtData.status = token ? '200' : '500';
	        evtData.ttc = dateStart ? Date.now() - dateStart : -1;
	        evtData.errorMessage = errorMessage;
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	    };
	    SkypeSignInManager.prototype.sendSignedOutTelemetry = function (origin, dateStart) {
	        var evtData = new signOutEvent_1.SignOutEvent();
	        evtData.origin = origin;
	        evtData.status = 200;
	        // evtData.status = token ? '200' : '500';
	        evtData.ttc = dateStart ? Date.now() - dateStart : -1;
	        // evtData.errorMessage = errorMessage;
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	    };
	    SkypeSignInManager.prototype.getRegistrationToken = function () {
	        var storageValue = application_1.default.instance.Storage.getItem('skype|registrationtoken');
	        var storeRegToken;
	        if (storageValue) {
	            try {
	                storeRegToken = JSON.parse(storageValue);
	            }
	            catch (e) {
	                console.error(e);
	            }
	        }
	        return storeRegToken;
	    };
	    SkypeSignInManager.prototype.getTokenDataFromCache = function () {
	        if (!this._tokenData) {
	            try {
	                this._tokenData = JSON.parse(application_1.default.instance.Storage.getItem(config_1.default.SKYPE_TOKEN_KEY));
	            }
	            catch (e) {
	                this.clearUserDataFromCache();
	                return null;
	            }
	        }
	        if (this._tokenData) {
	            this._tokenData = this.isTokenValid(this._tokenData) ? this._tokenData : null;
	        }
	        return this._tokenData;
	    };
	    SkypeSignInManager.prototype.isTokenValid = function (tokenData) {
	        var regToken = this.getRegistrationToken();
	        if (regToken && !regToken.value) {
	            return false;
	        }
	        if (tokenData.expiresAt < Date.now()) {
	            return false;
	        }
	        if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.SKYPE && app_1.default.activeConversationSdkMode === sdkMode_1.SDKMode.PERSON) {
	            console.log(this.getUserNameFromToken(tokenData.token));
	            if (tokenData.isGuest) {
	                this._tokenData = null;
	                this.clearUserDataFromCache();
	                return false;
	            }
	        }
	        if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST && app_1.default.activeConversationSdkMode === sdkMode_1.SDKMode.BOT) {
	            if (!tokenData.isGuest) {
	                this._tokenData = null;
	                this.clearUserDataFromCache();
	                return false;
	            }
	        }
	        return true;
	    };
	    SkypeSignInManager.prototype.getUserNameFromToken = function (skypetoken) {
	        if (!this._userName) {
	            var tokenParser = new tokenUtility_1.default();
	            this._userName = tokenParser.retrieveMeName(skypetoken);
	        }
	        return this._userName;
	    };
	    SkypeSignInManager.prototype.setTokenDataToCache = function (token, expiresIn, isGuest) {
	        var expiresAt = 0;
	        if (expiresIn) {
	            expiresAt = Date.now() + expiresIn * 1000;
	        }
	        application_1.default.instance.Storage.setItem(config_1.default.SKYPE_TOKEN_KEY, JSON.stringify({ token: token, expiresAt: expiresAt, isGuest: isGuest }));
	    };
	    SkypeSignInManager.prototype.clearUserDataFromCache = function () {
	        console.log('[skypeSigninManager] clearing login data from cache');
	        this._tokenData = null;
	        application_1.default.instance.Storage.removeItem(config_1.default.SKYPE_TOKEN_KEY);
	        application_1.default.instance.Storage.removeItem(config_1.default.SKYPE_REGTOKEN_KEY);
	        application_1.default.instance.Storage.removeItem('skype|epid');
	        application_1.default.instance.Storage.removeItem('skype|hasHistory');
	    };
	    SkypeSignInManager.prototype.silentLogin = function () {
	        var _this = this;
	        if (this.silentLoginPromise) {
	            return this.silentLoginPromise;
	        }
	        var startDate = Date.now();
	        this.silentLoginPromise = new Promise(function (resolve, reject) {
	            var onmessage = function (e) {
	                if (!e.origin || !/a.lw.skype.com/.test(e.origin)) {
	                    return;
	                }
	                var data;
	                var expiresAt;
	                var onResolve = function (token) {
	                    _this.sendSignedInTelemetry(token, 'silent', startDate);
	                    resolve(token);
	                };
	                var onReject = function (error) {
	                    if (data.error === 'invalid_grant') {
	                        _this.clearUserDataFromCache();
	                    }
	                    _this.sendSignedInTelemetry(undefined, 'silent', startDate, data.error);
	                    reject(data.error);
	                };
	                try {
	                    data = JSON.parse(e.data);
	                }
	                catch (err) {
	                    data = e.data;
	                }
	                window.removeEventListener('message', onmessage);
	                if (data.error) {
	                    console.error('[SkypeAuth]::SilentLogin failed [reason]:', data.error);
	                    onReject(data.error);
	                }
	                else if (data.token) {
	                    _this.setTokenDataToCache(data.token, data.expires_in, false);
	                    onResolve(data.token);
	                }
	                else if (data.skypetoken) {
	                    _this.setTokenDataToCache(data.skypetoken, data.expires_in, false);
	                    onResolve(data.skypetoken);
	                }
	                reject(new Error('Neither token nor skypeToken in the response'));
	            };
	            window.addEventListener('message', onmessage, false);
	            console.log('[silentlogin]:: START');
	            var options = {
	                client_id: config_1.default.LOGIN_CLIENT_ID,
	                redirect_uri: urlHelper_1.default.getAbsoluteUrl(packageName_1.PackageName.CONNECT, 'html'),
	                env: 'live'
	            };
	            window.SKYPE.login.Silent.init(options).load();
	        });
	        return this.silentLoginPromise;
	    };
	    SkypeSignInManager.prototype.reset = function () {
	        this.clearUserDataFromCache();
	        this._guestUserPromise = null;
	        this.silentLoginPromise = null;
	        this._signedIn = false;
	        this._tokenData = null;
	        this._userName = null;
	    };
	    Object.defineProperty(SkypeSignInManager.prototype, "reloginContext", {
	        get: function () {
	            return this._reloginContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SkypeSignInManager;
	}(ObservableBase_1.default));
	;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeSignInManager;


/***/ },
/* 91 */
/***/ function(module, exports) {

	"use strict";
	var ReloginContext = (function () {
	    function ReloginContext(toRelogin, callback) {
	        var _this = this;
	        this.execCallback = function () {
	            if (_this._callback) {
	                var bindedReset = _this.reset.bind(_this);
	                return _this._callback().then(bindedReset, bindedReset);
	            }
	            _this.reset();
	            return Promise.resolve();
	        };
	        this.reset = function () {
	            _this._callback = null;
	            _this._toRelogin = false;
	        };
	        this.setContext(toRelogin, callback);
	    }
	    ReloginContext.prototype.setContext = function (toRelogin, callback) {
	        this._toRelogin = toRelogin;
	        this._callback = callback;
	    };
	    Object.defineProperty(ReloginContext.prototype, "canRelogin", {
	        get: function () {
	            return this._toRelogin;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ReloginContext;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ReloginContext;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	/**
	 * Event being published every time a LWC user
	 * goes through the authentication sequence.
	 *
	 * @export
	 * @class SignInEvent
	 * @extends {TelemetryEvent}
	 */
	var SignInEvent = (function (_super) {
	    __extends(SignInEvent, _super);
	    function SignInEvent() {
	        _super.call(this, 'qos_signin_complete');
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignInEvent
	     */
	    SignInEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.status, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('origin', this.authOrigin, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttc', this.ttc >= 0 ? this.ttc : telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorMessage', this.errorMessage || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return SignInEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.SignInEvent = SignInEvent;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	/**
	 * Event being published every time a LWC user
	 * goes through the authentication sequence.
	 *
	 * @export
	 * @class SignOutEvent
	 * @extends {TelemetryEvent}
	 */
	var SignOutEvent = (function (_super) {
	    __extends(SignOutEvent, _super);
	    function SignOutEvent() {
	        _super.call(this, 'qos_signout_complete');
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignOutEvent
	     */
	    SignOutEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.status || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('origin', this.origin || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttc', this.ttc >= 0 ? this.ttc : telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorMessage', this.errorMessage || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return SignOutEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.SignOutEvent = SignOutEvent;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(fetch) {"use strict";
	var config_1 = __webpack_require__(27);
	var InviteService = (function () {
	    function InviteService() {
	    }
	    InviteService.getGuestToken = function (name) {
	        var uri = 'users/guests/lwc';
	        var body = {
	            name: name
	        };
	        return new Promise(function (resolve, reject) {
	            InviteService.request('POST', uri, body).then(function (response) {
	                response.json().then(function (value) {
	                    resolve(value);
	                }).catch(function (error) {
	                    reject(error);
	                });
	            }, function (error) {
	                reject(error);
	            });
	        });
	        // return InviteService.request('POST', uri, body).then((response: Response)=> {
	        // 	return response.json();
	        // });
	    };
	    InviteService.request = function (method, url, payload) {
	        var params = {};
	        params.method = method;
	        params.body = JSON.stringify(payload);
	        // params.mode = 'cors';
	        params.headers = { 'Content-Type': 'application/json' };
	        return fetch(config_1.default.INVITE_HOST_URL + url, params);
	    };
	    return InviteService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = InviteService;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Documentation: https://skype.visualstudio.com/SCONSUMER/_git/client-shared_web_login-lib?path=%2FREADME.md&version=GBmaster&_a=contents
	 */
	(function () {
	    "use strict";
	
	    if (typeof window.SKYPE === "undefined") {
	        window.SKYPE = {};
	    }
	    window.SKYPE.login = window.SKYPE.login || {};
	
	    window.SKYPE.login.Silent = (function() {
	        var loginDomains = {
	            qa: "https://a.qa.lw.skype.net",
	            live: "https://a.lw.skype.com"
	        },
	        endpoint = "/login/silent", // Silent login endpoint uri
	        endpointVersion = "1.0", // Endpoint version
	        iFrameReference = null, // iFrame object reference
	        ancestorElement, // iFrame's ancestor
	        callback, // Callback function
	        response = {}, // Response object
	        timeout = 20000, // Timeout for the call in ms
	        timeoutObj = null, // Timeout reference
	        host = null, // Selected login hostname
	        state = "", // State passed through the silent login
	        eventRegistered = false, // Post message event listener registered
	        processing = false, // Processing the Silent login request
	        logEnabled = null; // Debug logging enabled
	
	        /**
	         * Settings object. will be overriden by init()
	         */
	        var settings = {
	            env: "live",
	            client_id: null,
	            redirect_uri: null
	        };
	
	        /**
	         * Simple debug logger
	         *
	         * @param string message Logged message
	         * @param Object debug Optional debug data
	         *
	         * @return void
	         */
	        var _log = function(message, debug) {
	            if (logEnabled === null) {
	                logEnabled = (window.location.host.match(/^(pre|dev|qa).*\.net$/) || document.cookie.indexOf("debug") > -1 || window.location.search.indexOf("debug") > -1);
	            }
	            if (!logEnabled) {
	                return;
	            }
	            try {
	                if (typeof debug === "object") {
	                    var tokens = [];
	
	                    for (var prop in debug) {
	                        if (prop === "skypetoken") {
	                            // Hide the skypetoken from console
	                            tokens.push(prop + ": " + "<HIDDEN>");
	                        } else {
	                            tokens.push(prop + ": " + JSON.stringify(debug[prop]));
	                        }
	                    }
	
	                    message += " - " + tokens.join(", ");
	                } else if (typeof debug === "string") {
	                    message += " - " + debug;
	                }
	                message = "[silentlogin.js] - " + message;
	                console.log(message);
	            } catch (e) {}
	        };
	
	        /**
	         * Post message event listener
	         *
	         * @return void
	         */
	        var _messageListener = function (e) {
	            _log("Received message from " + e.origin);
	            // Verify the message origin
	            if (!host || e.origin !== host) {
	                return;
	            }
	
	            var data = e.data;
	
	            // If the postMessage sends just a string, try to JSON parse it
	            if (typeof e.data === "string") {
	                try {
	                    data = JSON.parse(e.data);
	                } catch (ex) {}
	            }
	            _log("Message data", data);
	
	            // Verify the message state
	            var receivedState = data.state || null;
	            if (state !== receivedState) {
	                _log("State " + receivedState + " doesn't match the last submitted state " + state);
	                return;
	            }
	            // Response is trusted
	            window.clearTimeout(timeoutObj);
	            // Clone the response data
	            response = {};
	            for (var attr in data) {
	                if (data.hasOwnProperty(attr)) {
	                    response[attr] = data[attr];
	                }
	            }
	
	            _callCallback();
	        };
	
	        /**
	         * Create the silent login iframe and start loading
	         *
	         * @return void
	         */
	        var _createSilentLogin = function(source) {
	            _destroySilentLogin();
	            if (typeof ancestorElement === "undefined") {
	                // Use body as the ancestor, but when it's not available yet, use head instead.
	                // document.head is not available in IE8, so fallback is to get it by tag name.
	                ancestorElement = document.body || document.head || document.getElementsByTagName('head')[0];
	            }
	            iFrameReference = document.createElement("iframe");
	            iFrameReference.frameBorder = 0;
	            iFrameReference.width = "1px";
	            iFrameReference.height = "1px";
	            iFrameReference.style.display = "none";
	            iFrameReference.style.visibility = "hidden";
	            iFrameReference.id = "silentLoginFrame" + Math.floor((Math.random() * 10) + 1);
	            iFrameReference.setAttribute("src", source);
	            ancestorElement.appendChild(iFrameReference);
	            _log("Created iFrame: " + source);
	        };
	
	        /**
	         * Destroy the silent login iframe
	         *
	         * @return void
	         */
	        var _destroySilentLogin = function() {
	            if (iFrameReference) {
	                ancestorElement.removeChild(iFrameReference);
	                iFrameReference = null;
	            }
	        };
	
	        /**
	         * Verify if the provided settings are valid. Initialize the redirect uri if missing.
	         *
	         * @return void
	         */
	        var _validateSettings = function() {
	            if (!settings.client_id) {
	                throw "[silentlogin.js] client_id not initialized. Call init() first.";
	            }
	
	            if (!settings.redirect_uri) {
	                // If redirect_uri not set, use the page location (without parameters)
	                settings.redirect_uri = window.location.protocol + "//" + window.location.host + window.location.pathname;
	            }
	        };
	
	        /**
	         * Check if the browser supports postMessage and JSON.parse
	         *
	         * @return boolean
	         */
	        var _isSupportedBrowser = function() {
	            return ("postMessage" in window) && (typeof JSON === "object" && JSON.parse);
	        };
	
	        /**
	         * Call the callback function and pass the response object to it.
	         *
	         * @return void
	         */
	        var _callCallback = function() {
	            _log("Calling callback function", response);
	
	            // No longer processing request. Unlock.
	            processing = false;
	
	            if (typeof callback === "function") {
	                callback(response);
	            }
	        };
	
	        /**
	         * Handle timeout event and call the callback function.
	         *
	         * @return void
	         */
	        var _handleTimeout = function() {
	            _destroySilentLogin();
	            response = {};
	            response.error = "timeout";
	            _callCallback();
	        };
	
	        /**
	         * Serialize object into query parameters
	         *
	         * @param Object query Object holding the parameters to serialize
	         * @return string Serialized query string
	         */
	        var _createQuery = function(query) {
	            var str = [];
	            for (var k in query) {
	                if (query.hasOwnProperty(k)) {
	                    str.push(encodeURIComponent(k) + "=" + encodeURIComponent(query[k]));
	                }
	            }
	            return str.join("&");
	        };
	
	        /**
	         * Get the iFrame source url
	         *
	         * @return string Frame url
	         */
	        var _getFrameSource = function() {
	            var timestamp = new Date().getTime(),
	                domainMap = loginDomains;
	
	            state = "silentloginsdk_" + timestamp;
	            console.log('getting frame source!');
	            var query = {
	                response_type: "postmessage",
	                client_id: settings.client_id,
	                partner: "999",
	                redirect_uri: settings.redirect_uri,
	                state: state,
	                _accept: endpointVersion,
	                _nc: timestamp
	            };
	
	            host = domainMap[settings.env] || domainMap.live;
	            return host + endpoint + "?" + _createQuery(query);
	        };
	
	        /**
	         * Initialize the Silent login before using it
	         *
	         * Pass in the settings object:
	         * <pre>
	         * {
	         *  env: "<live|qa>", // Skype environment to be used: Live (default), QA. Optional.
	         *  client_id: <client id>, // Client id of your application. Mandatory.
	         *  redirect_uri: <uri>, // Redirect uri of your application. If left empty, will be autodetected from current location. (Optional, recommended)
	         * }
	         * </pre>
	         *
	         * @param Object options Silent login options
	         * @return SKYPE.login.Silent
	         */
	        var init = function(options) {
	            if (typeof options === "object") {
	                options = options || {};
	                // If callback function passed into init method, set it correctly
	                if (options.hasOwnProperty("callback")) {
	                    setCallback(options.callback);
	                }
	                // Copy overrides to settings
	                for (var k in settings) {
	                    if (options.hasOwnProperty(k)) {
	                        settings[k] = options[k];
	                    }
	                }
	            }
	            // Register the message listener
	            if (!eventRegistered) {
	                eventRegistered = true;
	                if (!window.addEventListener) {
	                    window.attachEvent("onmessage", _messageListener);
	                 } else {
	                    window.addEventListener("message", _messageListener, false);
	                 }
	            }
	            return this;
	        };
	
	        /**
	         * Set the callback function, which will be called once we get the result.
	         * Note the function parameter will contain the response object.
	         *
	         * @param function callbackFunction Callback function
	         * @return SKYPE.login.Silent
	         */
	        var setCallback = function(callbackFunction) {
	            if (typeof callbackFunction === "function") {
	                callback = callbackFunction;
	            }
	            return this;
	        };
	
	        /**
	         * Trigger loading the Silent login iFrame. Registered callback will be called once finished.
	         *
	         * @return void
	         */
	        var load = function() {
	            // Prevent multiple simultaneous calls
	            if (processing) {
	                return;
	            }
	            _validateSettings();
	            processing = true;
	            // If this browser doesn't support postMessage, we're done.
	            if (!_isSupportedBrowser()) {
	                response = {error: "unsupported_browser"};
	                _callCallback();
	                return;
	            }
	            // Initialize timer
	            window.clearTimeout(timeoutObj);
	            timeoutObj = window.setTimeout(_handleTimeout, timeout);
	            // Start loading the iFrame
	            _createSilentLogin(_getFrameSource());
	        };
	
	        /**
	         * Get the Skypetoken from response or null if not provided
	         *
	         * @return string|null Skypetoken or null
	         */
	        var getSkypetoken = function() {
	            return response.skypetoken || null;
	        };
	
	        /**
	         * Get the full response object
	         *
	         * @return Object Response object
	         */
	        var getFullResponse = function() {
	            return response;
	        };
	
	        return {
	            init: init,
	            setCallback: setCallback,
	            load: load,
	            getSkypetoken: getSkypetoken,
	            getFullResponse: getFullResponse
	        };
	    }());
	}());

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Person_1 = __webpack_require__(75);
	var application_1 = __webpack_require__(47);
	var main_1 = __webpack_require__(97);
	var ContactType_1 = __webpack_require__(100);
	var personHelper_1 = __webpack_require__(72);
	var SkypeStratusManager = (function () {
	    function SkypeStratusManager() {
	        var _this = this;
	        this.getPerson = function (personId, fetchAvatar) {
	            if (fetchAvatar === void 0) { fetchAvatar = false; }
	            var normalizedPersonId = personHelper_1.default.normalizePersonId(personId);
	            var person = _this.getPersonById(normalizedPersonId);
	            if (person) {
	                if (fetchAvatar && !person.avatarData) {
	                    _this.getAvatarData(person.id, person);
	                }
	                return person;
	            }
	            if (personHelper_1.default.isMePerson(normalizedPersonId)) {
	                return application_1.default.instance.Messaging.mePerson;
	            }
	            person = _this.createPerson(personId);
	            SkypeStratusManager._persons[person.id] = person;
	            _this.getPersonData(person.id, person);
	            if (fetchAvatar) {
	                _this.getAvatarData(person.id, person);
	            }
	            return person;
	        };
	        this.getPersonData = function (personId, person, isMePerson) {
	            if (person.isAgent) {
	                return;
	            }
	            function onSuccess(contactCards) {
	                if (!contactCards || contactCards.length !== 1) {
	                    return;
	                }
	                var contactCard = contactCards[0];
	                person.displayName = contactCard.displayname || contactCard.username;
	            }
	            if (isMePerson) {
	                _this._stratusService.fetchMeProperties().then(onSuccess);
	            }
	            else {
	                _this._stratusService.fetchPerson(personId).then(onSuccess);
	            }
	        };
	        this.getPersonById = function (personId) {
	            return SkypeStratusManager._persons[personHelper_1.default.normalizePersonId(personId)];
	        };
	        this.createPerson = function (personId) {
	            var personIdData = personHelper_1.default.parsePersonId(personId);
	            var person = new Person_1.default(personIdData.id, personIdData.type === ContactType_1.ContactType.Agent);
	            return person;
	        };
	        this.getAvatarData = function (personId, person) {
	            if (person.isAgent) {
	                // TODO: mimat - add proper type to agent
	                application_1.default.instance.AgentsManager.getAgent(personId).then(function (agent) {
	                    if (agent && agent.agentDescriptions && agent.agentDescriptions.length === 1) {
	                        person.avatarData = agent.agentDescriptions[0].userTileExtraLargeUrl;
	                    }
	                    else {
	                    }
	                });
	            }
	            else {
	                person.avatarData = _this._stratusService.getAvatarUrl(personId);
	            }
	        };
	        this._stratusService = new main_1.default();
	    }
	    SkypeStratusManager.prototype.dispose = function () {
	        SkypeStratusManager._persons = {};
	    };
	    SkypeStratusManager._persons = {};
	    return SkypeStratusManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeStratusManager;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(98);
	var config_1 = __webpack_require__(27);
	var StratusService = (function () {
	    function StratusService() {
	    }
	    StratusService.prototype.fetchMeProperties = function () {
	        var uri = 'users/self/profile';
	        return requestHelper.get('fetchMeProfiles', uri);
	    };
	    // TODO: mimat - it is not stratus service, we might need to move it to separate service?
	    StratusService.prototype.fetchPerson = function (id) {
	        var uri = 'users/batch/profiles';
	        var payload = {
	            usernames: [id]
	        };
	        return requestHelper.post('fetchPerson', uri, JSON.stringify(payload));
	    };
	    StratusService.prototype.getAvatarUrl = function (id) {
	        return config_1.default.STRATUS_DOMAIN_HOST_URL + 'users/' + id + '/profile/avatar?returnDefaultImage=true&cacheHeaders=1';
	    };
	    StratusService.prototype.fetchPersons = function (ids) {
	        var uri = 'users/batch/profiles';
	        var payload = {
	            usernames: ids
	        };
	        return requestHelper.post('fetchPersons', uri, JSON.stringify(payload));
	    };
	    return StratusService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StratusService;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(99);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	var request = function (serviceName, url, params) {
	    return requestCommon_1.default('stratus-' + serviceName, config_1.default.STRATUS_DOMAIN_HOST_URL + url, params);
	};
	exports.put = function (serviceName, uri, payload) {
	    return auth.putHeaders().then(function (headers) {
	        var putParams = {};
	        putParams.method = 'PUT';
	        putParams.body = payload;
	        putParams.headers = headers;
	        return request(serviceName, uri, putParams);
	    });
	};
	exports.post = function (serviceName, uri, payload) {
	    return auth.getHeaders().then(function (headers) {
	        headers.append('Content-Type', 'application/json');
	        var postParams = {};
	        postParams.method = 'POST';
	        postParams.body = payload;
	        postParams.headers = headers;
	        return request(serviceName, uri, postParams).then(function (response) {
	            return response.json();
	        });
	    });
	};
	var requestJson = function (serviceName, url, params, customDomain) {
	    return requestCommon_1.default('stratus-' + serviceName, (customDomain || config_1.default.STRATUS_DOMAIN_HOST_URL) + url, params)
	        .then(function (response) {
	        return response.json();
	    });
	};
	var requestData = function (serviceName, url, params, customDomain) {
	    return requestCommon_1.default('stratus-' + serviceName, (customDomain || config_1.default.STRATUS_DOMAIN_HOST_URL) + url, params)
	        .then(function (response) {
	        return response.blob();
	    });
	};
	exports.get = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        return requestJson(serviceName, uri, getParams);
	    });
	};
	exports.getData = function (serviceName, uri) {
	    return auth.getDataHeaders().then(function (headers) {
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        return requestData(serviceName, uri, getParams);
	    });
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var config_1 = __webpack_require__(27);
	exports.putHeaders = function () {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (skypetoken) {
	            var headers = new Headers();
	            headers.append('X-Skypetoken', skypetoken);
	            headers.append('X-Stratus-Caller', config_1.default.SKYPE_CALLER_ID);
	            headers.append('Content-Type', 'application/x-www-form-urlencoded');
	            resolve(headers);
	        });
	    });
	};
	exports.getHeaders = function () {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (skypetoken) {
	            var headers = new Headers();
	            headers.append('X-Skypetoken', skypetoken);
	            headers.append('X-Stratus-Caller', config_1.default.SKYPE_CALLER_ID);
	            resolve(headers);
	        });
	    });
	};
	exports.getProxyHeaders = function () {
	    return new Promise(function (resolve) {
	        var headers = new Headers();
	        headers.append('Accept', 'application/json, text/javascript');
	        headers.append('X-Stratus-Caller', config_1.default.SKYPE_CALLER_ID);
	        resolve(headers);
	    });
	};
	exports.getDataHeaders = function () {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (skypetoken) {
	            var headers = new Headers();
	            headers.append('X-Skypetoken', skypetoken);
	            headers.append('X-Stratus-Caller', config_1.default.SKYPE_CALLER_ID);
	            headers.append('Accept', 'image/webp,image/*,*/*;q=0.8');
	            headers.append('Accept-Encoding', 'gzip, deflate, sdch');
	            resolve(headers);
	        });
	    });
	};
	exports.getDataProxyHeaders = function () {
	    return new Promise(function (resolve) {
	        var headers = new Headers();
	        headers.append('X-Stratus-Caller', config_1.default.SKYPE_CALLER_ID);
	        headers.append('Accept', 'image/webp,image/*,*/*;q=0.8');
	        headers.append('Accept-Encoding', 'gzip, deflate, sdch');
	        resolve(headers);
	    });
	};


/***/ },
/* 100 */
/***/ function(module, exports) {

	"use strict";
	(function (ContactType) {
	    ContactType[ContactType["Skype"] = 8] = "Skype";
	    ContactType[ContactType["Agent"] = 28] = "Agent";
	    ContactType[ContactType["MSA"] = 1] = "MSA";
	})(exports.ContactType || (exports.ContactType = {}));
	var ContactType = exports.ContactType;


/***/ },
/* 101 */
/***/ function(module, exports) {

	"use strict";
	var AppStorage = (function () {
	    function AppStorage() {
	    }
	    AppStorage.setItem = function (key, data) {
	        this.get().setItem(key, data);
	    };
	    AppStorage.removeItem = function (key) {
	        this.get().removeItem(key);
	    };
	    AppStorage.get = function () {
	        if (this._storage) {
	            return this._storage;
	        }
	        if (typeof sessionStorage === 'object') {
	            try {
	                localStorage.setItem('ls', '0');
	                localStorage.removeItem('ls');
	                this._storage = window.sessionStorage;
	            }
	            catch (e) {
	                console.warn('Browser does not support session storage.');
	                this._storage = new MemoryStorage();
	            }
	        }
	        return this._storage;
	    };
	    return AppStorage;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AppStorage;
	var MemoryStorage = (function () {
	    function MemoryStorage() {
	        this._items = {};
	    }
	    Object.defineProperty(MemoryStorage.prototype, "length", {
	        // public length: number;
	        get: function () {
	            return this._items.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MemoryStorage.prototype.clear = function () {
	        this._items.length = 0;
	    };
	    MemoryStorage.prototype.getItem = function (key) {
	        return this._items[key];
	    };
	    MemoryStorage.prototype.key = function (index) {
	        return null;
	    };
	    MemoryStorage.prototype.removeItem = function (key) {
	        delete this._items[key];
	    };
	    MemoryStorage.prototype.setItem = function (key, data) {
	        this._items[key] = data;
	    };
	    return MemoryStorage;
	}());


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var skypeGraphService_1 = __webpack_require__(103);
	var SkypeSearchManager = (function () {
	    function SkypeSearchManager() {
	    }
	    SkypeSearchManager.prototype.searchSkypeContacts = function (searchKey) {
	        var _this = this;
	        var searchResult = new Array();
	        return new Promise(function (resolve, reject) {
	            _this.getGraphService().fetchProfiles(searchKey).then(function (profilesData) {
	                var current = 0;
	                profilesData.results.forEach(function (profileData) {
	                    var profile = profileData.nodeProfileData;
	                    if (profile.skypeId.indexOf('8:') !== 0) {
	                        profile.skypeId = '8:' + profile.skypeId;
	                    }
	                    application_1.default.instance.ContactsManager.isPersonContact(profile.skypeId).then(function (value) {
	                        current++;
	                        var match = MatchType.NOMATCH;
	                        if (value) {
	                            match = profilesData.results.length > 1 ? MatchType.SOFT : MatchType.STRONG;
	                        }
	                        var searchProfileInfo = {
	                            skypeid: profile.skypeId,
	                            name: profile.name,
	                            avatar: profile.avatarUrl,
	                            match: match
	                        };
	                        searchResult.push(searchProfileInfo);
	                        if (current === profilesData.results.length) {
	                            resolve(searchResult);
	                        }
	                    });
	                });
	            });
	        });
	    };
	    SkypeSearchManager.prototype.getGraphService = function () {
	        if (!this._graphService) {
	            this._graphService = new skypeGraphService_1.default();
	        }
	        return this._graphService;
	    };
	    return SkypeSearchManager;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeSearchManager;
	(function (MatchType) {
	    MatchType[MatchType["STRONG"] = 1] = "STRONG";
	    MatchType[MatchType["SOFT"] = 2] = "SOFT";
	    MatchType[MatchType["NOMATCH"] = 3] = "NOMATCH";
	})(exports.MatchType || (exports.MatchType = {}));
	var MatchType = exports.MatchType;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var requestHelper = __webpack_require__(104);
	var guid_1 = __webpack_require__(33);
	var config_1 = __webpack_require__(27);
	var SkypeGraphService = (function () {
	    function SkypeGraphService() {
	    }
	    SkypeGraphService.prototype.fetchProfiles = function (searchstring) {
	        var uri = 'search/v1.1/namesearch/swx/?requestid=' + this.getAppDataParams() + '&locale=' + config_1.default.LOCALE + '&searchstring=' + searchstring;
	        return requestHelper.get('namesearch', uri);
	    };
	    SkypeGraphService.prototype.getAppDataParams = function () {
	        return [config_1.default.APPNAME, config_1.default.ECS.version, guid_1.default.createNew()].join('-');
	    };
	    return SkypeGraphService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeGraphService;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var auth = __webpack_require__(105);
	var config_1 = __webpack_require__(27);
	var requestCommon_1 = __webpack_require__(52);
	var requestJson = function (serviceName, url, params) {
	    return requestCommon_1.default('skypegraph-' + serviceName, config_1.default.SKYPE_GRAPH_URL + url, params);
	};
	exports.get = function (serviceName, uri) {
	    return auth.getHeaders().then(function (headers) {
	        var getParams = {};
	        getParams.method = 'GET';
	        getParams.headers = headers;
	        getParams.cache = 'no-cache';
	        return requestJson(serviceName, uri, getParams).then(function (response) {
	            return response.json();
	        });
	    });
	};


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	exports.getHeaders = function () {
	    return new Promise(function (resolve) {
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            var headers = new Headers();
	            headers.append('x-skypetoken', token);
	            resolve(headers);
	        });
	    });
	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../customTypings/skype.d.ts" />
	/// <reference path="../../typings/index.d.ts" />
	"use strict";
	var audioPlayer_1 = __webpack_require__(107);
	var viewModel_1 = __webpack_require__(119);
	var file_1 = __webpack_require__(123);
	var gifPlayer_1 = __webpack_require__(124);
	var image_1 = __webpack_require__(125);
	var message_1 = __webpack_require__(126);
	var swift_1 = __webpack_require__(127);
	var adaptiveCard_1 = __webpack_require__(145);
	var videoPlayer_1 = __webpack_require__(152);
	var welcome_1 = __webpack_require__(153);
	var translate_1 = __webpack_require__(155);
	var keyboardNavigation_1 = __webpack_require__(156);
	// import SuggestionList from '../ui/chatInput/suggestionList/suggestionList';
	// import SuggestionListVM from '../ui/chatInput/suggestionList/viewModel';
	var ComponentsRegistrar = (function () {
	    function ComponentsRegistrar() {
	    }
	    ComponentsRegistrar.register = function (chatDataConfig) {
	        if (this.isInitialized) {
	            return;
	        }
	        keyboardNavigation_1.default.register();
	        // ko.components.register('suggestion-list', {
	        //     viewModel: {
	        //         createViewModel: (params: {suggestionList: SuggestionList}, componentInfo?: { element: Element }) => {
	        //             return new SuggestionListVM(params, componentInfo.element);
	        //         }
	        //     },
	        //     template: require('text!../ui/chatInput/suggestionList/template.html'),
	        //     synchronous: true
	        // });
	        ko.components.register('contactrequest', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new viewModel_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(159),
	            synchronous: true
	        });
	        ko.components.register('usermessage', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new message_1.default(params.message, params.conversation, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(160),
	            synchronous: true
	        });
	        ko.components.register('systemmessage', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new message_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(160),
	            synchronous: true
	        });
	        ko.components.register('swiftcard', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new swift_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(161),
	            synchronous: true
	        });
	        ko.components.register('adaptivecard', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new adaptiveCard_1.default(params.content, params.conversation, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(162),
	            synchronous: true
	        });
	        ko.components.register('lwcimage', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new image_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(163),
	            synchronous: true
	        });
	        ko.components.register('lwcfile', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new file_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(164),
	            synchronous: true
	        });
	        ko.components.register('welcome', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new welcome_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(165),
	            synchronous: true
	        });
	        ko.components.register('translate', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new translate_1.default(params.message, params.conversation);
	                }
	            },
	            template: __webpack_require__(166),
	            synchronous: true
	        });
	        ko.components.register('audioplayer', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new audioPlayer_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(167),
	            synchronous: true
	        });
	        ko.components.register('videoplayer', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new videoPlayer_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(168),
	            synchronous: true
	        });
	        ko.components.register('gifplayer', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new gifPlayer_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(169),
	            synchronous: true
	        });
	        ko.components.register('icon-hexagon', { template: SkypeWebControl.Assets.SVG.IconHexagon });
	        ko.components.register('skype-logo', { template: SkypeWebControl.Assets.SVG.SkypeLogo });
	        ko.components.register('icon-sent', { template: SkypeWebControl.Assets.SVG.IconSent });
	        ko.components.register('icon-close', { template: SkypeWebControl.Assets.SVG.IconClose });
	        ko.components.register('icon-arrow', { template: SkypeWebControl.Assets.SVG.iconArrow });
	        ko.components.register('icon-file-img', { template: SkypeWebControl.Assets.SVG.iconFileUpload });
	        ko.components.register('icon-download', { template: SkypeWebControl.Assets.SVG.iconDownload });
	        ko.components.register('icon-error', { template: SkypeWebControl.Assets.SVG.iconError });
	        ko.components.register('icon-mute', { template: SkypeWebControl.Assets.SVG.iconMute });
	        ko.components.register('icon-unmute', { template: SkypeWebControl.Assets.SVG.iconUnmute });
	        ko.components.register('icon-exit-fullscreen', { template: SkypeWebControl.Assets.SVG.iconExitFullscreen });
	        ko.components.register('icon-enter-fullscreen', { template: SkypeWebControl.Assets.SVG.iconEnterFullscreen });
	        ko.components.register('icon-play', { template: SkypeWebControl.Assets.SVG.iconPlay });
	        ko.components.register('icon-pause', { template: SkypeWebControl.Assets.SVG.iconPause });
	        ko.components.register('icon-group-avatar', { template: SkypeWebControl.Assets.SVG.iconGroupAvatar });
	        ko.components.register('icon-globus', { template: SkypeWebControl.Assets.SVG.iconGlobus });
	        ko.components.register('icon-call-start', { template: SkypeWebControl.Assets.SVG.iconCallStart });
	        ko.components.register('icon-open-url', { template: SkypeWebControl.Assets.SVG.iconOpenUrl });
	        ko.components.register('icon-speaker', { template: SkypeWebControl.Assets.SVG.iconSpeaker });
	        this.isInitialized = true;
	    };
	    ComponentsRegistrar.unregister = function () {
	        // ko.components.unregister('suggestion-list');
	        ko.components.unregister('contactrequest');
	        ko.components.unregister('usermessage');
	        ko.components.unregister('systemmessage');
	        ko.components.unregister('swiftcard');
	        ko.components.unregister('adaptivecard');
	        ko.components.unregister('lwcimage');
	        ko.components.unregister('lwcfile');
	        ko.components.unregister('icon-hexagon');
	        ko.components.unregister('icon-sent');
	        ko.components.unregister('icon-file-img');
	        ko.components.unregister('icon-close');
	        ko.components.unregister('icon-download');
	        ko.components.unregister('icon-error');
	        ko.components.unregister('icon-mute');
	        ko.components.unregister('icon-unmute');
	        ko.components.unregister('icon-exit-fullscreen');
	        ko.components.unregister('icon-enter-fullscreen');
	        ko.components.unregister('icon-play');
	        ko.components.unregister('icon-pause');
	        ko.components.unregister('audioplayer');
	        ko.components.unregister('videoplayer');
	        ko.components.unregister('gifplayer');
	        ko.components.unregister('icon-group-avatar');
	        ko.components.unregister('icon-call-start');
	        ko.components.unregister('icon-open-url');
	        this.isInitialized = false;
	    };
	    ComponentsRegistrar.isInitialized = false;
	    return ComponentsRegistrar;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ComponentsRegistrar;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var basePlayer_1 = __webpack_require__(108);
	var enums_1 = __webpack_require__(118);
	var controller_1 = __webpack_require__(110);
	var AudioPlayerVM = (function (_super) {
	    __extends(AudioPlayerVM, _super);
	    function AudioPlayerVM(_params, _element) {
	        var _this = this;
	        _super.call(this, _element, _params.thumbnail, enums_1.SwiftCardContentType.audio);
	        this._params = _params;
	        this._element = _element;
	        this.shouldShowCover = function () {
	            return !!(_this.coverImage && _this.coverImage.url);
	        };
	        this.onAudioEnded = function () {
	            _this.isPlaying(false);
	        };
	        this.dispose = function () {
	            _this.showCoverImage.dispose();
	        };
	        this.coverImage = _params.coverImage;
	        this.media = _params.media;
	        this.autoplay = _params.autoplay;
	        this.id = _params.messageId;
	        this.showLoadingInfo = _params.showLoadingInfo || true;
	        this.showCoverImage = ko.computed(this.shouldShowCover);
	        controller_1.default.instance.registerPlayer(this);
	    }
	    return AudioPlayerVM;
	}(basePlayer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AudioPlayerVM;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var mediaLoader_1 = __webpack_require__(109);
	var controller_1 = __webpack_require__(110);
	var i18n_1 = __webpack_require__(112);
	var browser_1 = __webpack_require__(41);
	var document = browser_1.default.getDocument();
	var MINUTE = 60;
	var progressBarClass = '.timeline';
	var BasePlayer = (function (_super) {
	    __extends(BasePlayer, _super);
	    function BasePlayer(element, thumbnail, type) {
	        var _this = this;
	        _super.call(this, element, thumbnail);
	        this.isInFullscreen = ko.observable(false);
	        this.play = function () {
	            _this.queuedForPlaying = !_this.isLoaded;
	            if (_this.isLoaded) {
	                _this.player.play();
	                _this.isPlaying(true);
	                _this.onLoadedActionHandler = null;
	            }
	            else {
	                _this.onLoadedActionHandler = _this.play;
	            }
	        };
	        this.pause = function () {
	            _this.queuedForPlaying = false;
	            _this.touchedByUser = false;
	            if (_this.isLoaded) {
	                _this.player.pause();
	                _this.isPlaying(false);
	                _this.onLoadedActionHandler = null;
	            }
	            else {
	                _this.onLoadedActionHandler = _this.pause;
	            }
	        };
	        this.togglePlay = function () {
	            if (_this.player.ended) {
	            }
	            if (_this.player.paused || _this.player.ended) {
	                controller_1.default.instance.pauseAll();
	                _this.play();
	                _this.mute(false);
	                _this.touchedByUser = true;
	            }
	            else {
	                _this.pause();
	            }
	        };
	        this.getCurrentTime = function () {
	            return _this.formatTime(_this.currentTimeUnformatted());
	        };
	        this.getTotalTime = function () {
	            return _this.formatTime(_this.totalTimeUnformatted());
	        };
	        this.getPlayButtonText = function () {
	            var key = _this.isPlaying() ? 'mediaPlayer_pause' : 'mediaPlayer_play';
	            return i18n_1.default.fetch(key);
	        };
	        this.formatTime = function (time) {
	            var seconds = Math.round(time), minutes = 0;
	            function addLeadingZero(time) {
	                if (time.toString().length === 1) {
	                    return '0' + time;
	                }
	                return time;
	            }
	            if (seconds >= MINUTE) {
	                minutes = parseInt((seconds / MINUTE).toString());
	                seconds = seconds - minutes * MINUTE;
	            }
	            return addLeadingZero(minutes) + ':' + addLeadingZero(seconds);
	        };
	        this.onTimeUpdated = function () {
	            _this.currentTimeUnformatted(_this.player.currentTime);
	            _this.setProgress(_this.currentTimeUnformatted() / _this.totalTimeUnformatted() * 100);
	        };
	        this.isQueuedForPlaying = function () {
	            return _this.queuedForPlaying;
	        };
	        this.triggeredByUser = function () {
	            return _this.touchedByUser;
	        };
	        this.dispose = function () {
	            _this.currentTime.dispose();
	            _this.totalTime.dispose();
	            _this.playButtonText.dispose();
	            controller_1.default.instance.removePlayer(_this.id);
	        };
	        this.isPlaying = ko.observable(false);
	        this.currentProgress = ko.observable('0');
	        this.progressBar = element.querySelector(progressBarClass);
	        this.currentTime = ko.computed(this.getCurrentTime);
	        this.totalTime = ko.computed(this.getTotalTime);
	        this.playButtonText = ko.computed(this.getPlayButtonText);
	        this.mediaType = type;
	    }
	    BasePlayer.prototype.mute = function (val) {
	        if (this.player && this.isMuted) {
	            this.player.muted = val;
	            this.isMuted(val);
	        }
	    };
	    ;
	    BasePlayer.prototype.setProgress = function (percentage) {
	        this.currentProgress('width: ' + percentage + '%');
	    };
	    BasePlayer.prototype.updateRange = function (event) {
	        var progressBarWidth = this.progressBar.offsetWidth, progressBarXOffset = this.progressBar.getBoundingClientRect().left, xPosition = event.pageX - progressBarXOffset;
	        this.player.currentTime = this.player.duration * (xPosition / progressBarWidth);
	        this.setProgress(xPosition / progressBarWidth * 100);
	    };
	    BasePlayer.prototype.onTimelineClick = function (data, event) {
	        this.updateRange(event);
	    };
	    BasePlayer.prototype.onHandleStartDrag = function (data, event) {
	        this.updateRange(event);
	        function onMouseUp() {
	            document.removeEventListener('mousemove', this.updateRange);
	            document.removeEventListener('mouseup', this.onMouseUp);
	        }
	        document.addEventListener('mousemove', this.updateRange);
	        document.addEventListener('mouseup', onMouseUp);
	    };
	    return BasePlayer;
	}(mediaLoader_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BasePlayer;


/***/ },
/* 109 */
/***/ function(module, exports) {

	"use strict";
	var playerClass = '.player';
	var MediaLoader = (function () {
	    function MediaLoader(element, _thumbnail) {
	        var _this = this;
	        this.element = element;
	        this._thumbnail = _thumbnail;
	        this.canPlay = ko.observable();
	        this.isLoading = ko.observable();
	        this.failed = ko.observable();
	        this.onMetadataLoaded = function () {
	            _this.isLoaded = true;
	            if (_this.onLoadedActionHandler) {
	                _this.onLoadedActionHandler();
	            }
	            _this.currentTimeUnformatted(_this.player.currentTime);
	            _this.totalTimeUnformatted(_this.player.duration);
	        };
	        this.canPlay = ko.observable(false);
	        this.isLoading = ko.observable(true);
	        this.failed = ko.observable(false);
	        this.isLoaded = false;
	        this.currentTimeUnformatted = ko.observable(0);
	        this.totalTimeUnformatted = ko.observable(0);
	        this.player = element.querySelector(playerClass);
	        this.thumbnail = ko.observable('');
	        if (_thumbnail) {
	            this.loadThumbnail(_thumbnail);
	        }
	    }
	    MediaLoader.prototype.loadThumbnail = function (src) {
	        var img = new Image();
	        img.onload = this.setThumbnail.bind(this, src);
	        img.src = src;
	    };
	    MediaLoader.prototype.setThumbnail = function (src) {
	        this.thumbnail(src);
	    };
	    MediaLoader.prototype.onError = function (e) {
	        this.canPlay(false);
	        this.isLoading(false);
	        this.failed(true);
	    };
	    MediaLoader.prototype.onReady = function () {
	        this.canPlay(true);
	        this.isLoading(false);
	    };
	    return MediaLoader;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MediaLoader;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var common_1 = __webpack_require__(111);
	var MediaController = (function () {
	    function MediaController() {
	        var _this = this;
	        this.players = function () {
	            return _this._players;
	        };
	        this.terminatedMedia = function () {
	            return _this._terminatedMedia;
	        };
	        this.pauseAll = function () {
	            _this.players().forEach(function (item) {
	                item.pause();
	                if (item.mute) {
	                    item.mute(true);
	                }
	            });
	        };
	        this.registerPlayer = function (playerVM) {
	            var item = {
	                id: playerVM.id,
	                isInFullscreen: playerVM.isInFullscreen,
	                pause: playerVM.pause,
	                play: playerVM.play,
	                mute: playerVM.mute ? playerVM.mute : null,
	                type: playerVM.mediaType,
	                isPlaying: playerVM.isPlaying,
	                autoplay: playerVM.autoplay,
	                isQueuedForPlaying: playerVM.isQueuedForPlaying,
	                triggeredByUser: playerVM.triggeredByUser
	            };
	            this.players().push(item);
	        };
	        this.removePlayer = function (id) {
	            var item = _this.getPlayerById(id);
	            if (item) {
	                _this.players().splice(_this.players().indexOf(item), 1);
	            }
	        };
	        this.getPlayerById = function (id) {
	            var player;
	            _this.players().forEach(function (item) {
	                if (item.id === id) {
	                    player = item;
	                }
	            });
	            return player;
	        };
	        this.getPlayingMedia = function () {
	            var player;
	            _this.players().forEach(function (item) {
	                if (item.isPlaying() || item.isQueuedForPlaying()) {
	                    player = item;
	                }
	            });
	            return player;
	        };
	        this.onEnteringFullscreen = function (player) {
	            _this.playerInFullscreen = player;
	        };
	        this.onLeavingFullscreen = function () {
	            _this.playerInFullscreen = null;
	        };
	        //TODO Add automatic playback of focused media player - it should react on scrolling / new message played so only most visible item is played
	        /*public onVisibleViewPortChanged = (visibleMessages: any) => {
	            let playingMedia: Player = this.getPlayingMedia(),
	                lastVisibleMedia: Player;
	    
	            if (playingMedia && playingMedia.triggeredByUser()) {
	                return;
	            }
	    
	            visibleMessages.sort(function (m1: any, m2: any) {return m1 - m2;});
	    
	            for (var i = visibleMessages.length - 1; i >= 0; i--) {
	                var media = this.getPlayerById(visibleMessages[i]);
	                if (media && media.type === SwiftCardContentType.video && media.autoplay) {
	                    lastVisibleMedia = media;
	                    break;
	                }
	            }
	    
	            if (lastVisibleMedia && lastVisibleMedia === playingMedia) {
	                return;
	            }
	    
	            if (playingMedia) {
	                playingMedia.pause();
	            }
	    
	            if (lastVisibleMedia) {
	                lastVisibleMedia.play();
	    
	                if (lastVisibleMedia.mute) {
	                    lastVisibleMedia.mute(true);
	                }
	            }
	        };*/
	        this.onFullScreenChanged = function (event) {
	            var isFromYtPlayer = event.target &&
	                (event.target.id && event.target.id.substring(0, 7) === 'yt_msg_'
	                    || event.target.activeElement && event.target.activeElement.id && event.target.activeElement.id.substring(0, 7) === 'yt_msg_');
	            if (isFromYtPlayer) {
	                return;
	            }
	            var isFullScreen = !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
	            if (_this.playerInFullscreen) {
	                _this.playerInFullscreen.isInFullscreen(isFullScreen);
	            }
	            if (!isFullScreen) {
	                _this.onLeavingFullscreen();
	            }
	        };
	        this.onClientBlurred = function () {
	            var playingMedia = _this.getPlayingMedia();
	            if (playingMedia && !playingMedia.triggeredByUser()) {
	                playingMedia.pause();
	                _this.terminatedMedia = playingMedia;
	            }
	        };
	        this.onClientFocused = function () {
	            if (_this.terminatedMedia && _this.terminatedMedia().play) {
	                _this.terminatedMedia().play();
	                _this.terminatedMedia = null;
	            }
	        };
	        this.dispose = function () {
	            document.removeEventListener('webkitfullscreenchange', _this.onFullScreenChanged);
	            document.removeEventListener('mozfullscreenchange', _this.onFullScreenChanged);
	            document.removeEventListener('MSFullscreenChange', _this.onFullScreenChanged);
	            document.removeEventListener('fullscreenchange', _this.onFullScreenChanged);
	            document.removeEventListener(common_1.default.events.browser.BLUR, _this.onClientBlurred);
	            document.removeEventListener(common_1.default.events.browser.FOCUS, _this.onClientFocused);
	        };
	    }
	    Object.defineProperty(MediaController, "instance", {
	        get: function () {
	            if (!MediaController._instance) {
	                MediaController._instance = new MediaController();
	                MediaController._instance.init();
	            }
	            return MediaController._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MediaController.prototype.init = function () {
	        this._players = [];
	        this._terminatedMedia = null;
	        document.addEventListener('webkitfullscreenchange', this.onFullScreenChanged);
	        document.addEventListener('mozfullscreenchange', this.onFullScreenChanged);
	        document.addEventListener('MSFullscreenChange', this.onFullScreenChanged);
	        document.addEventListener('fullscreenchange', this.onFullScreenChanged);
	        document.addEventListener(common_1.default.events.browser.BLUR, this.onClientBlurred);
	        document.addEventListener(common_1.default.events.browser.FOCUS, this.onClientFocused);
	    };
	    Object.defineProperty(MediaController.prototype, "playerInFullscreen", {
	        get: function () {
	            return this._playerInFullscreen;
	        },
	        set: function (player) {
	            if (player === this._playerInFullscreen) {
	                return;
	            }
	            this._playerInFullscreen = player;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    ;
	    return MediaController;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MediaController;


/***/ },
/* 111 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    events: {
	        browser: {
	            FOCUS: 'focus',
	            BLUR: 'blur',
	            KEYDOWN: 'keydown',
	            MOUSEDOWN: 'mousedown',
	            MOUSEUP: 'mouseup',
	        },
	    },
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var default_1 = __webpack_require__(113);
	var resources_1 = __webpack_require__(114);
	var loader_1 = __webpack_require__(115);
	var plurals_1 = __webpack_require__(116);
	var cultureInfo_1 = __webpack_require__(117);
	var config_1 = __webpack_require__(27);
	var errorHandler_1 = __webpack_require__(15);
	var I18N = (function () {
	    function I18N() {
	        this._initialized = false;
	        resources_1.default.set(default_1.default);
	        plurals_1.default.init(config_1.default.LOCALE);
	    }
	    I18N.prototype.init = function (lang) {
	        var _this = this;
	        if (!lang) {
	            lang = config_1.default.LOCALE;
	        }
	        this.lang = cultureInfo_1.default.getLocale(lang.toLowerCase());
	        this._initialized = true;
	        if (this.lang === config_1.default.LOCALE) {
	            return Promise.resolve();
	        }
	        return loader_1.default.load(config_1.default.ECS.lwcPath + '/out/resources/i18n', this.lang).then(function () {
	            plurals_1.default.init(_this.lang);
	            return {};
	        }, function () {
	            _this.lang = config_1.default.LOCALE;
	            plurals_1.default.init(_this.lang);
	            return {};
	        });
	    };
	    I18N.prototype.fetch = function (key, params) {
	        if (!this._initialized) {
	            errorHandler_1.default.throwError(10500, 'You need to initialize I18N before using it');
	        }
	        if (typeof params !== 'undefined' && typeof params.count !== 'undefined') {
	            key += plurals_1.default.getPluralSuffix(params.count);
	        }
	        var translation = this._getKeyValueText(key);
	        return this._replaceParams(translation, params);
	    };
	    I18N.prototype._replaceParams = function (translation, params) {
	        if (params === void 0) { params = {}; }
	        for (var param in params) {
	            if (params.hasOwnProperty(param)) {
	                var replacement = params[param].toString();
	                translation = translation.replace(new RegExp('{' + param + '}', 'g'), replacement);
	            }
	        }
	        return translation;
	    };
	    I18N.prototype._getKeyValueText = function (key) {
	        var resources = resources_1.default.get();
	        if (resources && resources[key]) {
	            return resources[key];
	        }
	        return key;
	    };
	    return I18N;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new I18N();


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(82);
	var Translations = (function () {
	    function Translations() {
	        // chatInput
	        this.area_text_insertText = 'Type to chat...';
	        this.action_button_send = 'Send';
	        // addMember
	        this.joinedConversation = '<b>{participant}</b> joined this conversation';
	        this.wasAdded = '{participant} added {contact} to this conversation';
	        // deleteMemeber
	        this.hasLeftConversation = '{participant} has left this conversation';
	        this.wasRemoved = '{participant} has removed {removedParticipant} from this conversation';
	        // historyDisclosed
	        this.historyClosed = 'Conversation history was closed by {participant}';
	        this.historyDisclosed = 'Conversation history was disclosed by {participant}';
	        // joiningEnabled
	        this.joiningEnabled = '{participant} enabled joining this conversation';
	        this.joiningDisabled = '{participant} disabled joining this conversation';
	        // pictureUpdate
	        this.threadPictureUpdated = '{participant} has changed the conversation picture';
	        // roleUpdate
	        this.roleUpdated = '{who} updated {whom}\'s role to {role}';
	        // topicUpdate
	        this.topicUpdated = '{participant} has changed the conversation topic to \'{topic}\'';
	        // contactRequest
	        this.contact_request = 'Contact request sent.';
	        this.waiting_for_reply = 'Waiting for a reply...';
	        // terms of use
	        this.ms_service_privacy_agreement = 'By chatting below, you agree to the <a href="{linkMSA}" target="_blank">Microsoft services agreement</a> and <a href="{linkPrivacy}" target="_blank">privacy statement</a>.';
	        // swiftCard
	        this.s_title = 'Sent you a message';
	        this.s_card = 'Card';
	        this.s_cards = 'Cards';
	        this.s_receipt = 'Receipt';
	        this.s_signIn = 'Sign in';
	        this.s_groupTitle = '{displayName} sent a message';
	        this.s_vat = 'Vat';
	        this.s_tax = 'Tax';
	        this.s_totalPrice = 'Total';
	        this.s_unsupported = 'Eek! We can\'t show this card on the version of Skype you have.';
	        this.s_unsupported_button = 'Next';
	        this.s_showImageTitle = 'Enlarge image';
	        this.s_signInTitle = 'Connect';
	        this.s_prevCard = 'Show previous';
	        this.s_nextCard = 'Show next';
	        this.s_showAll = 'Show all';
	        this.s_showLess = 'Show less';
	        this.mediaPlayer_play = "Play";
	        this.mediaPlayer_pause = "Pause";
	        this.videoPlayer_fullscreen = "Fullscreen";
	        this.videoPlayer_exitFullscreen = "Exit fullscreen";
	        this.videoPlayer_button_mute = "Mute";
	        this.videoPlayer_button_unmute = "Unmute";
	        this.accessibility_swift_action_prefix = "Click to {swiftAction}";
	        // signIn
	        this.sign_in_welcome = 'Please sign in to start chatting';
	        this.sign_in = 'Sign in';
	        this.sign_in_cancel = 'Cancel';
	        // preview
	        this.header_preview = 'Preview';
	        this.header_termsOfUse = 'Terms of use';
	        this.header_privacyPolicy = 'Privacy policy';
	        // messageList
	        this.m_unsupported = 'This message type is currently not supported. Go to http://web.skype.com for full experience';
	        // builderPage
	        this.builder_botId = 'Bot Id';
	        this.builder_buttonStyle = 'Button style';
	        this.builder_buttonImage = 'Button image';
	        this.builder_buttonLabel = 'Button label';
	        this.builder_colors = 'Colors';
	        this.builder_message = 'Message';
	        this.builder_theme = 'Theme';
	        this.builder_code = 'Code';
	        this.builder_copy = 'Copy';
	        this.builder_light = 'Light';
	        this.builder_dark = 'Dark';
	        this.sending = 'Sending';
	        this.sent = 'Sent';
	        this.failed = 'Failed';
	    }
	    return Translations;
	}());
	var translations = Object.assign({}, new Translations());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = translations;
	;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(82);
	var errorHandler_1 = __webpack_require__(15);
	var I18NResources = (function () {
	    function I18NResources() {
	    }
	    I18NResources.prototype.set = function (destination) {
	        this._throwIfFalsy(destination);
	        this._resourcesLocation = destination;
	    };
	    ;
	    I18NResources.prototype.merge = function (destination) {
	        this._throwIfFalsy(destination);
	        Object.assign(this._resourcesLocation, destination);
	    };
	    ;
	    I18NResources.prototype.get = function () {
	        return this._resourcesLocation;
	    };
	    I18NResources.prototype._throwIfFalsy = function (destination) {
	        if (!destination) {
	            errorHandler_1.default.throwError(10009, '[i18n / resources] Specified destination for localizations resources is not reachable');
	        }
	    };
	    return I18NResources;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new I18NResources();


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var resources_1 = __webpack_require__(114);
	var Loader = (function () {
	    function Loader() {
	    }
	    Loader.prototype.load = function (url, lang) {
	        var translationUrl = url + '/' + lang + '/strings.js';
	        var scriptElement = document.createElement('script');
	        if (!window.Skype) {
	            window.Skype = {
	                WebExperience: {
	                    setTranslations: function (translations) {
	                        resources_1.default.merge(translations);
	                    }
	                }
	            };
	        }
	        else if (!window.Skype.WebExperience) {
	            window.Skype.WebExperience = {
	                setTranslations: function (translations) {
	                    resources_1.default.merge(translations);
	                }
	            };
	        }
	        scriptElement.src = translationUrl;
	        scriptElement.type = 'text/javascript';
	        scriptElement.async = true;
	        return new Promise(function (resolve, reject) {
	            scriptElement.onload = resolve;
	            scriptElement.onerror = reject;
	            document.getElementsByTagName('head')[0].appendChild(scriptElement);
	        });
	    };
	    return Loader;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Loader();


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorHandler_1 = __webpack_require__(15);
	var PLURAL_SUFFIX_ONE = '', PLURAL_SUFFIX_FEW = '_few', PLURAL_SUFFIX_MANY = '_many', locale = {
	    af: 'af',
	    am: 'am',
	    ar: 'ar',
	    as: 'as',
	    az: 'az',
	    be: 'be',
	    bg: 'bg',
	    bn: 'bn',
	    bs: 'bs',
	    chr: 'chr',
	    ca: 'ca',
	    cs: 'cs',
	    cy: 'cy',
	    da: 'da',
	    de: 'de',
	    el: 'el',
	    en: 'en',
	    es: 'es',
	    et: 'et',
	    eu: 'eu',
	    fa: 'fa',
	    fi: 'fi',
	    fil: 'fil',
	    fr: 'fr',
	    ga: 'ga',
	    gd: 'gd',
	    gl: 'gl',
	    gu: 'gu',
	    ha: 'ha',
	    he: 'he',
	    hi: 'hi',
	    hr: 'hr',
	    hu: 'hu',
	    hy: 'hy',
	    id: 'id',
	    ig: 'ig',
	    is: 'is',
	    it: 'it',
	    iw: 'iw',
	    ja: 'ja',
	    ka: 'ka',
	    kk: 'kk',
	    km: 'km',
	    kn: 'kn',
	    ko: 'ko',
	    kok: 'kok',
	    ku: 'ku',
	    ky: 'ky',
	    lb: 'lb',
	    lt: 'lt',
	    lv: 'lv',
	    mi: 'mi',
	    ml: 'ml',
	    mn: 'mn',
	    mr: 'mr',
	    ms: 'ms',
	    ne: 'ne',
	    nl: 'nl',
	    nn: 'nn',
	    nb: 'nb',
	    no: 'no',
	    nso: 'nso',
	    or: 'or',
	    pa: 'pa',
	    pl: 'pl',
	    prs: 'prs',
	    pt_br: 'pt-br',
	    pt_pt: 'pt-pt',
	    qps: 'qps',
	    qut: 'qut',
	    quz: 'quz',
	    ro: 'ro',
	    ru: 'ru',
	    rw: 'rw',
	    sd: 'sd',
	    si: 'si',
	    sl: 'sl',
	    sk: 'sk',
	    sq: 'sq',
	    sr: 'sr',
	    sv: 'sv',
	    sw: 'sw',
	    ta: 'ta',
	    te: 'te',
	    tg: 'tg',
	    th: 'th',
	    ti: 'ti',
	    tk: 'tk',
	    tn: 'tn',
	    tr_tr: 'tr-tr',
	    tt: 'tt',
	    ug: 'ug',
	    uk: 'uk',
	    ur: 'ur',
	    uz: 'uz',
	    vi: 'vi',
	    wo: 'wo',
	    xh: 'xh',
	    yo: 'yo',
	    zh: 'zh',
	    zu: 'zu'
	}, pluralRulesGroup = {
	    group0: {
	        // Using FEW instead of ONE: some strings have hardcoded "1" instead of "{COUNT}",
	        // so when you tried to get eg. 3 months in tr, you got str_replace('{COUNT}', 3, '1 ay') -> 1 ay
	        // FEW is translated correctly even in languages without plural
	        // 1 is still translated as ONE, because master "string" and "string.few" sometimes differ a lot
	        languages: [locale.ja, locale.id, locale.ko, locale.tr_tr, locale.vi, locale.zh, locale.az, locale.ig,
	            locale.fa, locale.ka, locale.km, locale.kn, locale.ms, locale.prs, locale.th, locale.tt, locale.ug, locale.wo, locale.yo]
	    },
	    group1: {
	        // Simple plural. Germanic (Danish, Dutch, English, Welsh, German, Norwegian, Swedish),
	        // Finno-Ugric (Estonian, Finnish, Hungarian), Language isolate Basque (Basque), Latin/Greek (Greek), Semitic (Hebrew),
	        // Romanic (Italian, Portuguese, Spanish, Catalan)
	        languages: [locale.bg, locale.ca, locale.cy, locale.da, locale.de, locale.el, locale.en, locale.es, locale.et, locale.fi, locale.he,
	            locale.hu, locale.it, locale.iw, locale.nb, locale.nl, locale.no, locale.pt_pt, locale.qps, locale.sv, locale.af,
	            locale.as, locale.bn, locale.chr, locale.eu, locale.gl, locale.gu, locale.ha, locale.hy, locale.is,
	            locale.kk, locale.kok, locale.ku, locale.ky, locale.lb, locale.mi, locale.ml, locale.mn, locale.mr,
	            locale.ne, locale.nn, locale.or, locale.pa, locale.qut, locale.quz, locale.rw, locale.sd, locale.si,
	            locale.sq, locale.sw, locale.ta, locale.te, locale.tk, locale.tn, locale.ur, locale.xh, locale.zu]
	    },
	    group2: {
	        // French plural. Romanic (French, Portuguese (Brazil))
	        languages: [locale.fr, locale.pt_br, locale.am, locale.fil, locale.hi, locale.nso, locale.tg, locale.ti, locale.uz]
	    },
	    group3: {
	        // 0,1,2,3,4,5 toes. Baltic (Latvian)
	        languages: [locale.lv]
	    },
	    group4: {
	        // Celtic (Scottish Gaelic), Skype-simplified version to support only 3 plural forms, normally has 4 forms
	        languages: [locale.gd]
	    },
	    group5: {
	        // Romanic (Romanian)
	        languages: [locale.ro]
	    },
	    group6: {
	        // Baltic (Lithuanian)
	        languages: [locale.lt]
	    },
	    group7: {
	        // Slavic (Croatian, Serbian, Russian, Ukrainian, Slovenian)
	        languages: [locale.ru, locale.uk, locale.hr, locale.sr, locale.be, locale.bs, locale.sl]
	    },
	    group8: {
	        // Slavic (Slovak, Czech)
	        languages: [locale.cs, locale.sk]
	    },
	    group9: {
	        // Slavic (Polish)
	        languages: [locale.pl]
	    },
	    group11: {
	        // Celtic (Irish Gaelic), Skype-simplified version to support only 3 plural forms, normally it has 5 forms
	        languages: [locale.ga]
	    },
	    group12: {
	        // Semitic (Arabic), Skype-simplified version to support only 3 plural forms, normally AR has 6. 1: single, 2: few, everything else: many.
	        languages: [locale.ar]
	    }
	};
	var Plurals = (function () {
	    function Plurals() {
	    }
	    Plurals.prototype.init = function (myLocale) {
	        if (myLocale === void 0) { myLocale = locale.en; }
	        var normalizedLocale = myLocale.replace('-', '_').toLowerCase();
	        if (!locale[normalizedLocale]) {
	            var splits = normalizedLocale.split('_');
	            if (splits.length === 1) {
	                errorHandler_1.default.throwError(10050, 'Unsupported language:' + myLocale);
	            }
	            normalizedLocale = splits[0];
	        }
	        this._currentLocale = normalizedLocale;
	    };
	    Plurals.prototype.getPluralSuffix = function (value) {
	        var rule, selectedRule = null, suffix = '';
	        for (rule in pluralRulesGroup) {
	            if (pluralRulesGroup[rule].languages.indexOf(this._currentLocale) !== -1) {
	                selectedRule = rule;
	            }
	        }
	        switch (selectedRule) {
	            case 'group0':
	                // Using FEW instead of ONE: some strings have hardcoded "1" instead of "{COUNT}",
	                // so when you tried to get eg. 3 months in tr, you got str_replace('{COUNT}', 3, '1 ay') -> 1 ay
	                // FEW is translated correctly even in languages without plural
	                // 1 is still translated as ONE, because master "string" and "string.few" sometimes differ a lot
	                suffix = value === 1 ? PLURAL_SUFFIX_ONE : PLURAL_SUFFIX_FEW;
	                break;
	            case 'group1':
	                // Simple plural. Germanic (Danish, Dutch, English, German, Norwegian, Swedish),
	                // Finno-Ugric (Estonian, Finnish, Hungarian), Language isolate Basque (Basque), Latin/Greek (Greek), Semitic (Hebrew),
	                // Romanic (Italian, Portuguese, Spanish, Catalan)
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : PLURAL_SUFFIX_MANY);
	                break;
	            case 'group2':
	                // French plural. Romanic (French, Portuguese (Brazil))
	                suffix = (value > 1 ? PLURAL_SUFFIX_MANY : PLURAL_SUFFIX_ONE);
	                break;
	            case 'group3':
	                // Baltic (Latvian)
	                suffix = (value % 10 === 1 && value % 100 !== 11 ? PLURAL_SUFFIX_ONE : (value === 0 ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group4':
	                // Celtic (Scottish Gaelic), Skype-simplified version to support only 3 plural forms, normally has 4 forms
	                suffix = (value === 1 || value === 11 ? PLURAL_SUFFIX_ONE : ((value === 2 || value === 12) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group5':
	                // Romanic (Romanian)
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : ((value === 0 || (value % 100 > 0 && value % 100 < 20)) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group6':
	                // Baltic (Lithuanian)
	                suffix = (value % 10 === 1 && value % 100 !== 11 ? PLURAL_SUFFIX_ONE : (value % 10 >= 2 && (value % 100 < 10 || value % 100 >= 20) ? PLURAL_SUFFIX_MANY : PLURAL_SUFFIX_FEW));
	                break;
	            // Slavic (Croatian, Serbian, Russian, Ukrainian)
	            case 'group7':
	                suffix = (value % 10 === 1 && value % 100 !== 11 ? PLURAL_SUFFIX_ONE : (value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group8':
	                // Slavic (Slovak, Czech)
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : ((value >= 2 && value <= 4) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group9':
	                // Slavic (Polish)
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : ((value % 10 >= 2 && value % 10 <= 4 && (value % 100 < 10 || value % 100 >= 20)) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group11':
	                // Celtic (Irish Gaelic), Skype-simplified version to support only 3 plural forms, normally it has 5 forms
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : ((value >= 2 && value <= 10) ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            case 'group12':
	                // Semitic (Arabic), Skype-simplified version to support only 3 plural forms, normally AR has 6. 1: single, 2: few, everything else: many.
	                suffix = (value === 1 ? PLURAL_SUFFIX_ONE : (value === 2 ? PLURAL_SUFFIX_FEW : PLURAL_SUFFIX_MANY));
	                break;
	            default:
	                suffix = '';
	                break;
	        }
	        return suffix;
	    };
	    return Plurals;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Plurals();


/***/ },
/* 117 */
/***/ function(module, exports) {

	"use strict";
	var MAPPINGS = [
	    { language: 'am', defaultLocale: 'am-et' },
	    { language: 'ar', defaultLocale: 'ar-sa' },
	    { language: 'bg', defaultLocale: 'bg-bg' },
	    { language: 'bn', defaultLocale: 'bn-in' },
	    { language: 'ca', defaultLocale: 'ca-es' },
	    { language: 'cs', defaultLocale: 'cs-cz' },
	    { language: 'cy', defaultLocale: 'cy-gb' },
	    { language: 'da', defaultLocale: 'da-dk' },
	    { language: 'de', defaultLocale: 'de-de' },
	    { language: 'el', defaultLocale: 'el-gr' },
	    { language: 'en', defaultLocale: 'en-us' },
	    { language: 'es', defaultLocale: 'es-es' },
	    { language: 'et', defaultLocale: 'et-ee' },
	    { language: 'eu', defaultLocale: 'eu-es' },
	    { language: 'fa', defaultLocale: 'fa-ir' },
	    { language: 'fi', defaultLocale: 'fi-fl' },
	    { language: 'fil', defaultLocale: 'fil-ph' },
	    { language: 'fr', defaultLocale: 'fr-fr' },
	    { language: 'gl', defaultLocale: 'gl-es' },
	    { language: 'gu', defaultLocale: 'gu-in' },
	    { language: 'he', defaultLocale: 'he-il' },
	    { language: 'hi', defaultLocale: 'hi-in' },
	    { language: 'hr', defaultLocale: 'hr-hr' },
	    { language: 'hu', defaultLocale: 'hu-hu' },
	    { language: 'id', defaultLocale: 'id-id' },
	    { language: 'is', defaultLocale: 'is-is' },
	    { language: 'it', defaultLocale: 'it-it' },
	    { language: 'ja', defaultLocale: 'ja-jp' },
	    { language: 'kk', defaultLocale: 'kk-kz' },
	    { language: 'kn', defaultLocale: 'kn-in' },
	    { language: 'ko', defaultLocale: 'ko-kr' },
	    { language: 'ku', defaultLocale: 'ku-arab-iq' },
	    { language: 'lt', defaultLocale: 'lt-lt' },
	    { language: 'lv', defaultLocale: 'lv-lv' },
	    { language: 'ml', defaultLocale: 'ml-in' },
	    { language: 'mr', defaultLocale: 'mr-in' },
	    { language: 'ms', defaultLocale: 'ms-my' },
	    { language: 'nb', defaultLocale: 'nb-no' },
	    { language: 'nl', defaultLocale: 'nl-nl' },
	    { language: 'nn', defaultLocale: 'nn-no' },
	    { language: 'or', defaultLocale: 'or-in' },
	    { language: 'pl', defaultLocale: 'pl-pl' },
	    { language: 'pt', defaultLocale: 'pt-PT' },
	    { language: 'pt-pt', defaultLocale: 'pt-PT' },
	    { language: 'pt-br', defaultLocale: 'pt-BR' },
	    { language: 'ro', defaultLocale: 'ro-ro' },
	    { language: 'ru', defaultLocale: 'ru-ru' },
	    { language: 'sk', defaultLocale: 'sk-sk' },
	    { language: 'sl', defaultLocale: 'sl-si' },
	    { language: 'sr', defaultLocale: 'sr-cyrl-rs' },
	    { language: 'sr-cyrl', defaultLocale: 'sr-cyrl-rs' },
	    { language: 'sr-latn', defaultLocale: 'sr-latn-rs' },
	    { language: 'sv', defaultLocale: 'sv-se' },
	    { language: 'sw', defaultLocale: 'sw-ke' },
	    { language: 'ta', defaultLocale: 'ta-in' },
	    { language: 'te', defaultLocale: 'te-in' },
	    { language: 'th', defaultLocale: 'th-th' },
	    { language: 'tr', defaultLocale: 'tr-tr' },
	    { language: 'uk', defaultLocale: 'uk-ua' },
	    { language: 'ur', defaultLocale: 'ur-pk' },
	    { language: 'vi', defaultLocale: 'vi-vn' },
	    { language: 'zh', defaultLocale: 'zh-cn' },
	    { language: 'zh-hant', defaultLocale: 'zh-tw' },
	    { language: 'zh-cht', defaultLocale: 'zh-tw' },
	    { language: 'zh-hk', defaultLocale: 'zh-tw' },
	    { language: 'zh-mo', defaultLocale: 'zh-tw' }
	];
	var CultureInfo = (function () {
	    function CultureInfo() {
	    }
	    CultureInfo.prototype.getLocale = function (lang) {
	        var mapping = this.getMappingByLanguage(lang);
	        if (mapping) {
	            return mapping.defaultLocale;
	        }
	        else {
	            var index = lang.lastIndexOf('-');
	            if (index > -1) {
	                return this.getLocale(lang.substring(0, index));
	            }
	        }
	        return lang;
	    };
	    ;
	    CultureInfo.prototype.getMappingByLanguage = function (lang) {
	        for (var i = 0; i < MAPPINGS.length; i++) {
	            if (MAPPINGS[i].language.toLowerCase() === lang.toLowerCase()) {
	                return MAPPINGS[i];
	            }
	        }
	        return null;
	    };
	    return CultureInfo;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new CultureInfo();


/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";
	(function (SwiftCardType) {
	    SwiftCardType[SwiftCardType["unknown"] = 0] = "unknown";
	    SwiftCardType[SwiftCardType["card"] = 1] = "card";
	    SwiftCardType[SwiftCardType["carousel"] = 2] = "carousel";
	    SwiftCardType[SwiftCardType["signin"] = 3] = "signin";
	    SwiftCardType[SwiftCardType["receipt"] = 4] = "receipt";
	    SwiftCardType[SwiftCardType["adaptive"] = 5] = "adaptive";
	})(exports.SwiftCardType || (exports.SwiftCardType = {}));
	var SwiftCardType = exports.SwiftCardType;
	(function (SwiftCardContentType) {
	    SwiftCardContentType[SwiftCardContentType["unknown"] = 0] = "unknown";
	    SwiftCardContentType[SwiftCardContentType["hero"] = 1] = "hero";
	    SwiftCardContentType[SwiftCardContentType["thumb"] = 2] = "thumb";
	    SwiftCardContentType[SwiftCardContentType["receipt"] = 3] = "receipt";
	    SwiftCardContentType[SwiftCardContentType["signin"] = 4] = "signin";
	    SwiftCardContentType[SwiftCardContentType["video"] = 5] = "video";
	    SwiftCardContentType[SwiftCardContentType["audio"] = 6] = "audio";
	    SwiftCardContentType[SwiftCardContentType["animation"] = 7] = "animation";
	    SwiftCardContentType[SwiftCardContentType["actionImage"] = 8] = "actionImage";
	    SwiftCardContentType[SwiftCardContentType["adaptive"] = 9] = "adaptive";
	})(exports.SwiftCardContentType || (exports.SwiftCardContentType = {}));
	var SwiftCardContentType = exports.SwiftCardContentType;
	(function (SwiftCardActionType) {
	    SwiftCardActionType[SwiftCardActionType["unknown"] = 0] = "unknown";
	    SwiftCardActionType[SwiftCardActionType["unsupported"] = 1] = "unsupported";
	    SwiftCardActionType[SwiftCardActionType["openUrl"] = 2] = "openUrl";
	    SwiftCardActionType[SwiftCardActionType["imBack"] = 3] = "imBack";
	    SwiftCardActionType[SwiftCardActionType["signin"] = 4] = "signin";
	    SwiftCardActionType[SwiftCardActionType["call"] = 5] = "call";
	    SwiftCardActionType[SwiftCardActionType["showImage"] = 6] = "showImage";
	    SwiftCardActionType[SwiftCardActionType["payment"] = 7] = "payment";
	})(exports.SwiftCardActionType || (exports.SwiftCardActionType = {}));
	var SwiftCardActionType = exports.SwiftCardActionType;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var i18n_1 = __webpack_require__(112);
	var baseMessage_1 = __webpack_require__(120);
	var sdkMode_1 = __webpack_require__(30);
	var CHAT_ENABLED_SUBSCRIPTION = 'isChatEnabled';
	var ContactRequest = (function (_super) {
	    __extends(ContactRequest, _super);
	    function ContactRequest(message, conversation) {
	        var _this = this;
	        _super.call(this, message, conversation);
	        this.titleKey = ko.observable();
	        this.messageKey = ko.observable();
	        this.showContactRequest = ko.observable();
	        this.dispose = function () {
	            if (_this._conversation) {
	                _this._conversation.unsubscribe(CHAT_ENABLED_SUBSCRIPTION, _this._onChatEnabledChanged);
	            }
	        };
	        this._onChatEnabledChanged = function (value) {
	            if (_this._conversation.sdkMode === sdkMode_1.SDKMode.BOT) {
	                _this.showContactRequest(false);
	                return;
	            }
	            _this.showContactRequest(!value);
	        };
	        this._conversation = conversation;
	        this.titleKey(i18n_1.default.fetch('contact_request'));
	        this.messageKey(i18n_1.default.fetch('waiting_for_reply'));
	        this.showContactRequest(false);
	        this._conversation.subscribe(CHAT_ENABLED_SUBSCRIPTION, this._onChatEnabledChanged);
	    }
	    return ContactRequest;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContactRequest;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Direction_1 = __webpack_require__(121);
	var dateUtility_1 = __webpack_require__(122);
	var application_1 = __webpack_require__(47);
	var personHelper_1 = __webpack_require__(72);
	var sdkMode_1 = __webpack_require__(30);
	var BaseMessage = (function () {
	    function BaseMessage(message, conversation) {
	        var _this = this;
	        this.message = message;
	        this.conversation = conversation;
	        this.messageFromMe = false;
	        this.author = ko.observable();
	        this.showAuthor = false;
	        this.dispose = function () {
	            if (_this.message.senderId && _this.updateDisplayName && _this._isSkypeRelated) {
	                var person = application_1.default.instance.StratusManager.getPerson(_this.message.senderId);
	                person.unsubscribe('displayName', _this.updateDisplayName);
	            }
	        };
	        this.updateDisplayName = function () {
	            var person = application_1.default.instance.StratusManager.getPerson(_this.message.senderId);
	            _this.author(person.displayName);
	        };
	        this._isSkypeRelated = conversation.sdkMode !== sdkMode_1.SDKMode.DIRECT_LINE_TOKEN;
	        this.timestamp = dateUtility_1.default.toStringMesssageDate(this.message.timestamp.getTime());
	        if (message.type !== 'SystemMessage') {
	            if (this.message.senderId) {
	                this.author = ko.observable(this.message.senderId);
	                if (this._isSkypeRelated) {
	                    var person = application_1.default.instance.StratusManager.getPerson(this.message.senderId);
	                    person.subscribe('displayName', this.updateDisplayName);
	                }
	                this.showAuthor = !message.senderId && conversation.isGroup();
	                this.messageFromMe = !!message.senderId && personHelper_1.default.isMePerson(personHelper_1.default.normalizePersonId(message.senderId));
	            }
	            else {
	                this.messageFromMe = !!message.senderId || message.direction === Direction_1.Direction.Outgoing;
	            }
	        }
	        this.showAuthor = !this.messageFromMe && conversation.isGroup();
	    }
	    return BaseMessage;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BaseMessage;


/***/ },
/* 121 */
/***/ function(module, exports) {

	"use strict";
	(function (Direction) {
	    Direction[Direction["Incoming"] = 0] = "Incoming";
	    Direction[Direction["Outgoing"] = 1] = "Outgoing";
	})(exports.Direction || (exports.Direction = {}));
	var Direction = exports.Direction;


/***/ },
/* 122 */
/***/ function(module, exports) {

	"use strict";
	var DateUtility = (function () {
	    function DateUtility() {
	    }
	    DateUtility.toStringMesssageDate = function (timestamp) {
	        var date = new Date(timestamp);
	        var lastMidnight = new Date();
	        lastMidnight.setHours(0, 0, 0, 0);
	        if (date.getTime() > lastMidnight.getTime()) {
	            return date.toLocaleTimeString(navigator.language, { hour: '2-digit', minute: '2-digit' });
	        }
	        return date.toLocaleTimeString(navigator.language, { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
	    };
	    return DateUtility;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DateUtility;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(fetch) {"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var baseMessage_1 = __webpack_require__(120);
	var amsAuth = __webpack_require__(62);
	var FileMessageVM = (function (_super) {
	    __extends(FileMessageVM, _super);
	    function FileMessageVM(message, conversation) {
	        var _this = this;
	        _super.call(this, message, conversation);
	        this.url = ko.observable();
	        this.originalName = ko.observable();
	        this.downloaded = ko.observable(false);
	        // TODO: t-marud: handle unsafe files?
	        // TODO: javesely: we should unify url / auth helpers as they seem to be very similar for various serivces
	        this.downloadFile = function () {
	            amsAuth.getHeaders().then(function (headers) {
	                var putParams = {};
	                putParams.method = 'GET';
	                putParams.headers = headers;
	                return fetch(_this.url() + '/views/original', putParams);
	            }).then(function (response) {
	                return response.blob();
	            }).then(function (blob) {
	                if (navigator.msSaveOrOpenBlob) {
	                    navigator.msSaveOrOpenBlob(blob, _this.originalName());
	                }
	                else {
	                    var urlCreator = window.URL || window.webkitURL;
	                    var url = urlCreator.createObjectURL(blob);
	                    var downloadEl = document.createElement('a');
	                    document.body.appendChild(downloadEl);
	                    downloadEl.href = url;
	                    downloadEl.setAttribute("download", _this.originalName());
	                    downloadEl.click();
	                    urlCreator.revokeObjectURL(url);
	                }
	                _this.downloaded(true);
	            });
	        };
	        this.computeDisplaySize = function (size) {
	            var units = ['Bytes', 'KB', 'MB', 'GB'];
	            var unit = 0;
	            while (size >= 1024) {
	                size /= 1024;
	                unit++;
	            }
	            return Math.floor(size) + ' ' + units[unit];
	        };
	        this.computeCssClasses = function () {
	            var css = {
	                done: _this.downloaded()
	            };
	            css[_this.extension] = true;
	            return css;
	        };
	        this.parse = function () {
	            var documentId = _this.retrieveDocumentId(_this.message.content);
	            if (!documentId || documentId === null) {
	                // TODO: mimat - handle this case properly - display error message
	                return;
	            }
	            var sizeMatcher = _this.message.content.match(/<LwcFile[^>]*?\ssize=\"([\d]+?)\"/i);
	            _this.size = sizeMatcher ? parseInt(sizeMatcher[1]) || 0 : 0;
	            var nameMatcher = _this.message.content.match(/<LwcFile[^>]*?\soriginalName=\"([^"]+?)\"/i);
	            _this.originalName(nameMatcher ? nameMatcher[1] : null);
	            var urlMatcher = _this.message.content.match(/<LwcFile[^>]*?\surl=\"([^"]+?)\"/i);
	            _this.url(urlMatcher ? urlMatcher[1] : null);
	        };
	        this.retrieveDocumentId = function (content) {
	            var idMatcher = content.match(/<LwcFile[^>]*?\surl=\"([^"]+?)\"/i);
	            if (!idMatcher) {
	                return null;
	            }
	            var wholeUrl = idMatcher[1];
	            return wholeUrl.substr(wholeUrl.lastIndexOf('/') + 1);
	        };
	        this.parse();
	        this.type = message.type;
	        this.displaySize = this.computeDisplaySize(this.size);
	        this.extension = (this.originalName() || '').match(/[0-9a-z]+$/i)[0].toLowerCase();
	        this.iconClasses = ko.computed(this.computeCssClasses);
	    }
	    return FileMessageVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FileMessageVM;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var mediaLoader_1 = __webpack_require__(109);
	var GifPlayerVM = (function (_super) {
	    __extends(GifPlayerVM, _super);
	    function GifPlayerVM(_params, _element) {
	        var _this = this;
	        _super.call(this, _element);
	        this._params = _params;
	        this._element = _element;
	        this.shouldShowCover = function () {
	            return !!(_this.coverImage && _this.coverImage.url && !_this.canPlay());
	        };
	        this.dispose = function () {
	            _this.showCoverImage.dispose();
	        };
	        this.media = _params.media;
	        this.coverImage = _params.coverImage;
	        this.showCoverImage = ko.computed(this.shouldShowCover);
	        this.showLoadingInfo = _params.showLoadingInfo || true;
	    }
	    return GifPlayerVM;
	}(mediaLoader_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GifPlayerVM;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var application_1 = __webpack_require__(47);
	var baseMessage_1 = __webpack_require__(120);
	var ImageMessageVM = (function (_super) {
	    __extends(ImageMessageVM, _super);
	    function ImageMessageVM(message, conversation) {
	        var _this = this;
	        _super.call(this, message, conversation);
	        this.thumbnailUrl = ko.observable();
	        this.pictureUrl = ko.observable();
	        this.parse = function () {
	            var documentId = _this.retrieveDocumentId(_this.message.content);
	            if (!documentId || documentId === null) {
	                // TODO: mimat - handle this case properly - display error message
	                return;
	            }
	            application_1.default.instance.AmsManager.downloadPictureThumbnail(documentId).then(function (blob) {
	                var urlCreator = window.URL || window.webkitURL;
	                var imageUrl = urlCreator.createObjectURL(blob);
	                _this.thumbnailUrl(imageUrl);
	            });
	        };
	        // todo - we use a tag to pass information; this should be moved to a constructor
	        this.retrieveDocumentId = function (content) {
	            var idMatcher = content.match(/<LwcImage[^>]*?\surl=\"([^"]+?)\"/i);
	            if (!idMatcher) {
	                return null;
	            }
	            var wholeUrl = idMatcher[1];
	            return wholeUrl.substr(wholeUrl.lastIndexOf('/') + 1);
	        };
	        this.retrieveDocumentUrl = function (content) {
	            var idMatcher = content.match(/<LwcImage[^>]*?\surl=\"([^"]+?)\"/i);
	            if (!idMatcher) {
	                return null;
	            }
	            return idMatcher[1];
	        };
	        this.retrieveFilename = function (content) {
	            var matcher = content.match(/<LwcImage[^>]*?\sfilename=\"([^"]+?)\"/i);
	            if (!matcher) {
	                return null;
	            }
	            var filename = matcher[1];
	            return filename.substr(filename.lastIndexOf('/') + 1);
	        };
	        this.downloadImage = function () {
	            var newTab = null;
	            var IEFallback = !!navigator.msSaveOrOpenBlob;
	            if (!IEFallback) {
	                newTab = window.open('', '_blank');
	            }
	            var documentId = _this.retrieveDocumentId(_this.message.content);
	            application_1.default.instance.AmsManager.downloadPicture(documentId).then(function (blob) {
	                if (IEFallback) {
	                    navigator.msSaveOrOpenBlob(blob, _this.retrieveFilename(_this.message.content));
	                    return;
	                }
	                var urlCreator = window.URL || window.webkitURL;
	                var imageUrl = urlCreator.createObjectURL(blob);
	                newTab.location.href = imageUrl;
	            });
	        };
	        this.type = message.type;
	        this.parse();
	    }
	    return ImageMessageVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageMessageVM;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var dateUtility_1 = __webpack_require__(122);
	var baseMessage_1 = __webpack_require__(120);
	var i18n_1 = __webpack_require__(112);
	var MessageVM = (function (_super) {
	    __extends(MessageVM, _super);
	    function MessageVM(message, conversation, chatDef) {
	        var _this = this;
	        _super.call(this, message, conversation);
	        this.message = message;
	        this.content = ko.observable();
	        this.imageContent = ko.observable();
	        this.status = ko.observable();
	        this.showStatus = ko.observable();
	        this.deliveryFailed = ko.observable();
	        this.messageColor = ko.observable();
	        this.isTranslated = ko.observable();
	        this.isNew = true;
	        this.dispose = function () {
	            _this.message.unsubscribe('content', _this.content);
	            _this.message.unsubscribe('imageContent', _this.imageContent);
	        };
	        this._conversation = conversation;
	        this.type = message.type;
	        this.timestamp = dateUtility_1.default.toStringMesssageDate(message.timestamp.getTime());
	        if (message.type !== 'UserMessage') {
	            this.messageFromMe = false;
	        }
	        this.content(message.content);
	        this.imageContent(message.imageContent);
	        if (!this.messageFromMe) {
	            message.subscribe('content', function (newValue) {
	                _this.content(newValue);
	            });
	            message.subscribe('imageContent', function (newValue) {
	                _this.imageContent(newValue);
	            });
	        }
	        this.isTranslated(message.isTranslated);
	        message.subscribe('isTranslated', function (newValue) {
	            _this.isTranslated(newValue);
	        });
	        this.subscribeToDeliveryStatus(message);
	        if (chatDef) {
	            this.messageColor(chatDef.ColorMessage);
	        }
	    }
	    MessageVM.prototype.subscribeToDeliveryStatus = function (message) {
	        if (this._conversation.isDirectLineBackend()) {
	            return;
	        }
	        message.subscribe('status', updateStatus.bind(this));
	        updateStatus.bind(this)();
	        function updateStatus() {
	            switch (message.status) {
	                case 0:
	                    this.status(i18n_1.default.fetch('sending'));
	                    this.showStatus(true);
	                    break;
	                case 1:
	                    this.status(i18n_1.default.fetch('sent'));
	                    this.showStatus(false);
	                    break;
	                case 2:
	                    this.status(i18n_1.default.fetch('failed'));
	                    this.showStatus(false);
	                    this.deliveryFailed(true);
	                    break;
	                default:
	                    this.status('');
	                    this.showStatus(false);
	                    break;
	            }
	        }
	    };
	    return MessageVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessageVM;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var swift_1 = __webpack_require__(128);
	var enums_1 = __webpack_require__(118);
	var domPurifyService_1 = __webpack_require__(131);
	var baseMessage_1 = __webpack_require__(120);
	var swiftCardNodeRegex = /(<swiftcard>?[\s\S]*<\/swiftcard>)/i;
	var swiftAttributeRegex = /(?:<swiftcard[\s]+swift=\")([\s\S]*)(?:\">)/i;
	var invalid = -1;
	var SwiftVM = (function (_super) {
	    __extends(SwiftVM, _super);
	    function SwiftVM(params, _element) {
	        var _this = this;
	        _super.call(this, params.message, params.conversation);
	        this._element = _element;
	        this.isDisjoined = true;
	        this.unsupportedText = 'Swift is not supported';
	        this.parse = function (message, conversation, element) {
	            var regEx = /^<swiftcard/i;
	            var swiftCardJSON;
	            if (!regEx.test(message.content)) {
	                return invalid;
	            }
	            var getMessageSanitizedContent = function (text) {
	                return domPurifyService_1.default.dompurify.sanitize(text, { ALLOWED_TAGS: [] });
	            };
	            _this.content = message.content;
	            var swiftCardsStringMatch = message.content.match(swiftCardNodeRegex);
	            if (!swiftCardsStringMatch || swiftCardsStringMatch.length === 0) {
	                return invalid;
	            }
	            var swiftCardsArray = swiftCardsStringMatch[0].replace('><', '>$$$<').split('$$$');
	            var swiftAttribute = _this.find(swiftCardsArray, function (cardData) {
	                return swiftAttributeRegex.test(cardData);
	            });
	            if (!swiftAttribute) {
	                return invalid;
	            }
	            var swiftData = swiftAttribute.match(swiftAttributeRegex)[1];
	            try {
	                swiftCardJSON = JSON.parse(swiftData);
	            }
	            catch (e) {
	                return getMessageSanitizedContent(message.content);
	            }
	            _this.swift = new swift_1.default(swiftCardJSON, conversation, message, element);
	            _this.customMessageClasses = 'swiftCard ' + (_this.swift.isSupported() ? enums_1.SwiftCardType[_this.swift.type].toLowerCase() : 'unsupported') + (_this.swift.isValid() ? '' : ' invalid');
	        };
	        this.find = function (array, predicate) {
	            var i;
	            var item;
	            for (i = 0; i < array.length; ++i) {
	                if (predicate(array[i], i, array)) {
	                    return array[i];
	                }
	            }
	            return undefined;
	        };
	        if (this.parse(params.message, params.conversation, this._element) === invalid) {
	            this.content = this.unsupportedText;
	            this.swift = new swift_1.default({}, params.conversation, params.message, _element);
	        }
	        ;
	    }
	    return SwiftVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SwiftVM;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var enums_1 = __webpack_require__(118);
	var utils_1 = __webpack_require__(129);
	var card_1 = __webpack_require__(133);
	var action_1 = __webpack_require__(136);
	var suggestedAction_1 = __webpack_require__(144);
	var i18n_1 = __webpack_require__(112);
	var styleUtils_1 = __webpack_require__(139);
	var Swift = (function () {
	    function Swift(swiftJson, conversation, message, element) {
	        var _this = this;
	        this.CAROUSEL_WIDTH_DEFAULT = 288;
	        this.CAROUSEL_WIDTH_NARROW = 204;
	        this.selectedCard = ko.observable(0);
	        this.unsupportedText = i18n_1.default.fetch('s_unsupported');
	        this.types = {
	            'Unknown': enums_1.SwiftCardType.unknown,
	            'Card': enums_1.SwiftCardType.card,
	            'Carousel': enums_1.SwiftCardType.carousel,
	            'SignIn': enums_1.SwiftCardType.signin,
	            'Receipt': enums_1.SwiftCardType.receipt
	        };
	        this.carouselLeftPosition = function () {
	            var carouselWidth = _this.CAROUSEL_WIDTH_DEFAULT;
	            if (styleUtils_1.default.instance.CurrentStyle === styleUtils_1.StyleModes.NARROW) {
	                carouselWidth = _this.CAROUSEL_WIDTH_NARROW;
	            }
	            if (_this.isFirst()) {
	                return '0px';
	            }
	            else {
	                if (_this.isLast()) {
	                    return 'calc(' + _this.selectedCard() * -carouselWidth + 'px + (100% - ' + carouselWidth + 'px))';
	                }
	                else {
	                    return 'calc(' + _this.selectedCard() * -carouselWidth + 'px + (100% - ' + carouselWidth + 'px) / 2)';
	                }
	            }
	        };
	        this.isSupported = function () {
	            var cardsAreSupported = _this.cards.every(function (c) {
	                return c.isSupported();
	            });
	            return _this.isValid() && _this.type !== enums_1.SwiftCardType.unknown && cardsAreSupported;
	        };
	        this.isValid = function () {
	            var cardsAreValid = _this.cards.every(function (c) {
	                return c.isValid();
	            });
	            return !!_this.type && _this.cards.length !== 0 && cardsAreValid;
	        };
	        this.isCarousel = function () {
	            return _this.type === enums_1.SwiftCardType.carousel;
	        };
	        this.nextCard = function () {
	            _this.moveTo(_this.selectedCard() + 1);
	        };
	        this.prevCard = function () {
	            _this.moveTo(_this.selectedCard() - 1);
	        };
	        this.moveTo = function (index) {
	            if (index < 0 || index >= _this.cards.length) {
	                return;
	            }
	            _this.selectedCard(index);
	            _this.isFirst(index === 0);
	            _this.isLast(index === _this.cards.length - 1);
	        };
	        this.moveToCard = function (card) {
	            _this.moveTo(_this.cards.indexOf(card));
	        };
	        this.types['message/card'] = enums_1.SwiftCardType.card;
	        this.types['message/card.carousel'] = enums_1.SwiftCardType.carousel;
	        this.types['message/card.signin'] = enums_1.SwiftCardType.signin;
	        this.types['message/card.receipt'] = enums_1.SwiftCardType.receipt;
	        this.content = swiftJson.content ? utils_1.default.normalizeText(swiftJson.content) : null;
	        this.summary = utils_1.default.normalizeText(swiftJson.summary);
	        this.type = swiftJson.type ? this.types[swiftJson.type] : null;
	        this.cards = utils_1.default.mapArray(swiftJson.attachments, function (cardJson) {
	            return new card_1.default(cardJson, conversation, message.senderId, element);
	        });
	        if (swiftJson.suggestedActions && swiftJson.suggestedActions.actions) {
	            utils_1.default.mapArray(swiftJson.suggestedActions.actions, function (actionJson) {
	                message.suggestedActions.push(new suggestedAction_1.default(actionJson, conversation, message.senderId));
	            });
	        }
	        if (!this.isValid()) {
	            this.button = new action_1.default({ type: enums_1.SwiftCardActionType.unsupported, title: 'Not supported' }, conversation, message.senderId);
	            if (!this.type) {
	            }
	            else if (this.cards.length === 0) {
	            }
	            return;
	        }
	        if (!this.isSupported()) {
	            this.button = new action_1.default({ type: enums_1.SwiftCardActionType.unsupported, title: 'Not supported' }, conversation, message.senderId);
	            if (this.type === enums_1.SwiftCardType.unknown) {
	            }
	        }
	        this.areButtonsMultiLine = !this.cards.every(function (c) {
	            return c.content && c.isValid() && c.content.areButtonsMultiLine === false;
	        });
	        this.isFirst = ko.observable(true);
	        this.isLast = ko.observable(this.cards.length === 1);
	        this.selectedCard = ko.observable(0);
	        this.isMultiple = ko.observable(this.cards.length > 1);
	        if (this.isMultiple()) {
	            for (var index = 0; index < this.cards.length; index++) {
	                var card = this.cards[index];
	                if (card.isValid() && card.content && card.content.mainSection) {
	                    for (var imageIndex = 0; imageIndex < card.content.mainSection.images.length; imageIndex++) {
	                        var image = card.content.mainSection.images[imageIndex];
	                        image.isImageInCarousel(true);
	                    }
	                }
	            }
	        }
	        this.prevCardTitle = i18n_1.default.fetch('s_prevCard');
	        this.nextCardTitle = i18n_1.default.fetch('s_nextCard');
	    }
	    return Swift;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Swift;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var enums_1 = __webpack_require__(118);
	var messageUtils_1 = __webpack_require__(130);
	var SwiftCardUtils = (function () {
	    function SwiftCardUtils() {
	    }
	    SwiftCardUtils.INVALID_VALUE = 'invalidValue';
	    SwiftCardUtils.urlPrefixBlacklist = ['http', 'file', 'smb'];
	    SwiftCardUtils.filterOutNotValidItems = function (items, unitBuilder) {
	        var mapped = SwiftCardUtils.mapArray(items, unitBuilder);
	        var result = new Array();
	        for (var index = 0; index < mapped.length; index++) {
	            var item = mapped[index];
	            if (!item.isValid || item.isValid()) {
	                result.push(item);
	            }
	        }
	        return result;
	    };
	    SwiftCardUtils.filterOutDisabledItems = function (items, unitBuilder) {
	        var mapped = SwiftCardUtils.mapArray(items, unitBuilder);
	        var result = new Array();
	        for (var index = 0; index < mapped.length; index++) {
	            var item = mapped[index];
	            if (!item.isDisabled || !item.isDisabled()) {
	                result.push(item);
	            }
	        }
	        return result;
	    };
	    SwiftCardUtils.getItemIfNotDisabled = function (item) {
	        return (!item.isDisabled || !item.isDisabled()) ? item : null;
	    };
	    SwiftCardUtils.mapArray = function (items, unitBuilder) {
	        var result = new Array();
	        if (!items) {
	            return result;
	        }
	        for (var index = 0; index < items.length; index++) {
	            var item = items[index];
	            if (!!item) {
	                result.push(unitBuilder(item));
	            }
	        }
	        return result;
	    };
	    SwiftCardUtils.normalizeText = function (text) {
	        return text ? messageUtils_1.default.getMessageSanitizedContent(text) : null;
	    };
	    SwiftCardUtils.normalizeUrl = function (urlToValidate, actionType) {
	        var sanitizedUrl = urlToValidate ? messageUtils_1.default.getMessageSanitizedContent(urlToValidate) : SwiftCardUtils.INVALID_VALUE, forbiddenPrefixes = SwiftCardUtils.urlPrefixBlacklist;
	        function validateUrlPrefix(url) {
	            var regex;
	            for (var i = 0; i < forbiddenPrefixes.length; i++) {
	                regex = new RegExp('^' + forbiddenPrefixes[i] + ':', 'i');
	                if (regex.test(url)) {
	                    return SwiftCardUtils.INVALID_VALUE;
	                }
	            }
	            return url;
	        }
	        function validateURLProtocol(url) {
	            var allowedSchemes = ['https:'];
	            try {
	                var a = document.createElement('a'); // Use the browsers parser to extract the scheme.
	                a.href = url;
	                if (allowedSchemes.indexOf(a.protocol) > -1) {
	                    return url;
	                }
	                else {
	                    return SwiftCardUtils.INVALID_VALUE;
	                }
	            }
	            catch (e) {
	                return SwiftCardUtils.INVALID_VALUE;
	            }
	        }
	        function validateUrlFormat(url) {
	            var regex = /^(https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g;
	            return !!url.match(regex) ? url : SwiftCardUtils.INVALID_VALUE;
	        }
	        function validateEmbeddedScript(url) {
	            if (url === SwiftCardUtils.INVALID_VALUE) {
	                return SwiftCardUtils.INVALID_VALUE;
	            }
	            var regex = /^[\s\S]*javascript:/igm;
	            return !!url.match(regex) ? SwiftCardUtils.INVALID_VALUE : url;
	        }
	        switch (actionType) {
	            case enums_1.SwiftCardActionType.openUrl:
	            case enums_1.SwiftCardActionType.showImage:
	                sanitizedUrl = validateURLProtocol(sanitizedUrl);
	                sanitizedUrl = validateUrlFormat(sanitizedUrl);
	                sanitizedUrl = validateUrlPrefix(sanitizedUrl);
	                break;
	            case enums_1.SwiftCardActionType.signin:
	                sanitizedUrl = /^https/i.test(sanitizedUrl) ? sanitizedUrl : SwiftCardUtils.INVALID_VALUE;
	                break;
	            default:
	                break;
	        }
	        sanitizedUrl = validateEmbeddedScript(sanitizedUrl);
	        return sanitizedUrl;
	    };
	    SwiftCardUtils.normalizeDestination = function (text) {
	        return (/^(skype|tel):/i).test(text) ? messageUtils_1.default.getMessageSanitizedContent(text) : SwiftCardUtils.INVALID_VALUE;
	    };
	    SwiftCardUtils.normalizeRichText = function (text) {
	        return text ? text : null;
	    };
	    return SwiftCardUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SwiftCardUtils;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var domPurifyService_1 = __webpack_require__(131);
	var urlParser_1 = __webpack_require__(132);
	var MessageUtils = (function () {
	    function MessageUtils() {
	    }
	    MessageUtils.getMessageSanitizedContent = function (text) {
	        // this is removed as it does a lot of unnecessary sanitization which breaks legit tags
	        // requires deeper refactoring
	        // const escaped = escape(text)
	        // const decoded = new Encoder().decode(escaped)
	        var sanitized = domPurifyService_1.default.dompurify.sanitize(text);
	        return MessageUtils.webify(sanitized);
	    };
	    MessageUtils.webify = function (content) {
	        var lineFeed = /(\r?\n)|(&lt;br\s?\/&gt;)/gm;
	        var htmlNewLine = '<br/>';
	        return content.replace(lineFeed, htmlNewLine);
	    };
	    MessageUtils.attachActionToLinks = function (node, filterSelector, action, handler) {
	        if (node.nodeType === 1 && node.matches(filterSelector)) {
	            var anchors = node.querySelectorAll('a');
	            for (var i = 0; i < anchors.length; i++) {
	                var anchor = anchors[i];
	                if (anchor.href.indexOf(action) > 1) {
	                    var payload = urlParser_1.default.getQueryParameter(anchor.href, action);
	                    payload && anchor.setAttribute('data-swc-payload', payload);
	                    anchor.addEventListener('click', handler);
	                }
	            }
	        }
	    };
	    return MessageUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessageUtils;


/***/ },
/* 131 */
/***/ function(module, exports) {

	"use strict";
	var DomPurifyService = (function () {
	    function DomPurifyService() {
	    }
	    Object.defineProperty(DomPurifyService, "dompurify", {
	        get: function () {
	            return window.DOMPurify;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DomPurifyService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DomPurifyService;


/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	var UrlParserUtils = (function () {
	    function UrlParserUtils() {
	    }
	    UrlParserUtils.getQueryParameters = function () {
	        var query = window.location.search.substring(1);
	        return this.extractQueryParameters(query);
	    };
	    UrlParserUtils.getQueryParameter = function (uri, parameter) {
	        var query = uri.split('?')[1];
	        return this.extractQueryParameters(query)[parameter];
	    };
	    UrlParserUtils.extractQueryParameters = function (query) {
	        var variables = query.split('&');
	        var ret = {};
	        variables.forEach(function (variable) {
	            var tuple = variable.split('=');
	            ret[decodeURIComponent(tuple[0])] = decodeURIComponent(tuple[1]) || '';
	        });
	        return ret;
	    };
	    return UrlParserUtils;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = UrlParserUtils;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var enums_1 = __webpack_require__(118);
	var content_1 = __webpack_require__(134);
	// import swiftCardTelemetry from './telemetry/swiftCardTelemetry';
	var Card = (function () {
	    function Card(cardJson, conversation, senderId, element) {
	        var _this = this;
	        this.contentType = enums_1.SwiftCardContentType.unknown;
	        this.content = null;
	        this.isValid = function () {
	            return _this.contentType === enums_1.SwiftCardContentType.adaptive || (_this.contentType !== enums_1.SwiftCardContentType.unknown && _this.content && _this.content.isValid && _this.content.isValid()) || _this.contentType === enums_1.SwiftCardContentType.unknown;
	        };
	        this.isSupported = function () {
	            return _this.contentType === enums_1.SwiftCardContentType.adaptive || _this.contentType !== enums_1.SwiftCardContentType.unknown && (!_this.content || (!!_this.content.isSupported && _this.content.isSupported()));
	        };
	        this.getContentTypeName = function () {
	            return enums_1.SwiftCardContentType[_this.contentType].toLowerCase();
	        };
	        this.convertToCardContentType = function (value, content) {
	            if (!value) {
	                return enums_1.SwiftCardContentType.unknown;
	            }
	            var profile = content && content.media && content.media[0] && content.media[0].profile;
	            try {
	                switch (value.toLowerCase()) {
	                    case 'application/vnd.microsoft.card.hero':
	                        return enums_1.SwiftCardContentType.hero;
	                    case 'application/vnd.microsoft.card.thumbnail':
	                        return enums_1.SwiftCardContentType.thumb;
	                    case 'application/vnd.microsoft.card.receipt':
	                        return enums_1.SwiftCardContentType.receipt;
	                    case 'application/vnd.microsoft.card.signin':
	                        return enums_1.SwiftCardContentType.signin;
	                    case 'application/vnd.microsoft.card.video':
	                        return enums_1.SwiftCardContentType.video;
	                    case 'application/vnd.microsoft.card.audio':
	                        return enums_1.SwiftCardContentType.audio;
	                    case 'application/vnd.microsoft.card.animation':
	                        return profile === 'video' ? enums_1.SwiftCardContentType.video : enums_1.SwiftCardContentType.animation;
	                    case 'application/vnd.microsoft.card.adaptive':
	                        return enums_1.SwiftCardContentType.adaptive;
	                    default:
	                        return enums_1.SwiftCardContentType.unknown;
	                }
	            }
	            catch (error) {
	                return enums_1.SwiftCardContentType.unknown;
	            }
	        };
	        this.contentType = this.convertToCardContentType(cardJson.contentType, cardJson.content);
	        this.content = null;
	        this._conversation = conversation;
	        if (!cardJson.content) {
	            if (!this.isValid()) {
	            }
	            if (!this.isSupported()) {
	            }
	            return;
	        }
	        switch (this.contentType) {
	            case enums_1.SwiftCardContentType.hero:
	            case enums_1.SwiftCardContentType.thumb:
	                this.content = new content_1.default(cardJson.content, conversation, senderId, this.contentType);
	                break;
	            case enums_1.SwiftCardContentType.signin:
	                this.content = new content_1.SignInContent(cardJson.content, conversation, senderId);
	                break;
	            case enums_1.SwiftCardContentType.receipt:
	                this.content = new content_1.ReceiptContent(cardJson.content, conversation, senderId);
	                break;
	            case enums_1.SwiftCardContentType.audio:
	            case enums_1.SwiftCardContentType.video:
	            case enums_1.SwiftCardContentType.animation:
	                this.content = new content_1.MediaContent(cardJson.content, conversation, senderId, this.contentType);
	                break;
	            case enums_1.SwiftCardContentType.adaptive:
	                this.content = cardJson.content;
	                break;
	        }
	        if (!this.isSupported() && this.contentType === enums_1.SwiftCardContentType.unknown) {
	        }
	    }
	    return Card;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Card;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var enums_1 = __webpack_require__(118);
	var utils_1 = __webpack_require__(129);
	var image_1 = __webpack_require__(135);
	var section_1 = __webpack_require__(141);
	var fact_1 = __webpack_require__(142);
	var action_1 = __webpack_require__(136);
	var media_1 = __webpack_require__(143);
	var i18n_1 = __webpack_require__(112);
	// import swiftCardTelemetry from './telemetry/swiftCardTelemetry';
	var PORTRAIT_RATIO = '9:16';
	var PORTRAIT = 'portrait';
	var LANDSCAPE = 'landscape';
	var BaseContent = (function () {
	    function BaseContent() {
	        this.unsupportedText = i18n_1.default.fetch('s_unsupported');
	        this.vatText = i18n_1.default.fetch('s_vat');
	        this.taxText = i18n_1.default.fetch('s_tax');
	        this.totalPriceText = i18n_1.default.fetch('s_totalPrice');
	        this.areButtonsMultiLine = false;
	        this.mainSection = null;
	    }
	    return BaseContent;
	}());
	exports.BaseContent = BaseContent;
	var Content = (function (_super) {
	    __extends(Content, _super);
	    function Content(contentJson, conversation, senderId, type) {
	        var _this = this;
	        _super.call(this);
	        this.computeButtonsLimit = function () {
	            if (_this.type === enums_1.SwiftCardContentType.thumb) {
	                return 3;
	            }
	            var buttonsLimit = 3;
	            if (_this.mainSection.images.length === 0) {
	                buttonsLimit += 2;
	            }
	            if (!_this.mainSection.text) {
	                buttonsLimit++;
	                if (!_this.mainSection.title) {
	                    buttonsLimit++;
	                }
	                if (!_this.mainSection.subtitle) {
	                    buttonsLimit++;
	                }
	            }
	            return Math.min(buttonsLimit, 6);
	        };
	        this.isValid = function () {
	            if (_this.buttons.length !== 0) {
	                return _this.buttons.every(function (b) {
	                    return b.isValid();
	                });
	            }
	            return _this.mainSection.isValid();
	        };
	        this.isSupported = function () {
	            var buttonsAreSupported = _this.buttons.every(function (b) {
	                return b.isSupported();
	            });
	            return ((_this.tap && _this.tap.isSupported()) || !_this.tap) && buttonsAreSupported;
	        };
	        this.type = type;
	        this.buttons = utils_1.default.filterOutDisabledItems(contentJson.buttons, function (actionJson) {
	            return new action_1.default(actionJson, conversation, senderId);
	        });
	        this.tap = contentJson.tap ? utils_1.default.getItemIfNotDisabled(new action_1.default(contentJson.tap, conversation, senderId)) : null;
	        this.mainSection = new section_1.default(contentJson, conversation, senderId, type);
	        var buttonsLimit = this.computeButtonsLimit();
	        if (this.buttons.length > buttonsLimit) {
	            this.buttons = this.buttons.slice(0, buttonsLimit);
	        }
	        this.areButtonsMultiLine = Content.areButtonsMultiLine(this.buttons);
	        if (!this.isValid()) {
	            if (!this.mainSection.isValid()) {
	            }
	            else {
	            }
	        }
	        if (!this.isSupported()) {
	        }
	    }
	    Content.areButtonsMultiLine = function (buttons) {
	        switch (buttons.length) {
	            case 2:
	                return !buttons.every(function (b) {
	                    return b.title.length <= 11;
	                });
	            case 3:
	                return !buttons.every(function (b) {
	                    return b.title.length <= 5;
	                });
	        }
	        return true;
	    };
	    return Content;
	}(BaseContent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Content;
	var SignInContent = (function (_super) {
	    __extends(SignInContent, _super);
	    function SignInContent(contentJson, conversation, senderId) {
	        var _this = this;
	        _super.call(this);
	        this.isValid = function () {
	            return _this.buttons.length !== 0 && !!_this.text;
	        };
	        this.isSupported = function () {
	            return _this.isValid();
	        };
	        this.find = function (array, predicate) {
	            var i;
	            var item;
	            for (i = 0; i < array.length; ++i) {
	                if (predicate(array[i], i, array)) {
	                    return array[i];
	                }
	            }
	            return undefined;
	        };
	        this.type = enums_1.SwiftCardContentType.signin;
	        this.buttons = utils_1.default.filterOutDisabledItems(contentJson.buttons, function (actionJson) {
	            return new action_1.default(actionJson, conversation, senderId);
	        });
	        var signInButton = this.find(this.buttons, function (b) {
	            return b.type === enums_1.SwiftCardActionType.signin;
	        });
	        this.buttons = signInButton ? [signInButton] : [];
	        this.text = utils_1.default.normalizeRichText(contentJson.text);
	        if (!this.isValid()) {
	            if (this.buttons.length === 0) {
	            }
	            else if (!this.text) {
	            }
	        }
	    }
	    return SignInContent;
	}(BaseContent));
	exports.SignInContent = SignInContent;
	var MediaContent = (function (_super) {
	    __extends(MediaContent, _super);
	    function MediaContent(contentJson, conversation, senderId, type) {
	        var _this = this;
	        _super.call(this);
	        this.hasUrl = function () {
	            return !!_this.image && !!_this.image.url;
	        };
	        this.hasTitle = function () {
	            return !!_this.title || !!_this.subtitle;
	        };
	        this.isValid = function () {
	            return !!_this.media && !!_this.media.isValid();
	        };
	        this.isSupported = function () {
	            return _this.isValid();
	        };
	        this.type = type;
	        this.autoloop = contentJson.autoloop;
	        this.autostart = contentJson.autostart;
	        this.shareable = contentJson.shareable;
	        this.subtitle = contentJson.subtitle ? utils_1.default.normalizeText(contentJson.subtitle) : null;
	        this.title = contentJson.title ? utils_1.default.normalizeText(contentJson.title) : null;
	        this.image = new image_1.default(contentJson.image || {}, conversation, senderId, type);
	        this.aspect = contentJson.aspect && contentJson.aspect === PORTRAIT_RATIO ? PORTRAIT : LANDSCAPE;
	        this.hasThumbnail = ko.computed(this.hasUrl);
	        this.hasTextInfo = ko.computed(this.hasTitle);
	        this.media = contentJson.media && contentJson.media.length ? new media_1.default(contentJson.media[0], conversation, senderId, type) : null;
	        this.buttons = utils_1.default.filterOutDisabledItems(contentJson.buttons, function (actionJson) {
	            return new action_1.default(actionJson, conversation, senderId);
	        });
	        if (this.buttons.length > 3) {
	            this.buttons = this.buttons.slice(0, 3);
	        }
	        this.areButtonsMultiLine = Content.areButtonsMultiLine(this.buttons);
	        if (!this.isValid()) {
	        }
	    }
	    return MediaContent;
	}(BaseContent));
	exports.MediaContent = MediaContent;
	var ReceiptContent = (function (_super) {
	    __extends(ReceiptContent, _super);
	    function ReceiptContent(contentJson, conversation, senderId) {
	        var _this = this;
	        _super.call(this);
	        this.itemsForInitialDisplay = new Array();
	        this.triggerFoldAction = function () {
	            _this.isCollapsed(!_this.isCollapsed());
	            if (_this.isCollapsed()) {
	                _this.collapseItems();
	            }
	            else {
	                _this.displayedItems(_this.items);
	                _this.foldButtonText(i18n_1.default.fetch('s_showLess'));
	            }
	        };
	        this.isValid = function () {
	            var buttonsAreValid = _this.buttons.every(function (b) {
	                return b.isValid();
	            });
	            return !!_this.total && buttonsAreValid;
	        };
	        this.isSupported = function () {
	            var buttonsAreSupported = _this.buttons.every(function (b) {
	                return b.isSupported();
	            });
	            return ((_this.tap && _this.tap.isSupported()) || !_this.tap) && buttonsAreSupported;
	        };
	        this.collapseItems = function () {
	            _this.displayedItems(_this.itemsForInitialDisplay);
	            _this.foldButtonText(i18n_1.default.fetch('s_showAll'));
	        };
	        this.getItemsForInitialDisplay = function () {
	            var counter = 0;
	            for (var i = 0; i < _this.items.length; i++) {
	                if (counter >= ReceiptContent.MAX_ITEMS_NUMBER_TO_DISPLAY) {
	                    return;
	                }
	                _this.itemsForInitialDisplay.push(_this.items[i]);
	                if (_this.items[i].images.length > 0) {
	                    counter = counter + ReceiptContent.IMAGE_ITEM_COUNTER;
	                }
	                else {
	                    counter++;
	                }
	            }
	            _this.itemsForInitialDisplay = [];
	        };
	        this.type = enums_1.SwiftCardContentType.receipt;
	        this.buttons = utils_1.default.filterOutDisabledItems(contentJson.buttons, function (actionJson) {
	            return new action_1.default(actionJson, conversation, senderId);
	        });
	        if (this.buttons.length > 3) {
	            this.buttons = this.buttons.slice(0, 3);
	        }
	        this.areButtonsMultiLine = Content.areButtonsMultiLine(this.buttons);
	        this.tap = contentJson.tap ? new action_1.default(contentJson.tap, conversation, senderId) : null;
	        this.title = utils_1.default.normalizeRichText(contentJson.title);
	        this.total = utils_1.default.normalizeText(contentJson.total);
	        this.tax = utils_1.default.normalizeText(contentJson.tax);
	        this.vat = utils_1.default.normalizeText(contentJson.vat);
	        this.facts = utils_1.default.filterOutNotValidItems(contentJson.facts, function (factJson) {
	            return new fact_1.default(factJson);
	        });
	        this.items = utils_1.default.filterOutNotValidItems(contentJson.items, function (sectionJson) {
	            return new section_1.default(sectionJson, conversation, senderId, enums_1.SwiftCardContentType.thumb);
	        });
	        this.displayedItems = ko.observableArray();
	        this.showFoldButton = ko.observable(false);
	        this.isCollapsed = ko.observable(false);
	        this.foldButtonText = ko.observable();
	        this.getItemsForInitialDisplay();
	        if (this.itemsForInitialDisplay.length > 0) {
	            this.showFoldButton(true);
	            this.isCollapsed(true);
	            this.collapseItems();
	        }
	        else {
	            this.displayedItems(this.items);
	        }
	        if (!this.isValid()) {
	            if (!this.total) {
	            }
	            else {
	            }
	        }
	        if (!this.isSupported()) {
	        }
	    }
	    ReceiptContent.MAX_ITEMS_NUMBER_TO_DISPLAY = 5;
	    ReceiptContent.IMAGE_ITEM_COUNTER = 3;
	    return ReceiptContent;
	}(BaseContent));
	exports.ReceiptContent = ReceiptContent;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config_1 = __webpack_require__(27);
	var enums_1 = __webpack_require__(118);
	var action_1 = __webpack_require__(136);
	var application_1 = __webpack_require__(47);
	var utils_1 = __webpack_require__(129);
	var i18n_1 = __webpack_require__(112);
	var styleUtils_1 = __webpack_require__(139);
	var serviceFaultEvent_1 = __webpack_require__(54);
	var SwiftCardImage = (function () {
	    function SwiftCardImage(imageJson, conversation, senderId, contentType) {
	        var _this = this;
	        this.url = ko.observable();
	        this.DestinationSize = {
	            narrow: {},
	            default: {},
	            carouselDefault: {},
	            carouselNarrow: {}
	        };
	        this.trustedDomains = [
	            config_1.default.AMS_HOST_URL,
	            config_1.default.CDN_SERVICE_HOST
	        ];
	        this.shouldProcessThroughAMS = function (url) {
	            return _this._conversation.isSkypeBackend() && !_this.isTrustedUrl(url);
	        };
	        this.processImage = function (url) {
	            if (_this.shouldProcessThroughAMS(url)) {
	                _this.processViaAMS(url).then(function (response) {
	                    if (response.thumbnail) {
	                        _this.url(response.thumbnail);
	                    }
	                    if (response.thumbnail_meta) {
	                        _this.naturalSize({
	                            height: response.thumbnail_meta.height,
	                            width: response.thumbnail_meta.width
	                        });
	                    }
	                }, function (error) {
	                    console.warn('swift-img - failed loading image ' + error);
	                });
	            }
	            else {
	                _this.loadImageSize(_this._conversation.isSkypeBackend() ? utils_1.default.normalizeUrl(url) : url);
	            }
	        };
	        this.hasProcessedUrl = function () {
	            return !!_this.url();
	        };
	        this.isTrustedUrl = function (url) {
	            var isTrusted = false;
	            _this.trustedDomains.forEach(function (domain) {
	                isTrusted = url.indexOf(domain) > -1;
	            });
	            return isTrusted;
	        };
	        this.processViaAMS = function (url) {
	            var urlpPart = '/v1/url/info?url=', prefix = config_1.default.URLP_SERVICE_URL + urlpPart, uri, escapedPrefix = prefix.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), finalPrefix = new RegExp(escapedPrefix, 'g');
	            uri = url.indexOf(prefix) > 0 ? url.replace(finalPrefix, '') : url;
	            return new Promise(function (resolve) {
	                return application_1.default.instance.AmsManager.getPictureThumbnail(prefix + encodeURIComponent(uri)).then(resolve);
	            });
	        };
	        this.loadImageSize = function (url) {
	            var image = new Image();
	            image.onload = function () {
	                _this.url(url);
	                _this.naturalSize({ height: image.naturalHeight, width: image.naturalWidth });
	            };
	            image.onerror = function (details) {
	                serviceFaultEvent_1.ServiceFaultEvent.report('swift-img', { message: 'Unable to load an image', isDirectLine: _this._conversation.isDirectLineBackend() });
	            };
	            image.src = url;
	        };
	        this.getUiSize = function () {
	            var styleMode = styleUtils_1.default.instance.CurrentStyle, destSize = _this.getDestinationSize(_this.contentType, styleMode, _this.isImageInCarousel()), natSize = _this.naturalSize(), uiSize = { height: 0, width: 0 };
	            if (natSize.height === 0 || natSize.width === 0 || destSize.height === 0) {
	                return uiSize;
	            }
	            var destRatio = destSize.width / destSize.height, imgRatio = natSize.width / natSize.height;
	            switch (_this.contentType) {
	                case enums_1.SwiftCardContentType.hero:
	                    if (imgRatio < destRatio) {
	                        uiSize.width = destSize.width;
	                        uiSize.height = natSize.height * destSize.width / natSize.width;
	                        _this.bottomAlignment((uiSize.height - destSize.height) / 2);
	                    }
	                    else {
	                        uiSize.height = destSize.height;
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                    }
	                    _this.leftAlignment(uiSize.width / -2);
	                    break;
	                case enums_1.SwiftCardContentType.animation:
	                case enums_1.SwiftCardContentType.audio:
	                    if (imgRatio < destRatio) {
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                        uiSize.height = natSize.height * destSize.height / natSize.height;
	                    }
	                    else {
	                        uiSize.height = destSize.height;
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                    }
	                    break;
	                case enums_1.SwiftCardContentType.thumb:
	                case enums_1.SwiftCardContentType.actionImage:
	                    if (imgRatio < destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = uiSize.height * imgRatio;
	                    }
	                    else if (imgRatio === destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                    }
	                    else {
	                        uiSize.width = destSize.width;
	                        uiSize.height = uiSize.width / imgRatio;
	                    }
	                    _this.bottomAlignment((uiSize.height - destSize.height) / 2);
	                    _this.leftAlignment(uiSize.width / -2);
	                    break;
	                case enums_1.SwiftCardContentType.receipt:
	                    if (imgRatio < destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = uiSize.height * imgRatio;
	                    }
	                    else if (imgRatio === destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                    }
	                    else {
	                        uiSize.width = destSize.width;
	                        uiSize.height = uiSize.width / imgRatio;
	                        _this.bottomAlignment((uiSize.height - destSize.height) / 2);
	                    }
	                    _this.leftAlignment(uiSize.width / -2);
	                    break;
	                case enums_1.SwiftCardContentType.actionImage:
	                    if (imgRatio < destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = uiSize.height * imgRatio;
	                    }
	                    else if (imgRatio === destRatio) {
	                        uiSize.height = destSize.height;
	                        uiSize.width = natSize.width * destSize.height / natSize.height;
	                    }
	                    else {
	                        uiSize.width = destSize.width;
	                        uiSize.height = uiSize.width / imgRatio;
	                    }
	                    break;
	                default:
	                    break;
	            }
	            return uiSize;
	        };
	        this.getTitleByType = function () {
	            switch (_this.tap.type) {
	                case enums_1.SwiftCardActionType.call:
	                case enums_1.SwiftCardActionType.imBack:
	                    return _this.createImageTitle();
	                case enums_1.SwiftCardActionType.openUrl:
	                    return _this.createImageTitle() + '\n\n' + _this.tap.value;
	                case enums_1.SwiftCardActionType.showImage:
	                    return (_this.alt ? _this.alt + ' ' : '') + _this.lowerFirstLetter(_this.tap.title);
	                default:
	                    break;
	            }
	            return '';
	        };
	        this.createImageTitle = function () {
	            var title = i18n_1.default.fetch('accessibility_swift_action_prefix', {
	                swiftAction: _this.lowerFirstLetter(_this.tap.title)
	            });
	            return (_this.alt ? _this.alt + ' ' : '') + title;
	        };
	        this.lowerFirstLetter = function (value) {
	            return value[0].toLowerCase() + value.substring(1);
	        };
	        this.getDestinationSize = function (contentType, styleMode, isImageInCarousel) {
	            var destSize;
	            if (styleMode === styleUtils_1.StyleModes.NORMAL) {
	                if (isImageInCarousel) {
	                    destSize = _this.DestinationSize.carouselDefault;
	                }
	                else {
	                    destSize = _this.DestinationSize.default;
	                }
	            }
	            else {
	                if (isImageInCarousel) {
	                    destSize = _this.DestinationSize.carouselNarrow;
	                }
	                else {
	                    destSize = _this.DestinationSize.narrow;
	                }
	            }
	            return destSize[contentType];
	        };
	        this._conversation = conversation;
	        // Hero
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.hero] = { height: 105, width: 188 };
	        this.DestinationSize.default[enums_1.SwiftCardContentType.hero] = { height: 153, width: 272 };
	        this.DestinationSize.carouselDefault[enums_1.SwiftCardContentType.hero] = { height: 145, width: 256 };
	        this.DestinationSize.carouselNarrow[enums_1.SwiftCardContentType.hero] = { height: 105, width: 188 };
	        // Thumb
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.thumb] = { height: 76, width: 76 };
	        this.DestinationSize.default[enums_1.SwiftCardContentType.thumb] = { height: 112, width: 112 };
	        this.DestinationSize.carouselDefault[enums_1.SwiftCardContentType.thumb] = { height: 112, width: 112 };
	        this.DestinationSize.carouselNarrow[enums_1.SwiftCardContentType.thumb] = { height: 76, width: 76 };
	        // Receipt
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.receipt] = { height: 76, width: 76 };
	        this.DestinationSize.default[enums_1.SwiftCardContentType.receipt] = { height: 112, width: 112 };
	        // Animation
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.animation] = { height: 105, width: 172 };
	        this.DestinationSize.default[enums_1.SwiftCardContentType.animation] = { height: 153, width: 256 };
	        this.DestinationSize.carouselDefault[enums_1.SwiftCardContentType.animation] = { height: 145, width: 256 };
	        this.DestinationSize.carouselNarrow[enums_1.SwiftCardContentType.animation] = { height: 105, width: 172 };
	        // Audio Thumbnail
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.audio] = { height: 105, width: 172 };
	        this.DestinationSize.default[enums_1.SwiftCardContentType.audio] = { height: 145, width: 256 };
	        this.DestinationSize.carouselDefault[enums_1.SwiftCardContentType.audio] = { height: 145, width: 256 };
	        this.DestinationSize.carouselNarrow[enums_1.SwiftCardContentType.audio] = { height: 105, width: 172 };
	        // Action Icon
	        this.DestinationSize.default[enums_1.SwiftCardContentType.actionImage] = { height: 20, width: 20 };
	        this.DestinationSize.narrow[enums_1.SwiftCardContentType.actionImage] = { height: 16, width: 16 };
	        this.contentType = contentType;
	        this.alt = utils_1.default.normalizeRichText(imageJson.alt);
	        if (imageJson.url) {
	            this.processImage(imageJson.url);
	        }
	        // TODO: [urlpreview] - add URL preview
	        this.tap = null;
	        if (imageJson.tap) {
	            this.tap = utils_1.default.getItemIfNotDisabled(new action_1.default(imageJson.tap, conversation, senderId));
	            if (this.tap && this.tap.type === enums_1.SwiftCardActionType.showImage && !this.tap.value) {
	                this.tap.value = this.url();
	            }
	        }
	        this.naturalSize = ko.observable({ height: 0, width: 0 });
	        this.uiSize = ko.pureComputed(this.getUiSize.bind(this));
	        this.isValid = ko.pureComputed(this.hasProcessedUrl);
	        this.bottomAlignment = ko.observable();
	        this.leftAlignment = ko.observable();
	        this.isImageInCarousel = ko.observable(false);
	    }
	    return SwiftCardImage;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SwiftCardImage;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var enums_1 = __webpack_require__(118);
	var utils_1 = __webpack_require__(129);
	var i18n_1 = __webpack_require__(112);
	// import swiftCardTelemetry from './telemetry/swiftCardTelemetry';
	var mentionDomEncoder_1 = __webpack_require__(137);
	var unsupportedUrl = 'https://www.skype.com/';
	var PAYMENT_POPUP_FEATURES = 'width=600, height=620, menubar=no, status=no, titlebar=no, toolbar=no, rel=noopener noreferrer';
	var Action = (function () {
	    function Action(actionJson, conversation, senderId) {
	        var _this = this;
	        this.type = enums_1.SwiftCardActionType.unknown;
	        this.actions = {};
	        this.isValid = function () {
	            return _this.type !== null && !!_this.title && !!_this.value;
	        };
	        this.isDisabled = function () {
	            return !!_this.value && _this.value === utils_1.default.INVALID_VALUE;
	        };
	        this.isSupported = function () {
	            return _this.type !== null && _this.type !== enums_1.SwiftCardActionType.unknown;
	        };
	        this.action = function () {
	            if (_this.isValid() && !_this.isCalling()) {
	                return _this.actions[enums_1.SwiftCardActionType[_this.type]]().then(function () {
	                    // swiftCardTelemetry.publishCardAction(this.type, true, this.senderId);
	                }).catch(function () {
	                    // swiftCardTelemetry.publishCardAction(this.type, false, this.senderId);
	                });
	            }
	            else {
	                // swiftCardTelemetry.publishCardAction(this.type, false, this.senderId);
	                return Promise.resolve();
	            }
	        };
	        this.openUrl = function () {
	            if (_this.value.match(/^skype:\?payments/)) {
	                console.warn('Payments action not supported');
	            }
	            else if (_this.value.match(/^skype:/)) {
	                // TODO: [call] - implement calling action for SWIFT cards
	                console.warn('Calling is not supported');
	            }
	            var newWindow = window.open(_this.value, '_blank');
	            newWindow.opener = null;
	            return Promise.resolve();
	        };
	        this.imBack = function () {
	            var startTime = Date.now();
	            return _this.conversation.sendSwift(_this.value)
	                .then(function () {
	                var endTime = Date.now();
	                // this.sendTelemetryData(endTime - startTime, true);
	                return Promise.resolve();
	            }).catch(function () {
	                // TODO: add message not send error handling?
	                var endTime = Date.now();
	                // this.sendTelemetryData(endTime - startTime, false);
	                console.warn('unable to send message');
	            });
	        };
	        this.payment = function () {
	            var uri = _this.fallbackUri ? _this.fallbackUri : _this.value;
	            var paymentPopup = window.open(uri, '_blank', PAYMENT_POPUP_FEATURES);
	            if (paymentPopup && window.focus) {
	                paymentPopup.focus();
	            }
	            paymentPopup.opener = null;
	            return Promise.resolve();
	        };
	        this.convertToActionType = function (text) {
	            if (!text) {
	                return null;
	            }
	            try {
	                switch (text.toLowerCase()) {
	                    case 'unsupported':
	                        return enums_1.SwiftCardActionType.unsupported;
	                    case 'openurl':
	                        return enums_1.SwiftCardActionType.openUrl;
	                    case 'imback':
	                        return enums_1.SwiftCardActionType.imBack;
	                    case 'signin':
	                        return enums_1.SwiftCardActionType.signin;
	                    case 'call':
	                        return enums_1.SwiftCardActionType.call;
	                    case 'showimage':
	                        return enums_1.SwiftCardActionType.showImage;
	                    case 'payment':
	                        return enums_1.SwiftCardActionType.payment;
	                    default:
	                        return enums_1.SwiftCardActionType.unknown;
	                }
	            }
	            catch (error) {
	                return enums_1.SwiftCardActionType.unknown;
	            }
	        };
	        this.type = this.convertToActionType(actionJson.type);
	        this.title = utils_1.default.normalizeText(actionJson.title);
	        this.value = actionJson.value ? actionJson.value : null;
	        this.isCalling = ko.observable(false);
	        this.senderId = senderId;
	        this.tooltip = this.title;
	        this.fallbackUri = actionJson.fallback && actionJson.fallback.uri ? utils_1.default.normalizeUrl(actionJson.fallback.uri) : null;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.call]] = this.call;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.imBack]] = this.imBack;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.openUrl]] = this.openUrl;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.showImage]] = this.openUrl;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.signin]] = this.openUrl;
	        this.actions[enums_1.SwiftCardActionType[enums_1.SwiftCardActionType.payment]] = this.payment;
	        switch (this.type) {
	            case enums_1.SwiftCardActionType.call:
	                this.value = utils_1.default.normalizeDestination(this.value);
	                break;
	            case enums_1.SwiftCardActionType.imBack:
	                if (conversation.isGroup()) {
	                    var self_1 = this;
	                    var originalValue_1 = this.value;
	                    // strip '28:' from agent id
	                    var strippedId_1 = senderId.substring(3);
	                    function setMentionValue() {
	                        var mentionEncoder = new mentionDomEncoder_1.MentionDomEncoder();
	                        var mentionData = mentionEncoder.getMentionUserData(strippedId_1, conversation);
	                        var mention = mentionEncoder.createXmlElement(document, mentionData).outerHTML;
	                        self_1.value = mention + ' ' + originalValue_1;
	                    }
	                    conversation.participants.filter(function (participant) {
	                        return participant.id.toLowerCase() === strippedId_1;
	                    })
	                        .forEach(function (participant) {
	                        // TODO: might be a bit too hacky
	                        participant.subscribe('displayName', setMentionValue);
	                    });
	                    setMentionValue();
	                }
	                break;
	            case enums_1.SwiftCardActionType.showImage:
	                if (this.value) {
	                    this.value = utils_1.default.normalizeUrl(actionJson.value);
	                }
	                if (!this.title) {
	                    this.title = i18n_1.default.fetch('s_showImageTitle');
	                }
	                break;
	            case enums_1.SwiftCardActionType.openUrl:
	                if (this.value.match(/^skype:/)) {
	                    this.value = utils_1.default.normalizeDestination(this.value);
	                }
	                else {
	                    this.value = utils_1.default.normalizeUrl(actionJson.value, enums_1.SwiftCardActionType.openUrl);
	                }
	                if (this.tooltip) {
	                    this.tooltip += '\n\n' + this.value;
	                }
	                else {
	                    this.tooltip = this.value;
	                }
	                break;
	            case enums_1.SwiftCardActionType.signin:
	                this.value = utils_1.default.normalizeUrl(actionJson.value, enums_1.SwiftCardActionType.signin);
	                if (!this.title) {
	                    this.title = i18n_1.default.fetch('s_signInTitle');
	                }
	                break;
	            case enums_1.SwiftCardActionType.unsupported:
	                this.type = enums_1.SwiftCardActionType.openUrl;
	                if (!this.title) {
	                    this.title = i18n_1.default.fetch('s_unsupported_button');
	                }
	                if (!this.value) {
	                    this.value = unsupportedUrl;
	                }
	                break;
	            default:
	                break;
	        }
	        this.conversation = conversation;
	        this.action = this.action.bind(this);
	        if (!this.isValid()) {
	            if (!this.type) {
	            }
	            else if (!this.title) {
	            }
	            else if (!this.value) {
	            }
	        }
	    }
	    Action.prototype.call = function () {
	        console.warn('Calling is not supported');
	        return Promise.reject('Calling is not supported');
	    };
	    ;
	    return Action;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Action;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var wordDomTransformer_1 = __webpack_require__(138);
	var parenthesesMatcher = /(\(|\))/g;
	var MentionDomEncoder = (function (_super) {
	    __extends(MentionDomEncoder, _super);
	    function MentionDomEncoder() {
	        _super.apply(this, arguments);
	    }
	    MentionDomEncoder.prototype.isElementAllowed = function (element) {
	        return element.nodeName.toLowerCase() !== 'i' ||
	            element.className.toLowerCase().indexOf('mention') === -1;
	    };
	    MentionDomEncoder.prototype.wordRawToXml = function (dom, word, conversation, mePerson) {
	        var nodes = [], subWord = word.substring(1), supportedSeparators = /[\.,_:\-;?]$/, removedSeparator, mentionData = this.getMentionUserData(subWord, conversation, mePerson);
	        while (!mentionData && subWord.match(supportedSeparators)) {
	            removedSeparator = subWord.charAt(subWord.length - 1);
	            subWord = subWord.substring(0, subWord.length - 1);
	            mentionData = this.getMentionUserData(subWord, conversation, mePerson);
	        }
	        if (mentionData) {
	            nodes.push(this.createXmlElement(dom, mentionData));
	            if (removedSeparator) {
	                nodes.push(dom.createTextNode(removedSeparator));
	            }
	        }
	        return nodes;
	    };
	    MentionDomEncoder.prototype.getMentionUserData = function (skypeId, conversation, mePerson) {
	        var mentionedPerson, separator = '', result = {
	            defaultDisplayName: '',
	            displayName: '',
	            skypeId: '',
	            type: '',
	            isMePerson: false
	        };
	        if (!skypeId) {
	            return null;
	        }
	        skypeId = skypeId.toLowerCase();
	        var isDisplayName = skypeId.indexOf('(') === 0, displayName = isDisplayName ? skypeId.substring(1, skypeId.length - 1) : '', persons = conversation ? conversation.participants : [];
	        result.isMePerson = !!mePerson && (skypeId === mePerson.id.toLowerCase() || isDisplayName && mePerson.displayName.replace(parenthesesMatcher, '').toLowerCase() === displayName);
	        if (result.isMePerson) {
	            mentionedPerson = mePerson;
	        }
	        else {
	            mentionedPerson = persons.filter(function (p) {
	                return p.id.toLowerCase() === skypeId || isDisplayName && p.displayName.replace(parenthesesMatcher, '').toLowerCase() === displayName;
	            })[0];
	        }
	        if (!mentionedPerson) {
	            return null;
	        }
	        result.skypeId = mentionedPerson.id;
	        // TODO: if we want to mention non-agents this needs to be fixed
	        result.type = '28';
	        result.displayName = mentionedPerson.displayName;
	        if (!result.defaultDisplayName) {
	            result.defaultDisplayName = result.displayName;
	        }
	        return result;
	    };
	    MentionDomEncoder.prototype.wordMatcher = function () {
	        return /@([a-z0-9\.,\-_:]+|\(.+?\))/gi;
	    };
	    MentionDomEncoder.prototype.createXmlElement = function (dom, mentionData) {
	        var emoticon = dom.createElement('at');
	        emoticon.setAttribute('id', mentionData.type + ':' + mentionData.skypeId);
	        emoticon.innerText = mentionData.defaultDisplayName;
	        return emoticon;
	    };
	    return MentionDomEncoder;
	}(wordDomTransformer_1.WordDomTransformer));
	exports.MentionDomEncoder = MentionDomEncoder;


/***/ },
/* 138 */
/***/ function(module, exports) {

	"use strict";
	var WordDomTransformer = (function () {
	    function WordDomTransformer() {
	    }
	    WordDomTransformer.prototype.transformRawToXml = function (dom, message, conversation, mePerson) {
	        var stack = [];
	        stack.push(message);
	        while (stack.length !== 0) {
	            var item = stack.pop();
	            if (item.nodeType === Node.TEXT_NODE) {
	                this.encodeTextNodeToXml(dom, item, conversation, mePerson);
	            }
	            else if (this.isElementAllowed(item)) {
	                this.pushChildNodes(stack, item);
	            }
	        }
	    };
	    WordDomTransformer.prototype.wordMatcher = function () {
	        // Following regex matches all word characters plus ()#:-=<>;'|$"]*^&+@{?ÆŽ/\!~
	        // these are currently all the possible characters for emoticons
	        return /[\w()#:\-=<>;'\|\$"\]\*\^&\+@\{\?ÆŽ\/\\!~]+/g;
	    };
	    WordDomTransformer.prototype.getAllWords = function (text) {
	        var regex = this.wordMatcher(), match, result = new Array();
	        while ((match = regex.exec(text)) !== null) {
	            result.push(match);
	        }
	        return result;
	    };
	    WordDomTransformer.prototype.encodeTextNodeToXml = function (dom, item, conversation, mePerson) {
	        var parent = item.parentNode, newNodes = this.encodeWords(dom, item, conversation, mePerson);
	        if (newNodes.length === 0) {
	            return;
	        }
	        for (var i = 0; i < newNodes.length; i++) {
	            parent.insertBefore(newNodes[i], item);
	        }
	        parent.removeChild(item);
	    };
	    WordDomTransformer.prototype.encodeWords = function (dom, item, conversation, mePerson) {
	        var _this = this;
	        var text = item.nodeValue, words = this.getAllWords(text), textPointer = 0, nodes = new Array();
	        words.forEach(function (wordMatch) {
	            var wordXml = _this.wordRawToXml(dom, wordMatch[0], conversation, mePerson);
	            if (wordXml.length === 0) {
	                return;
	            }
	            if (textPointer !== wordMatch.index) {
	                nodes.push(dom.createTextNode(text.substring(textPointer, wordMatch.index)));
	            }
	            textPointer = wordMatch.index + wordMatch[0].length;
	            nodes = nodes.concat(wordXml);
	        });
	        if (textPointer !== 0 && textPointer < text.length) {
	            nodes.push(dom.createTextNode(text.substring(textPointer)));
	        }
	        return nodes;
	    };
	    WordDomTransformer.prototype.pushChildNodes = function (stack, item) {
	        for (var i = 0; i < item.childNodes.length; i++) {
	            stack.push(item.childNodes[i]);
	        }
	    };
	    return WordDomTransformer;
	}());
	exports.WordDomTransformer = WordDomTransformer;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var browser_1 = __webpack_require__(41);
	var debounce = __webpack_require__(140);
	var StyleMode = (function () {
	    function StyleMode() {
	        var _this = this;
	        this.dispose = function () {
	            browser_1.default.getWindow().removeEventListener('resize', _this.windowResizeHandler);
	        };
	        this.getCurrentStyle = function () {
	            var width = browser_1.default.getWindow().innerWidth;
	            if (width < 356) {
	                return StyleModes.NARROW;
	            }
	            return StyleModes.NORMAL;
	        };
	        this.onResize = function () {
	            _this._currentStyle(_this.getCurrentStyle());
	        };
	        var RESIZE_DELAY = 500;
	        this.windowResizeHandler = debounce(this.onResize, RESIZE_DELAY);
	        this._currentStyle = ko.observable(this.getCurrentStyle());
	        browser_1.default.getWindow().addEventListener('resize', this.windowResizeHandler);
	    }
	    Object.defineProperty(StyleMode, "instance", {
	        get: function () {
	            if (!StyleMode._instance) {
	                StyleMode._instance = new StyleMode();
	            }
	            return StyleMode._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StyleMode.prototype, "CurrentStyle", {
	        get: function () {
	            return this._currentStyle();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return StyleMode;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StyleMode;
	(function (StyleModes) {
	    StyleModes[StyleModes["NARROW"] = 0] = "NARROW";
	    StyleModes[StyleModes["NORMAL"] = 1] = "NORMAL";
	})(exports.StyleModes || (exports.StyleModes = {}));
	var StyleModes = exports.StyleModes;


/***/ },
/* 140 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;
	
	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};
	
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;
	
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	
	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }
	
	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }
	
	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;
	
	    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	  }
	
	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;
	
	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }
	
	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }
	
	  function trailingEdge(time) {
	    timerId = undefined;
	
	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }
	
	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }
	
	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }
	
	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);
	
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;
	
	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = debounce;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var image_1 = __webpack_require__(135);
	var enums_1 = __webpack_require__(118);
	var utils_1 = __webpack_require__(129);
	var action_1 = __webpack_require__(136);
	var i18n_1 = __webpack_require__(112);
	var utils_2 = __webpack_require__(129);
	var SwiftCardSection = (function () {
	    function SwiftCardSection(sectionJson, conversation, senderId, contentType) {
	        var _this = this;
	        this.mapImages = function (images, conv, senderId, contentType) {
	            var result = [];
	            images.forEach(function (item) {
	                result.push(new image_1.default(item || {}, conv, senderId, contentType));
	            });
	            return result;
	        };
	        this.expandedText = function () {
	            return _this.subtitle === '' || _this.title === '';
	        };
	        this.isValid = function () {
	            return !!_this.title || !!_this.subtitle || !!_this.text || _this.images.length !== 0;
	        };
	        this.getTitleByType = function () {
	            switch (_this.tap.type) {
	                case enums_1.SwiftCardActionType.call:
	                case enums_1.SwiftCardActionType.imBack:
	                    return _this.createSectionTitle();
	                case enums_1.SwiftCardActionType.openUrl:
	                    return _this.createSectionTitle() + '\n\n' + _this.tap.value;
	                default:
	                    break;
	            }
	            return '';
	        };
	        this.createSectionTitle = function () {
	            return i18n_1.default.fetch('accessibility_swift_action_prefix', {
	                swiftAction: _this.lowerFirstLetter(_this.tap.title)
	            });
	        };
	        this.lowerFirstLetter = function (value) {
	            return value[0].toLowerCase() + value.substring(1);
	        };
	        var image = new image_1.default(sectionJson.image || {}, conversation, senderId, contentType);
	        this.title = utils_1.default.normalizeRichText(sectionJson.title);
	        this.subtitle = utils_1.default.normalizeRichText(sectionJson.subtitle);
	        this.text = utils_1.default.normalizeRichText(sectionJson.text);
	        this.price = utils_1.default.normalizeRichText(sectionJson.price);
	        this.images = sectionJson.images ? this.mapImages(sectionJson.images, conversation, senderId, contentType) : [];
	        if (this.images.length === 0 && sectionJson.image && sectionJson.image.url) {
	            this.images.push(image);
	        }
	        this.tap = sectionJson.tap ? utils_2.default.getItemIfNotDisabled(new action_1.default(sectionJson.tap || {}, conversation, senderId)) : null;
	    }
	    return SwiftCardSection;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SwiftCardSection;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(129);
	var Fact = (function () {
	    function Fact(factJson) {
	        var _this = this;
	        this.isValid = function () {
	            return !!_this.key || !!_this.value;
	        };
	        this.key = utils_1.default.normalizeRichText(factJson.key);
	        this.value = utils_1.default.normalizeRichText(factJson.value);
	    }
	    return Fact;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Fact;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var utils_1 = __webpack_require__(129);
	var enums_1 = __webpack_require__(118);
	var image_1 = __webpack_require__(135);
	var Media = (function () {
	    function Media(source, conversation, senderId, type) {
	        var _this = this;
	        this.isValid = function () {
	            return !!_this.video || !!_this.audio || (!!_this.animation || !!_this.animation.url);
	        };
	        this.getSourceDomain = function (url) {
	            var replaced = url.replace(/^(https?:\/\/)?(w*\.)?/i, ''), separator = '/';
	            return replaced ? replaced.split(separator)[0] : null;
	        };
	        this.url = source.url ? utils_1.default.normalizeUrl(source.url) : null;
	        if (this.url) {
	            switch (type) {
	                case enums_1.SwiftCardContentType.video:
	                    this.video = this.url;
	                    break;
	                case enums_1.SwiftCardContentType.audio:
	                    this.audio = this.url;
	                    break;
	                case enums_1.SwiftCardContentType.animation:
	                    this.animation = new image_1.default(source || {}, conversation, senderId, type);
	            }
	        }
	        this.sourceDomain = this.url ? this.getSourceDomain(this.url) : null;
	    }
	    return Media;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Media;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var action_1 = __webpack_require__(136);
	var enums_1 = __webpack_require__(118);
	var SuggestedActions = (function (_super) {
	    __extends(SuggestedActions, _super);
	    function SuggestedActions(actionJson, conversation, senderId) {
	        _super.call(this, actionJson, conversation, senderId);
	        this.actionType = enums_1.SwiftCardActionType.unknown;
	        this.actionType = actionJson.type;
	        this.image_url = actionJson.image ? actionJson.image : null;
	    }
	    return SuggestedActions;
	}(action_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SuggestedActions;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var enums_1 = __webpack_require__(118);
	var content_1 = __webpack_require__(134);
	var AC = __webpack_require__(146);
	var hostConfigOutlook = {
	    "supportsInteractivity": true,
	    "strongSeparation": {
	        "spacing": 40,
	        "lineThickness": 1,
	        "lineColor": "#EEEEEE"
	    },
	    "fontFamily": "Segoe UI, sans-serif",
	    "fontSizes": {
	        "small": 12,
	        "normal": 14,
	        "medium": 17,
	        "large": 21,
	        "extraLarge": 26
	    },
	    "fontWeights": {
	        "lighter": 200,
	        "normal": 400,
	        "bolder": 600
	    },
	    "colors": {
	        "dark": {
	            "normal": "#333333",
	            "subtle": "#EE333333"
	        },
	        "light": {
	            "normal": "#FFFFFF",
	            "subtle": "#88FFFFFF"
	        },
	        "accent": {
	            "normal": "#2E89FC",
	            "subtle": "#882E89FC"
	        },
	        "attention": {
	            "normal": "#FFD800",
	            "subtle": "#DDFFD800"
	        },
	        "good": {
	            "normal": "#00FF00",
	            "subtle": "#DD00FF00"
	        },
	        "warning": {
	            "normal": "#FF0000",
	            "subtle": "#DDFF0000"
	        }
	    },
	    "imageSizes": {
	        "small": 40,
	        "medium": 60,
	        "large": 160
	    },
	    "actions": {
	        "maxActions": 5,
	        "separation": {
	            "spacing": 20
	        },
	        "buttonSpacing": 20,
	        "stretch": false,
	        "showCard": {
	            "actionMode": "InlineEdgeToEdge",
	            "inlineCardSpacing": 16,
	            "backgroundColor": "#08000000",
	            "padding": {
	                "top": 16,
	                "right": 16,
	                "bottom": 16,
	                "left": 16
	            }
	        },
	        "actionsOrientation": "Horizontal",
	        "actionAlignment": "Left"
	    },
	    "adaptiveCard": {
	        "backgroundColor": "#00000000",
	        "padding": {
	            "left": 20,
	            "top": 20,
	            "right": 20,
	            "bottom": 20
	        }
	    },
	    "container": {
	        "separation": {
	            "spacing": 20
	        },
	        "normal": {},
	        "emphasis": {
	            "backgroundColor": "#EEEEEE",
	            "borderColor": "#AAAAAA",
	            "borderThickness": {
	                "top": 1,
	                "right": 1,
	                "bottom": 1,
	                "left": 1
	            },
	            "padding": {
	                "top": 10,
	                "right": 10,
	                "bottom": 10,
	                "left": 10
	            }
	        }
	    },
	    "textBlock": {
	        "color": "Dark",
	        "separations": {
	            "small": {
	                "spacing": 20
	            },
	            "normal": {
	                "spacing": 20
	            },
	            "medium": {
	                "spacing": 20
	            },
	            "large": {
	                "spacing": 20
	            },
	            "extraLarge": {
	                "spacing": 20
	            }
	        }
	    },
	    "image": {
	        "size": "Medium",
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "imageSet": {
	        "imageSize": "Medium",
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "factSet": {
	        "separation": {
	            "spacing": 20
	        },
	        "title": {
	            "color": "Dark",
	            "size": "Normal",
	            "isSubtle": false,
	            "weight": "Bolder"
	        },
	        "value": {
	            "color": "Dark",
	            "size": "Normal",
	            "isSubtle": false,
	            "weight": "Normal"
	        },
	        "spacing": 10
	    },
	    "input": {
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "columnSet": {
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "column": {
	        "separation": {
	            "spacing": 20
	        }
	    }
	};
	var hostConfigSkype = {
	    "supportsInteractivity": true,
	    "strongSeparation": {
	        "spacing": 40,
	        "lineThickness": 1,
	        "lineColor": "#EEEEEE"
	    },
	    "fontFamily": "Segoe UI, sans-serif",
	    "fontSizes": {
	        "small": 12,
	        "normal": 14,
	        "medium": 17,
	        "large": 21,
	        "extraLarge": 26
	    },
	    "fontWeights": {
	        "lighter": 200,
	        "normal": 400,
	        "bolder": 600
	    },
	    "colors": {
	        "dark": {
	            "normal": "#333333",
	            "subtle": "#EE333333"
	        },
	        "light": {
	            "normal": "#FFFFFF",
	            "subtle": "#88FFFFFF"
	        },
	        "accent": {
	            "normal": "#2E89FC",
	            "subtle": "#882E89FC"
	        },
	        "attention": {
	            "normal": "#FFD800",
	            "subtle": "#DDFFD800"
	        },
	        "good": {
	            "normal": "#00FF00",
	            "subtle": "#DD00FF00"
	        },
	        "warning": {
	            "normal": "#FF0000",
	            "subtle": "#DDFF0000"
	        }
	    },
	    "imageSizes": {
	        "small": 40,
	        "medium": 60,
	        "large": 160
	    },
	    "actions": {
	        "maxActions": 5,
	        "separation": {
	            "spacing": 20
	        },
	        "buttonSpacing": 20,
	        "stretch": false,
	        "showCard": {
	            "actionMode": "popup",
	            "inlineCardSpacing": 16,
	            "backgroundColor": "#AEEAEAEA",
	            "padding": {
	                "top": 16,
	                "right": 16,
	                "bottom": 16,
	                "left": 16
	            }
	        },
	        "actionsOrientation": "vertical",
	        "actionAlignment": "center"
	    },
	    "adaptiveCard": {
	        "backgroundColor": "#AEEAEAEA",
	        "padding": {
	            "left": 20,
	            "top": 20,
	            "right": 20,
	            "bottom": 20
	        }
	    },
	    "container": {
	        "separation": {
	            "spacing": 20
	        },
	        "normal": {},
	        "emphasis": {
	            "backgroundColor": "#EEEEEE",
	            "borderColor": "#AAAAAA",
	            "borderThickness": {
	                "top": 1,
	                "right": 1,
	                "bottom": 1,
	                "left": 1
	            },
	            "padding": {
	                "top": 10,
	                "right": 10,
	                "bottom": 10,
	                "left": 10
	            }
	        }
	    },
	    "textBlock": {
	        "color": "dark",
	        "separations": {
	            "small": {
	                "spacing": 20
	            },
	            "normal": {
	                "spacing": 20
	            },
	            "medium": {
	                "spacing": 20
	            },
	            "large": {
	                "spacing": 20
	            },
	            "extraLarge": {
	                "spacing": 20
	            }
	        }
	    },
	    "image": {
	        "size": "medium",
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "imageSet": {
	        "imageSize": "medium",
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "factSet": {
	        "separation": {
	            "spacing": 20
	        },
	        "title": {
	            "color": "dark",
	            "size": "normal",
	            "isSubtle": false,
	            "weight": "bolder"
	        },
	        "value": {
	            "color": "dark",
	            "size": "normal",
	            "isSubtle": false,
	            "weight": "normal"
	        },
	        "spacing": 10
	    },
	    "input": {
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "columnSet": {
	        "separation": {
	            "spacing": 20
	        }
	    },
	    "column": {
	        "separation": {
	            "spacing": 20
	        }
	    }
	};
	var AdaptiveCard = (function (_super) {
	    __extends(AdaptiveCard, _super);
	    function AdaptiveCard(content, conversation, element) {
	        var _this = this;
	        _super.call(this);
	        this.element = element;
	        this._actionHandlers = {};
	        this._processNodes = function (nodes, output) {
	            for (var i = 0; i < nodes.length; i++) {
	                var node = nodes[i];
	                if (node.nodeName === 'p') {
	                    _this._processNodes(node.childNodes, output);
	                    output.push(250);
	                }
	                else if (node.nodeName === 's') {
	                    _this._processNodes(node.childNodes, output);
	                    output.push(100);
	                }
	                else if (node.nodeName === 'break') {
	                    if (node.attributes['strength']) {
	                        var strength = node.attributes['strength'].nodeValue;
	                        if (strength === 'weak') {
	                        }
	                        else if (strength === 'medium') {
	                            output.push(50);
	                        }
	                        else if (strength === 'strong') {
	                            output.push(100);
	                        }
	                        else if (strength === 'x-strong') {
	                            output.push(250);
	                        }
	                    }
	                    else if (node.attributes['time']) {
	                        output.push(JSON.parse(node.attributes['time'].value));
	                    }
	                }
	                else if (node.nodeName === 'audio') {
	                    if (node.attributes['src']) {
	                        output.push(node.attributes['src'].value);
	                    }
	                }
	                else if (node.nodeName === 'say-as') {
	                    _this._processNodes(node.childNodes, output);
	                }
	                else if (node.nodeName === 'w') {
	                    _this._processNodes(node.childNodes, output);
	                }
	                else if (node.nodeName === 'phoneme') {
	                    _this._processNodes(node.childNodes, output);
	                }
	                else {
	                    output.push(node.nodeValue);
	                }
	            }
	        };
	        this._renderContent = function () {
	            _this._element.parentElement.insertBefore(_this._content, _this._element);
	        };
	        this._playSpeech = function (output, iCurrent) {
	            if (iCurrent < output.length) {
	                var current = output[iCurrent];
	                if (typeof current === "number") {
	                    setTimeout(function () {
	                        _this._playSpeech(output, iCurrent + 1);
	                    }, current);
	                }
	                else {
	                    if (current.indexOf("http") === 0) {
	                        _this._audioContainer.autoplay = true;
	                        _this._audioContainer.src = current;
	                        _this._audioContainer.onended = function () {
	                            this._playSpeech(output, iCurrent + 1);
	                        };
	                        _this._audioContainer.onerror = function () {
	                            this._playSpeech(output, iCurrent + 1);
	                        };
	                        _this._audioContainer.play();
	                    }
	                    else {
	                        var SpeechSynthesisUtterance = window.SpeechSynthesisUtterance;
	                        var msg = new SpeechSynthesisUtterance();
	                        if (!window.speechSynthesis || !msg) {
	                            console.warn('SpeechSynthesisUtterance not supported in this browser');
	                            return;
	                        }
	                        //msg.voiceURI = 'native';
	                        // msg.volume = 1; // 0 to 1
	                        // msg.rate = 1; // 0.1 to 10
	                        // msg.pitch = 2; //0 to 2
	                        msg.text = current;
	                        msg.lang = 'en-US';
	                        msg.onerror = function (event) {
	                            _this._playSpeech(output, iCurrent + 1);
	                        };
	                        msg.onend = function (event) {
	                            _this._playSpeech(output, iCurrent + 1);
	                        };
	                        window.speechSynthesis.speak(msg);
	                    }
	                }
	            }
	        };
	        this._renderSpeech = function () {
	            var element = document.createElement('div');
	            element.setAttribute('style', 'text-align: right; padding: 5px');
	            var button = document.createElement('button');
	            button.innerHTML = window.SkypeWebControl.Assets.SVG.iconSpeaker;
	            button.setAttribute('style', 'background: transparent; border: 0; cursor: pointer');
	            button.className = 'button';
	            //button.innerText = 'Speak this card';
	            var output = new Array();
	            if (_this._speechString[0] == '<') {
	                if (_this._speechString.indexOf('<speak') != 0) {
	                    _this._speechString = '<speak>\n' + _this._speechString + '\n</speak>\n';
	                }
	                var parser = new DOMParser(), dom = parser.parseFromString(_this._speechString, 'text/xml'), nodes = dom.documentElement.childNodes;
	                _this._processNodes(nodes, output);
	                var serializer = new XMLSerializer();
	                _this._speechString = serializer.serializeToString(dom);
	            }
	            else {
	                output.push(_this._speechString);
	            }
	            button.addEventListener('click', function () {
	                _this._playSpeech(output, 0);
	            });
	            element.appendChild(button);
	            element.appendChild(_this._audioContainer);
	            _this._element.parentElement.insertBefore(element, _this._element);
	        };
	        this.executeAction = function (action) {
	            var handler = _this._actionHandlers[action.constructor.name];
	            if (action) {
	                handler(action);
	            }
	        };
	        this.submit = function (action) {
	            if (!action.data) {
	                return;
	            }
	            return _this._conversation.sendSwift(action.data)
	                .then(function () {
	                return Promise.resolve();
	            }).catch(function () {
	                // TODO: add message not send error handling?
	                console.warn('unable to send message');
	            });
	        };
	        this.isValid = function () {
	            return !!_this._content;
	        };
	        this.isSupported = function () {
	            return _this.isValid();
	        };
	        this._element = element;
	        this._conversation = conversation;
	        this._audioContainer = document.createElement('audio');
	        var AdaptiveCard = AC;
	        AdaptiveCard.setConfiguration(hostConfigOutlook);
	        if (!content) {
	            return;
	        }
	        this._adaptiveCard = new AdaptiveCard.AdaptiveCard();
	        this.type = enums_1.SwiftCardContentType.adaptive;
	        this._adaptiveCard.parse(content);
	        this._content = this._adaptiveCard.render();
	        this._speechString = this._adaptiveCard.renderSpeech();
	        this._actionHandlers['OpenUrlAction'] = this.openUrl;
	        this._actionHandlers['Action.ShowCard'] = this.showCard;
	        this._actionHandlers['HttpAction'] = this.httpAction;
	        this._actionHandlers['SubmitAction'] = this.submit;
	        AdaptiveCard.AdaptiveCard.onExecuteAction = this.executeAction;
	        this._renderContent();
	        this._renderSpeech();
	    }
	    AdaptiveCard.prototype.openUrl = function (action) {
	        if (!action.url) {
	            return;
	        }
	        if (action.url.match(/^skype:\?payments/)) {
	            console.warn('Payments action not supported');
	        }
	        else if (action.url.match(/^skype:/)) {
	            console.warn('Calling is not supported');
	        }
	        var newWindow = window.open(action.url, '_blank');
	        newWindow.opener = null;
	    };
	    AdaptiveCard.prototype.showCard = function (action) {
	        console.warn('ShowAction not supported');
	    };
	    AdaptiveCard.prototype.httpAction = function (action) {
	        console.warn('HttpAction not supported');
	        /*if (!action.url) {
	         return
	         }
	         let method = action.method ? action.method.toLowerCase() : null;
	         if (method === 'post') {
	         requestHelper.post('httpActionPost', action.url, action.data);
	         return;
	         }
	         if (method === 'get') {
	         requestHelper.get('httpActionGet', action.url);
	         }*/
	    };
	    return AdaptiveCard;
	}(content_1.BaseContent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AdaptiveCard;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(__webpack_require__(147));
	__export(__webpack_require__(148));
	__export(__webpack_require__(151));
	//# sourceMappingURL=adaptive-cards.js.map


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var Enums = __webpack_require__(148);
	var Utils = __webpack_require__(149);
	var TextFormatters = __webpack_require__(150);
	function invokeSetParent(obj, parent) {
	    // This is not super pretty, but it the closest emulation of
	    // "internal" in TypeScript.
	    obj["setParent"](parent);
	}
	function isActionAllowed(action, forbiddenActionTypes) {
	    if (forbiddenActionTypes) {
	        for (var i = 0; i < forbiddenActionTypes.length; i++) {
	            if (action.getJsonTypeName() === forbiddenActionTypes[i]) {
	                return false;
	            }
	        }
	    }
	    if (!hostConfiguration.actions.supportedActionTypes) {
	        return true;
	    }
	    for (var i = 0; i < hostConfiguration.actions.supportedActionTypes.length; i++) {
	        if (action.getJsonTypeName() === hostConfiguration.actions.supportedActionTypes[i]) {
	            return true;
	        }
	    }
	    return false;
	}
	function isElementAllowed(element, forbiddenElementTypes) {
	    if (!hostConfiguration.supportsInteractivity && element.isInteractive) {
	        return false;
	    }
	    if (forbiddenElementTypes) {
	        for (var i = 0; i < forbiddenElementTypes.length; i++) {
	            if (element.getJsonTypeName() === forbiddenElementTypes[i]) {
	                return false;
	            }
	        }
	    }
	    if (!hostConfiguration.supportedElementTypes) {
	        return true;
	    }
	    for (var i = 0; i < hostConfiguration.supportedElementTypes.length; i++) {
	        if (element.getJsonTypeName() === hostConfiguration.supportedElementTypes[i]) {
	            return true;
	        }
	    }
	    return false;
	}
	var CardElement = (function () {
	    function CardElement() {
	        this._parent = null;
	        this.horizontalAlignment = "left";
	    }
	    CardElement.prototype.internalGetNonZeroPadding = function (element, padding) {
	        if (padding.top == 0) {
	            padding.top = element.padding.top;
	        }
	        if (padding.right == 0) {
	            padding.right = element.padding.right;
	        }
	        if (padding.bottom == 0) {
	            padding.bottom = element.padding.bottom;
	        }
	        if (padding.left == 0) {
	            padding.left = element.padding.left;
	        }
	        if (element.parent) {
	            this.internalGetNonZeroPadding(element.parent, padding);
	        }
	    };
	    CardElement.prototype.showBottomSpacer = function (requestingElement) {
	        if (this.parent) {
	            this.parent.showBottomSpacer(this);
	        }
	    };
	    CardElement.prototype.hideBottomSpacer = function (requestingElement) {
	        if (this.parent) {
	            this.parent.hideBottomSpacer(this);
	        }
	    };
	    CardElement.prototype.setParent = function (value) {
	        this._parent = value;
	    };
	    Object.defineProperty(CardElement.prototype, "useDefaultSizing", {
	        get: function () {
	            return true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CardElement.prototype.adjustAlignment = function (element) {
	        if (this.horizontalAlignment != "left") {
	            element.style.textAlign = this.horizontalAlignment;
	        }
	    };
	    CardElement.prototype.adjustLayout = function (element) {
	        element.style.boxSizing = "border-box";
	        if (this.useDefaultSizing) {
	            element.style.width = "100%";
	        }
	        this.adjustAlignment(element);
	    };
	    CardElement.prototype.getNonZeroPadding = function () {
	        var padding = { top: 0, right: 0, bottom: 0, left: 0 };
	        this.internalGetNonZeroPadding(this, padding);
	        return padding;
	    };
	    CardElement.prototype.getForbiddenElementTypes = function () {
	        return null;
	    };
	    CardElement.prototype.getForbiddenActionTypes = function () {
	        return null;
	    };
	    CardElement.prototype.parse = function (json) {
	        this.speak = json["speak"];
	        this.horizontalAlignment = json["horizontalAlignment"];
	        this.separation = Utils.getValueOrDefault(json["separation"], "default");
	    };
	    CardElement.prototype.validate = function () {
	        return [];
	    };
	    CardElement.prototype.render = function () {
	        var renderedElement = this.internalRender();
	        if (renderedElement != null) {
	            this.adjustLayout(renderedElement);
	        }
	        return renderedElement;
	    };
	    CardElement.prototype.isLastItem = function (item) {
	        return this.parent ? this.parent.isLastItem(item) : true;
	    };
	    CardElement.prototype.getRootElement = function () {
	        var rootElement = this;
	        while (rootElement.parent) {
	            rootElement = rootElement.parent;
	        }
	        return rootElement;
	    };
	    CardElement.prototype.getAllInputs = function () {
	        return [];
	    };
	    Object.defineProperty(CardElement.prototype, "padding", {
	        get: function () {
	            return { top: 0, right: 0, bottom: 0, left: 0 };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CardElement.prototype, "isInteractive", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CardElement.prototype, "parent", {
	        get: function () {
	            return this._parent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CardElement;
	}());
	exports.CardElement = CardElement;
	var TextBlock = (function (_super) {
	    __extends(TextBlock, _super);
	    function TextBlock() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.size = "normal";
	        _this.weight = "normal";
	        _this.isSubtle = false;
	        _this.wrap = true;
	        return _this;
	    }
	    TextBlock.prototype.internalRender = function () {
	        if (!Utils.isNullOrEmpty(this.text)) {
	            var element = document.createElement("div");
	            element.style.fontFamily = hostConfiguration.fontFamily;
	            var cssStyle = "text ";
	            var fontSize;
	            switch (this.size) {
	                case "small":
	                    fontSize = hostConfiguration.fontSizes.small;
	                    break;
	                case "medium":
	                    fontSize = hostConfiguration.fontSizes.medium;
	                    break;
	                case "large":
	                    fontSize = hostConfiguration.fontSizes.large;
	                    break;
	                case "extraLarge":
	                    fontSize = hostConfiguration.fontSizes.extraLarge;
	                    break;
	                default:
	                    fontSize = hostConfiguration.fontSizes.normal;
	                    break;
	            }
	            element.style.fontSize = fontSize + "px";
	            var actualTextColor = this.color ? this.color : hostConfiguration.textBlock.color;
	            var colorDefinition;
	            switch (actualTextColor) {
	                case "dark":
	                    colorDefinition = hostConfiguration.colors.dark;
	                    break;
	                case "light":
	                    colorDefinition = hostConfiguration.colors.light;
	                    break;
	                case "accent":
	                    colorDefinition = hostConfiguration.colors.accent;
	                    break;
	                case "good":
	                    colorDefinition = hostConfiguration.colors.good;
	                    break;
	                case "warning":
	                    colorDefinition = hostConfiguration.colors.warning;
	                    break;
	                case "attention":
	                    colorDefinition = hostConfiguration.colors.attention;
	                    break;
	                default:
	                    colorDefinition = hostConfiguration.colors.dark;
	                    break;
	            }
	            element.style.color = Utils.stringToCssColor(this.isSubtle ? colorDefinition.subtle : colorDefinition.normal);
	            var fontWeight;
	            switch (this.weight) {
	                case "lighter":
	                    fontWeight = hostConfiguration.fontWeights.lighter;
	                    break;
	                case "bolder":
	                    fontWeight = hostConfiguration.fontWeights.bolder;
	                    break;
	                default:
	                    fontWeight = hostConfiguration.fontWeights.normal;
	                    break;
	            }
	            element.style.fontWeight = fontWeight.toString();
	            var formattedText = TextFormatters.formatText(this.text);
	            element.innerHTML = Utils.processMarkdown(formattedText);
	            // element.innerHTML = formattedText;
	            if (element.firstElementChild instanceof HTMLElement) {
	                var firstElementChild = element.firstElementChild;
	                firstElementChild.style.marginTop = "0px";
	                if (!this.wrap) {
	                    firstElementChild.style.overflow = "hidden";
	                    firstElementChild.style.textOverflow = "ellipsis";
	                }
	            }
	            if (element.lastElementChild instanceof HTMLElement) {
	                element.lastElementChild.style.marginBottom = "0px";
	            }
	            var anchors = element.getElementsByTagName("a");
	            for (var i = 0; i < anchors.length; i++) {
	                anchors[i].target = "_blank";
	            }
	            if (this.wrap) {
	                element.style.wordWrap = "break-word";
	            }
	            else {
	                element.style.whiteSpace = "nowrap";
	            }
	            return element;
	        }
	        else {
	            return null;
	        }
	    };
	    TextBlock.prototype.getJsonTypeName = function () {
	        return "TextBlock";
	    };
	    TextBlock.prototype.getDefaultSeparationDefinition = function () {
	        switch (this.size) {
	            case "small":
	                return hostConfiguration.textBlock.separations.small;
	            case "medium":
	                return hostConfiguration.textBlock.separations.medium;
	            case "large":
	                return hostConfiguration.textBlock.separations.large;
	            case "extraLarge":
	                return hostConfiguration.textBlock.separations.extraLarge;
	            default:
	                return hostConfiguration.textBlock.separations.normal;
	        }
	    };
	    TextBlock.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.text = json["text"];
	        this.size = Utils.getValueOrDefault(json["size"], "normal");
	        this.weight = Utils.getValueOrDefault(json["weight"], "normal");
	        this.color = Utils.getValueOrDefault(json["color"], hostConfiguration.textBlock.color);
	        this.isSubtle = json["isSubtle"];
	        this.wrap = json["wrap"] === undefined ? true : json["wrap"];
	        this.maxLines = json["maxLines"];
	    };
	    TextBlock.prototype.renderSpeech = function () {
	        if (this.speak != null)
	            return this.speak + '\n';
	        if (this.text)
	            return '<s>' + this.text + '</s>\n';
	        return null;
	    };
	    return TextBlock;
	}(CardElement));
	exports.TextBlock = TextBlock;
	var InternalTextBlock = (function (_super) {
	    __extends(InternalTextBlock, _super);
	    function InternalTextBlock() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Object.defineProperty(InternalTextBlock.prototype, "useDefaultSizing", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return InternalTextBlock;
	}(TextBlock));
	var Fact = (function () {
	    function Fact() {
	    }
	    Fact.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak + '\n';
	        }
	        return '<s>' + this.name + ' ' + this.value + '</s>\n';
	    };
	    return Fact;
	}());
	exports.Fact = Fact;
	var FactSet = (function (_super) {
	    __extends(FactSet, _super);
	    function FactSet() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.facts = [];
	        return _this;
	    }
	    Object.defineProperty(FactSet.prototype, "useDefaultSizing", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    FactSet.prototype.internalRender = function () {
	        var element = null;
	        if (this.facts.length > 0) {
	            element = document.createElement("table");
	            element.style.borderWidth = "0px";
	            element.style.borderSpacing = "0px";
	            element.style.borderStyle = "none";
	            element.style.borderCollapse = "collapse";
	            for (var i = 0; i < this.facts.length; i++) {
	                var trElement = document.createElement("tr");
	                if (i > 0) {
	                    trElement.style.marginTop = hostConfiguration.factSet.spacing + "px";
	                }
	                var tdElement = document.createElement("td");
	                tdElement.className = "factNameContainer";
	                var textBlock = new InternalTextBlock();
	                textBlock.text = this.facts[i].name;
	                textBlock.size = hostConfiguration.factSet.title.size;
	                textBlock.color = hostConfiguration.factSet.title.color;
	                textBlock.isSubtle = hostConfiguration.factSet.title.isSubtle;
	                textBlock.weight = hostConfiguration.factSet.title.weight;
	                textBlock.separation = "none";
	                Utils.appendChild(tdElement, textBlock.render());
	                Utils.appendChild(trElement, tdElement);
	                tdElement = document.createElement("td");
	                tdElement.className = "factValueContainer";
	                textBlock = new InternalTextBlock();
	                textBlock.text = this.facts[i].value;
	                textBlock.size = hostConfiguration.factSet.value.size;
	                textBlock.color = hostConfiguration.factSet.value.color;
	                textBlock.isSubtle = hostConfiguration.factSet.value.isSubtle;
	                textBlock.weight = hostConfiguration.factSet.value.weight;
	                textBlock.separation = "none";
	                Utils.appendChild(tdElement, textBlock.render());
	                Utils.appendChild(trElement, tdElement);
	                Utils.appendChild(element, trElement);
	            }
	        }
	        return element;
	    };
	    FactSet.prototype.getJsonTypeName = function () {
	        return "FactSet";
	    };
	    FactSet.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.factSet.separation;
	    };
	    FactSet.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        if (json["facts"] != null) {
	            var jsonFacts = json["facts"];
	            for (var i = 0; i < jsonFacts.length; i++) {
	                var fact = new Fact();
	                fact.name = jsonFacts[i]["title"];
	                fact.value = jsonFacts[i]["value"];
	                fact.speak = jsonFacts[i]["speak"];
	                this.facts.push(fact);
	            }
	        }
	    };
	    FactSet.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak + '\n';
	        }
	        // render each fact 
	        var speak = null;
	        if (this.facts.length > 0) {
	            speak = '';
	            for (var i = 0; i < this.facts.length; i++) {
	                var speech = this.facts[i].renderSpeech();
	                if (speech) {
	                    speak += speech;
	                }
	            }
	        }
	        return '<p>' + speak + '\n</p>\n';
	    };
	    return FactSet;
	}(CardElement));
	exports.FactSet = FactSet;
	var Image = (function (_super) {
	    __extends(Image, _super);
	    function Image() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.style = "normal";
	        _this.size = "medium";
	        return _this;
	    }
	    Object.defineProperty(Image.prototype, "useDefaultSizing", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Image.prototype.adjustAlignment = function (element) {
	        switch (this.horizontalAlignment) {
	            case "center":
	                element.style.marginLeft = "auto";
	                element.style.marginRight = "auto";
	                break;
	            case "right":
	                element.style.marginLeft = "auto";
	                break;
	        }
	    };
	    Image.prototype.internalRender = function () {
	        var _this = this;
	        var imageElement = null;
	        if (!Utils.isNullOrEmpty(this.url)) {
	            imageElement = document.createElement("img");
	            imageElement.style.display = "block";
	            imageElement.onclick = function (e) {
	                if (_this.selectAction != null) {
	                    raiseExecuteActionEvent(_this.selectAction);
	                    e.cancelBubble = true;
	                }
	            };
	            imageElement.classList.add("image");
	            if (this.selectAction != null) {
	                imageElement.classList.add("selectable");
	            }
	            switch (this.size) {
	                case "auto":
	                    imageElement.style.maxWidth = "100%";
	                    break;
	                case "stretch":
	                    imageElement.style.width = "100%";
	                    break;
	                case "small":
	                    imageElement.style.maxWidth = hostConfiguration.imageSizes.small + "px";
	                    break;
	                case "large":
	                    imageElement.style.maxWidth = hostConfiguration.imageSizes.large + "px";
	                    break;
	                default:
	                    imageElement.style.maxWidth = hostConfiguration.imageSizes.medium + "px";
	                    break;
	            }
	            if (this.style == "person") {
	                imageElement.classList.add("person");
	            }
	            imageElement.src = this.url;
	        }
	        return imageElement;
	    };
	    Image.prototype.getJsonTypeName = function () {
	        return "Image";
	    };
	    Image.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.image.separation;
	    };
	    Image.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.url = json["url"];
	        this.style = Utils.getValueOrDefault(json["style"], "normal");
	        this.size = Utils.getValueOrDefault(json["size"], "medium");
	        var selectActionJson = json["selectAction"];
	        if (selectActionJson != undefined) {
	            this.selectAction = Action.createAction(selectActionJson);
	            invokeSetParent(this.selectAction, this);
	        }
	    };
	    Image.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak + '\n';
	        }
	        return null;
	    };
	    return Image;
	}(CardElement));
	exports.Image = Image;
	var ImageSet = (function (_super) {
	    __extends(ImageSet, _super);
	    function ImageSet() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._images = [];
	        _this.imageSize = "medium";
	        return _this;
	    }
	    ImageSet.prototype.internalRender = function () {
	        var element = null;
	        if (this._images.length > 0) {
	            element = document.createElement("div");
	            for (var i = 0; i < this._images.length; i++) {
	                var renderedImage = this._images[i].render();
	                // Default display for Image is "block" but that forces them to stack vertically
	                // in a div. So we need to override display and set it to "inline-block". The
	                // drawback is that it adds a small spacing at the bottom of each image, which
	                // simply can't be removed cleanly in a cross-browser compatible way.
	                renderedImage.style.display = "inline-block";
	                renderedImage.style.margin = "0px";
	                renderedImage.style.marginRight = "10px";
	                Utils.appendChild(element, renderedImage);
	            }
	        }
	        return element;
	    };
	    ImageSet.prototype.getJsonTypeName = function () {
	        return "ImageSet";
	    };
	    ImageSet.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.imageSet.separation;
	    };
	    ImageSet.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.imageSize = Utils.getValueOrDefault(json["imageSize"], "medium");
	        if (json["images"] != null) {
	            var jsonImages = json["images"];
	            for (var i = 0; i < jsonImages.length; i++) {
	                var image = new Image();
	                image.size = this.imageSize;
	                image.url = jsonImages[i]["url"];
	                this.addImage(image);
	            }
	        }
	    };
	    ImageSet.prototype.addImage = function (image) {
	        if (!image.parent) {
	            this._images.push(image);
	            invokeSetParent(image, this);
	        }
	        else {
	            throw new Error("This image already belongs to another ImageSet");
	        }
	    };
	    ImageSet.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak;
	        }
	        var speak = null;
	        if (this._images.length > 0) {
	            speak = '';
	            for (var i = 0; i < this._images.length; i++) {
	                speak += this._images[i].renderSpeech();
	            }
	        }
	        return speak;
	    };
	    return ImageSet;
	}(CardElement));
	exports.ImageSet = ImageSet;
	var Input = (function (_super) {
	    __extends(Input, _super);
	    function Input() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Input.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.input.separation;
	    };
	    Input.prototype.validate = function () {
	        if (!this.id) {
	            return [{ error: Enums.ValidationError.PropertyCantBeNull, message: "All inputs must have a unique Id" }];
	        }
	        else {
	            return [];
	        }
	    };
	    Input.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.id = json["id"];
	        this.defaultValue = json["value"];
	    };
	    Input.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak;
	        }
	        if (this.title) {
	            return '<s>' + this.title + '</s>\n';
	        }
	        return null;
	    };
	    Input.prototype.getAllInputs = function () {
	        return [this];
	    };
	    Object.defineProperty(Input.prototype, "isInteractive", {
	        get: function () {
	            return true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Input;
	}(CardElement));
	exports.Input = Input;
	var TextInput = (function (_super) {
	    __extends(TextInput, _super);
	    function TextInput() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TextInput.prototype.internalRender = function () {
	        this._textareaElement = document.createElement("textarea");
	        this._textareaElement.className = "input textInput";
	        if (this.isMultiline) {
	            this._textareaElement.classList.add("multiline");
	        }
	        if (!Utils.isNullOrEmpty(this.placeholder)) {
	            this._textareaElement.placeholder = this.placeholder;
	        }
	        if (!Utils.isNullOrEmpty(this.defaultValue)) {
	            this._textareaElement.textContent = this.defaultValue;
	        }
	        if (this.maxLength > 0) {
	            this._textareaElement.maxLength = this.maxLength;
	        }
	        return this._textareaElement;
	    };
	    TextInput.prototype.getJsonTypeName = function () {
	        return "Input.Text";
	    };
	    TextInput.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.maxLength = json["maxLength"];
	        this.isMultiline = json["isMultiline"];
	        this.placeholder = json["placeholder"];
	    };
	    Object.defineProperty(TextInput.prototype, "value", {
	        get: function () {
	            return this._textareaElement ? this._textareaElement.textContent : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TextInput;
	}(Input));
	exports.TextInput = TextInput;
	var ToggleInput = (function (_super) {
	    __extends(ToggleInput, _super);
	    function ToggleInput() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ToggleInput.prototype.internalRender = function () {
	        var element = document.createElement("div");
	        element.className = "input";
	        this._checkboxInputElement = document.createElement("input");
	        this._checkboxInputElement.className = "toggleInput";
	        this._checkboxInputElement.type = "checkbox";
	        if (this.defaultValue == this.valueOn) {
	            this._checkboxInputElement.checked = true;
	        }
	        var label = new InternalTextBlock();
	        label.text = this.title;
	        var labelElement = label.render();
	        labelElement.classList.add("toggleLabel");
	        var compoundInput = document.createElement("div");
	        Utils.appendChild(element, this._checkboxInputElement);
	        Utils.appendChild(element, labelElement);
	        return element;
	    };
	    ToggleInput.prototype.getJsonTypeName = function () {
	        return "Input.Toggle";
	    };
	    ToggleInput.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.title = json["title"];
	        this.valueOn = json["valueOn"];
	        this.valueOff = json["valueOff"];
	    };
	    Object.defineProperty(ToggleInput.prototype, "value", {
	        get: function () {
	            if (this._checkboxInputElement) {
	                return this._checkboxInputElement.checked ? this.valueOn : this.valueOff;
	            }
	            else {
	                return null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ToggleInput;
	}(Input));
	exports.ToggleInput = ToggleInput;
	var Choice = (function () {
	    function Choice() {
	    }
	    return Choice;
	}());
	exports.Choice = Choice;
	var ChoiceSetInput = (function (_super) {
	    __extends(ChoiceSetInput, _super);
	    function ChoiceSetInput() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.choices = [];
	        return _this;
	    }
	    ChoiceSetInput.prototype.internalRender = function () {
	        if (!this.isMultiSelect) {
	            if (this.isCompact) {
	                // Render as a combo box
	                this._selectElement = document.createElement("select");
	                this._selectElement.className = "input multichoiceInput";
	                var option = document.createElement("option");
	                option.selected = true;
	                option.disabled = true;
	                option.hidden = true;
	                option.text = this.placeholder;
	                Utils.appendChild(this._selectElement, option);
	                for (var i = 0; i < this.choices.length; i++) {
	                    var option = document.createElement("option");
	                    option.value = this.choices[i].value;
	                    option.text = this.choices[i].title;
	                    Utils.appendChild(this._selectElement, option);
	                }
	                return this._selectElement;
	            }
	            else {
	                // Render as a series of radio buttons
	                var element = document.createElement("div");
	                element.className = "input";
	                this._toggleInputs = [];
	                for (var i = 0; i < this.choices.length; i++) {
	                    var radioInput = document.createElement("input");
	                    radioInput.className = "toggleInput";
	                    radioInput.type = "radio";
	                    radioInput.name = this.id;
	                    radioInput.value = this.choices[i].value;
	                    this._toggleInputs.push(radioInput);
	                    var label = new InternalTextBlock();
	                    label.text = this.choices[i].title;
	                    var labelElement = label.render();
	                    labelElement.classList.add("toggleLabel");
	                    var compoundInput = document.createElement("div");
	                    Utils.appendChild(compoundInput, radioInput);
	                    Utils.appendChild(compoundInput, labelElement);
	                    Utils.appendChild(element, compoundInput);
	                }
	                return element;
	            }
	        }
	        else {
	            // Render as a list of toggle inputs
	            var element = document.createElement("div");
	            element.className = "input";
	            this._toggleInputs = [];
	            for (var i = 0; i < this.choices.length; i++) {
	                var checkboxInput = document.createElement("input");
	                checkboxInput.className = "toggleInput";
	                checkboxInput.type = "checkbox";
	                checkboxInput.value = this.choices[i].value;
	                this._toggleInputs.push(checkboxInput);
	                var label = new InternalTextBlock();
	                label.text = this.choices[i].title;
	                var labelElement = label.render();
	                labelElement.classList.add("toggleLabel");
	                var compoundInput = document.createElement("div");
	                Utils.appendChild(compoundInput, checkboxInput);
	                Utils.appendChild(compoundInput, labelElement);
	                Utils.appendChild(element, compoundInput);
	            }
	            return element;
	        }
	    };
	    ChoiceSetInput.prototype.getJsonTypeName = function () {
	        return "Input.ChoiceSet";
	    };
	    ChoiceSetInput.prototype.validate = function () {
	        var result = [];
	        if (this.choices.length == 0) {
	            result = [{ error: Enums.ValidationError.CollectionCantBeEmpty, message: "An Input.ChoiceSet must have at least one choice defined." }];
	        }
	        for (var i = 0; i < this.choices.length; i++) {
	            if (!this.choices[i].title || !this.choices[i].value) {
	                result = result.concat([{ error: Enums.ValidationError.PropertyCantBeNull, message: "All choices in an Input.ChoiceSet must have their title and value properties set." }]);
	                break;
	            }
	        }
	        return result;
	    };
	    ChoiceSetInput.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.isCompact = !(json["style"] === "expanded");
	        this.isMultiSelect = json["isMultiSelect"];
	        this.placeholder = json["placeholder"];
	        if (json["choices"] != undefined) {
	            var choiceArray = json["choices"];
	            for (var i = 0; i < choiceArray.length; i++) {
	                var choice = new Choice();
	                choice.title = choiceArray[i]["title"];
	                choice.value = choiceArray[i]["value"];
	                this.choices.push(choice);
	            }
	        }
	    };
	    Object.defineProperty(ChoiceSetInput.prototype, "value", {
	        get: function () {
	            if (!this.isMultiSelect) {
	                if (this.isCompact) {
	                    return this._selectElement ? this._selectElement.value : null;
	                }
	                else {
	                    if (this._toggleInputs.length == 0) {
	                        return null;
	                    }
	                    for (var i = 0; i < this._toggleInputs.length; i++) {
	                        if (this._toggleInputs[i].checked) {
	                            return this._toggleInputs[i].value;
	                        }
	                    }
	                    return null;
	                }
	            }
	            else {
	                if (this._toggleInputs.length == 0) {
	                    return null;
	                }
	                var result = "";
	                for (var i = 0; i < this._toggleInputs.length; i++) {
	                    if (this._toggleInputs[i].checked) {
	                        if (result != "") {
	                            result += ";";
	                        }
	                        result += this._toggleInputs[i].value;
	                    }
	                }
	                return result == "" ? null : result;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ChoiceSetInput;
	}(Input));
	exports.ChoiceSetInput = ChoiceSetInput;
	var NumberInput = (function (_super) {
	    __extends(NumberInput, _super);
	    function NumberInput() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    NumberInput.prototype.internalRender = function () {
	        this._numberInputElement = document.createElement("input");
	        this._numberInputElement.type = "number";
	        this._numberInputElement.className = "input number";
	        this._numberInputElement.min = this.min;
	        this._numberInputElement.max = this.max;
	        if (!Utils.isNullOrEmpty(this.defaultValue)) {
	            this._numberInputElement.value = this.defaultValue;
	        }
	        return this._numberInputElement;
	    };
	    NumberInput.prototype.getJsonTypeName = function () {
	        return "Input.Number";
	    };
	    NumberInput.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.min = json["min"];
	        this.max = json["max"];
	    };
	    Object.defineProperty(NumberInput.prototype, "value", {
	        get: function () {
	            return this._numberInputElement ? this._numberInputElement.value : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return NumberInput;
	}(Input));
	exports.NumberInput = NumberInput;
	var DateInput = (function (_super) {
	    __extends(DateInput, _super);
	    function DateInput() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    DateInput.prototype.internalRender = function () {
	        this._dateInputElement = document.createElement("input");
	        this._dateInputElement.type = "date";
	        this._dateInputElement.className = "input date";
	        return this._dateInputElement;
	    };
	    DateInput.prototype.getJsonTypeName = function () {
	        return "Input.Date";
	    };
	    Object.defineProperty(DateInput.prototype, "value", {
	        get: function () {
	            return this._dateInputElement ? this._dateInputElement.value : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DateInput;
	}(Input));
	exports.DateInput = DateInput;
	var TimeInput = (function (_super) {
	    __extends(TimeInput, _super);
	    function TimeInput() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TimeInput.prototype.internalRender = function () {
	        this._timeInputElement = document.createElement("input");
	        this._timeInputElement.type = "time";
	        this._timeInputElement.className = "input time";
	        return this._timeInputElement;
	    };
	    TimeInput.prototype.getJsonTypeName = function () {
	        return "Input.Time";
	    };
	    Object.defineProperty(TimeInput.prototype, "value", {
	        get: function () {
	            return this._timeInputElement ? this._timeInputElement.value : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TimeInput;
	}(Input));
	exports.TimeInput = TimeInput;
	var ActionButtonStyle;
	(function (ActionButtonStyle) {
	    ActionButtonStyle[ActionButtonStyle["Link"] = 0] = "Link";
	    ActionButtonStyle[ActionButtonStyle["Push"] = 1] = "Push";
	})(ActionButtonStyle || (ActionButtonStyle = {}));
	var ActionButtonState;
	(function (ActionButtonState) {
	    ActionButtonState[ActionButtonState["Normal"] = 0] = "Normal";
	    ActionButtonState[ActionButtonState["Expanded"] = 1] = "Expanded";
	    ActionButtonState[ActionButtonState["Subdued"] = 2] = "Subdued";
	})(ActionButtonState || (ActionButtonState = {}));
	var ActionButton = (function () {
	    function ActionButton(action, style) {
	        var _this = this;
	        this._element = null;
	        this._state = ActionButtonState.Normal;
	        this.onClick = null;
	        this._action = action;
	        this._style = style;
	        this._element = document.createElement("div");
	        this._element.onclick = function (e) { _this.click(); };
	        this.updateCssStyle();
	    }
	    ActionButton.prototype.click = function () {
	        if (this.onClick != null) {
	            this.onClick(this);
	        }
	    };
	    ActionButton.prototype.updateCssStyle = function () {
	        var cssStyle = this._style == ActionButtonStyle.Link ? "linkButton " : "pushButton ";
	        switch (this._state) {
	            case ActionButtonState.Expanded:
	                cssStyle += " expanded";
	                break;
	            case ActionButtonState.Subdued:
	                cssStyle += " subdued";
	                break;
	        }
	        this._element.className = cssStyle;
	    };
	    Object.defineProperty(ActionButton.prototype, "action", {
	        get: function () {
	            return this._action;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActionButton.prototype, "text", {
	        get: function () {
	            return this._text;
	        },
	        set: function (value) {
	            this._text = value;
	            this._element.innerText = this._text;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActionButton.prototype, "element", {
	        get: function () {
	            return this._element;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActionButton.prototype, "state", {
	        get: function () {
	            return this._state;
	        },
	        set: function (value) {
	            this._state = value;
	            this.updateCssStyle();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ActionButton;
	}());
	var Action = (function () {
	    function Action() {
	        this._parent = null;
	    }
	    Action.createAction = function (json) {
	        var actionType = json["type"];
	        var result = AdaptiveCard.actionTypeRegistry.createInstance(actionType);
	        if (result) {
	            result.parse(json);
	        }
	        else {
	            raiseParseError({
	                error: Enums.ValidationError.UnknownActionType,
	                message: "Unknown action type: " + actionType
	            });
	        }
	        return result;
	    };
	    Action.prototype.setParent = function (value) {
	        this._parent = value;
	    };
	    Action.prototype.validate = function () {
	        return [];
	    };
	    Action.prototype.prepare = function (inputs) {
	        // Do nothing in base implementation
	    };
	    ;
	    Action.prototype.parse = function (json) {
	        this.title = json["title"];
	    };
	    Action.prototype.getAllInputs = function () {
	        return [];
	    };
	    Object.defineProperty(Action.prototype, "parent", {
	        get: function () {
	            return this._parent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Action;
	}());
	exports.Action = Action;
	var ExternalAction = (function (_super) {
	    __extends(ExternalAction, _super);
	    function ExternalAction() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return ExternalAction;
	}(Action));
	exports.ExternalAction = ExternalAction;
	var SubmitAction = (function (_super) {
	    __extends(SubmitAction, _super);
	    function SubmitAction() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._isPrepared = false;
	        return _this;
	    }
	    SubmitAction.prototype.getJsonTypeName = function () {
	        return "Action.Submit";
	    };
	    SubmitAction.prototype.prepare = function (inputs) {
	        if (this._originalData) {
	            this._processedData = JSON.parse(JSON.stringify(this._originalData));
	        }
	        else {
	            this._processedData = {};
	        }
	        for (var i = 0; i < inputs.length; i++) {
	            var inputValue = inputs[i].value;
	            if (inputValue != null) {
	                this._processedData[inputs[i].id] = inputs[i].value;
	            }
	        }
	        this._isPrepared = true;
	    };
	    SubmitAction.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.data = json["data"];
	    };
	    Object.defineProperty(SubmitAction.prototype, "data", {
	        get: function () {
	            return this._isPrepared ? this._processedData : this._originalData;
	        },
	        set: function (value) {
	            this._originalData = value;
	            this._isPrepared = false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SubmitAction;
	}(ExternalAction));
	exports.SubmitAction = SubmitAction;
	var OpenUrlAction = (function (_super) {
	    __extends(OpenUrlAction, _super);
	    function OpenUrlAction() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    OpenUrlAction.prototype.getJsonTypeName = function () {
	        return "Action.OpenUrl";
	    };
	    OpenUrlAction.prototype.validate = function () {
	        if (!this.url) {
	            return [{ error: Enums.ValidationError.PropertyCantBeNull, message: "An Action.OpenUrl must have its url property set." }];
	        }
	        else {
	            return [];
	        }
	    };
	    OpenUrlAction.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.url = json["url"];
	    };
	    return OpenUrlAction;
	}(ExternalAction));
	exports.OpenUrlAction = OpenUrlAction;
	var HttpHeader = (function () {
	    function HttpHeader() {
	        this._value = new Utils.StringWithSubstitutions();
	    }
	    HttpHeader.prototype.prepare = function (inputs) {
	        this._value.substituteInputValues(inputs);
	    };
	    Object.defineProperty(HttpHeader.prototype, "value", {
	        get: function () {
	            return this._value.get();
	        },
	        set: function (newValue) {
	            this._value.set(newValue);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return HttpHeader;
	}());
	exports.HttpHeader = HttpHeader;
	var HttpAction = (function (_super) {
	    __extends(HttpAction, _super);
	    function HttpAction() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._url = new Utils.StringWithSubstitutions();
	        _this._body = new Utils.StringWithSubstitutions();
	        _this._headers = [];
	        return _this;
	    }
	    HttpAction.prototype.getJsonTypeName = function () {
	        return "Action.Http";
	    };
	    HttpAction.prototype.validate = function () {
	        var result = [];
	        if (!this.url) {
	            result = [{ error: Enums.ValidationError.PropertyCantBeNull, message: "An Action.Http must have its url property set." }];
	        }
	        if (this.headers.length > 0) {
	            for (var i = 0; i < this.headers.length; i++) {
	                if (!this.headers[i].name || !this.headers[i].value) {
	                    result = result.concat([{ error: Enums.ValidationError.PropertyCantBeNull, message: "All headers of an Action.Http must have their name and value properties set." }]);
	                    break;
	                }
	            }
	        }
	        return result;
	    };
	    HttpAction.prototype.prepare = function (inputs) {
	        this._url.substituteInputValues(inputs);
	        this._body.substituteInputValues(inputs);
	        for (var i = 0; i < this._headers.length; i++) {
	            this._headers[i].prepare(inputs);
	        }
	    };
	    ;
	    HttpAction.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.url = json["url"];
	        this.method = json["method"];
	        this.body = json["body"];
	        if (json["headers"] != null) {
	            var jsonHeaders = json["headers"];
	            for (var i = 0; i < jsonHeaders.length; i++) {
	                var httpHeader = new HttpHeader();
	                httpHeader.name = jsonHeaders[i]["name"];
	                httpHeader.value = jsonHeaders[i]["value"];
	                this.headers.push(httpHeader);
	            }
	        }
	    };
	    Object.defineProperty(HttpAction.prototype, "url", {
	        get: function () {
	            return this._url.get();
	        },
	        set: function (value) {
	            this._url.set(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HttpAction.prototype, "body", {
	        get: function () {
	            return this._body.get();
	        },
	        set: function (value) {
	            this._body.set(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HttpAction.prototype, "headers", {
	        get: function () {
	            return this._headers;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return HttpAction;
	}(ExternalAction));
	exports.HttpAction = HttpAction;
	var ShowCardAction = (function (_super) {
	    __extends(ShowCardAction, _super);
	    function ShowCardAction() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.card = new InlineAdaptiveCard();
	        return _this;
	    }
	    ShowCardAction.prototype.setParent = function (value) {
	        _super.prototype.setParent.call(this, value);
	        invokeSetParent(this.card, value);
	    };
	    ShowCardAction.prototype.getJsonTypeName = function () {
	        return "Action.ShowCard";
	    };
	    ShowCardAction.prototype.validate = function () {
	        return this.card.validate();
	    };
	    ShowCardAction.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.card.parse(json["card"]);
	    };
	    ShowCardAction.prototype.getAllInputs = function () {
	        return this.card.getAllInputs();
	    };
	    return ShowCardAction;
	}(Action));
	exports.ShowCardAction = ShowCardAction;
	var ActionCollection = (function () {
	    function ActionCollection(owner) {
	        this._actionButtons = [];
	        this._expandedAction = null;
	        this.items = [];
	        this.onHideActionCardPane = null;
	        this.onShowActionCardPane = null;
	        this._owner = owner;
	    }
	    ActionCollection.prototype.hideActionCardPane = function () {
	        this._actionCardContainer.innerHTML = '';
	        this._actionCardContainer.style.padding = "0px";
	        this._actionCardContainer.style.marginTop = "0px";
	        if (this.onHideActionCardPane) {
	            this.onHideActionCardPane();
	        }
	    };
	    ActionCollection.prototype.showActionCardPane = function (action) {
	        if (this.onShowActionCardPane) {
	            this.onShowActionCardPane(action);
	        }
	        var renderedCard = action.card.render();
	        this._actionCardContainer.innerHTML = '';
	        this._actionCardContainer.style.marginTop = this.items.length > 1 ? hostConfiguration.actions.showCard.inlineCardSpacing + "px" : "0px";
	        if (hostConfiguration.actions.showCard.actionMode == "inlineEdgeToEdge") {
	            var padding = this._owner.getNonZeroPadding();
	            this._actionCardContainer.style.paddingLeft = padding.left + "px";
	            this._actionCardContainer.style.paddingRight = padding.right + "px";
	            this._actionCardContainer.style.marginLeft = "-" + padding.left + "px";
	            this._actionCardContainer.style.marginRight = "-" + padding.right + "px";
	            renderedCard.style.paddingLeft = "0px";
	            renderedCard.style.paddingRight = "0px";
	        }
	        Utils.appendChild(this._actionCardContainer, renderedCard);
	    };
	    ActionCollection.prototype.actionClicked = function (actionButton) {
	        if (!(actionButton.action instanceof ShowCardAction)) {
	            for (var i = 0; i < this._actionButtons.length; i++) {
	                this._actionButtons[i].state = ActionButtonState.Normal;
	            }
	            this.hideActionCardPane();
	            raiseExecuteActionEvent(actionButton.action);
	        }
	        else {
	            if (hostConfiguration.actions.showCard.actionMode == "popup") {
	                var actionShowCard = actionButton.action;
	                raiseShowPopupCardEvent(actionShowCard);
	            }
	            else if (actionButton.action === this._expandedAction) {
	                for (var i = 0; i < this._actionButtons.length; i++) {
	                    this._actionButtons[i].state = ActionButtonState.Normal;
	                }
	                this._expandedAction = null;
	                this.hideActionCardPane();
	            }
	            else {
	                for (var i = 0; i < this._actionButtons.length; i++) {
	                    if (this._actionButtons[i] !== actionButton) {
	                        this._actionButtons[i].state = ActionButtonState.Subdued;
	                    }
	                }
	                actionButton.state = ActionButtonState.Expanded;
	                this._expandedAction = actionButton.action;
	                this.showActionCardPane(actionButton.action);
	            }
	        }
	    };
	    ActionCollection.prototype.validate = function () {
	        var result = [];
	        if (hostConfiguration.actions.maxActions && this.items.length > hostConfiguration.actions.maxActions) {
	            result.push({
	                error: Enums.ValidationError.TooManyActions,
	                message: "A maximum of " + hostConfiguration.actions.maxActions + " actions are allowed."
	            });
	        }
	        if (this.items.length > 0 && !hostConfiguration.supportsInteractivity) {
	            result.push({
	                error: Enums.ValidationError.InteractivityNotAllowed,
	                message: "Interactivity is not allowed."
	            });
	        }
	        for (var i = 0; i < this.items.length; i++) {
	            if (!isActionAllowed(this.items[i], this._owner.getForbiddenActionTypes())) {
	                result.push({
	                    error: Enums.ValidationError.ActionTypeNotAllowed,
	                    message: "Actions of type " + this.items[i].getJsonTypeName() + " are not allowe."
	                });
	            }
	        }
	        for (var i = 0; i < this.items.length; i++) {
	            result = result.concat(this.items[i].validate());
	        }
	        return result;
	    };
	    ActionCollection.prototype.render = function () {
	        var _this = this;
	        if (!hostConfiguration.supportsInteractivity) {
	            return null;
	        }
	        var element = document.createElement("div");
	        element.style.overflow = "hidden";
	        var buttonStrip = document.createElement("div");
	        switch (hostConfiguration.actions.actionAlignment) {
	            case "center":
	                element.style.textAlign = "center";
	                buttonStrip.style.textAlign = "center";
	                break;
	            case "right":
	                element.style.textAlign = "right";
	                buttonStrip.style.textAlign = "right";
	                break;
	        }
	        if (hostConfiguration.actions.actionsOrientation == "horizontal") {
	            if (hostConfiguration.actions.stretch) {
	                buttonStrip.style.display = "flex";
	            }
	            else {
	                buttonStrip.style.display = "inline-flex";
	            }
	        }
	        else {
	            buttonStrip.style.display = "inline-table";
	        }
	        this._actionCardContainer = document.createElement("div");
	        this._actionCardContainer.style.backgroundColor = Utils.stringToCssColor(hostConfiguration.actions.showCard.backgroundColor);
	        var renderedActions = 0;
	        if (this.items.length == 1 && this.items[0] instanceof ShowCardAction) {
	            this.showActionCardPane(this.items[0]);
	            renderedActions++;
	        }
	        else {
	            var actionButtonStyle = ActionButtonStyle.Push;
	            var maxActions = hostConfiguration.actions.maxActions ? Math.min(hostConfiguration.actions.maxActions, this.items.length) : this.items.length;
	            for (var i = 0; i < maxActions; i++) {
	                if (this.items[i] instanceof ShowCardAction) {
	                    actionButtonStyle = ActionButtonStyle.Link;
	                    break;
	                }
	            }
	            var forbiddenActionTypes = this._owner.getForbiddenActionTypes();
	            for (var i = 0; i < maxActions; i++) {
	                if (isActionAllowed(this.items[i], forbiddenActionTypes)) {
	                    var buttonStripItem = document.createElement("div");
	                    buttonStripItem.style.whiteSpace = "nowrap";
	                    buttonStripItem.style.overflow = "hidden";
	                    buttonStripItem.style.overflow = "table-cell";
	                    buttonStripItem.style.flex = hostConfiguration.actions.stretch ? "0 1 100%" : "0 1 auto";
	                    var actionButton = new ActionButton(this.items[i], actionButtonStyle);
	                    actionButton.text = this.items[i].title;
	                    actionButton.onClick = function (ab) { _this.actionClicked(ab); };
	                    this._actionButtons.push(actionButton);
	                    Utils.appendChild(buttonStripItem, actionButton.element);
	                    Utils.appendChild(buttonStrip, buttonStripItem);
	                    if (i < this.items.length - 1 && hostConfiguration.actions.buttonSpacing > 0) {
	                        var spacer = document.createElement("div");
	                        if (hostConfiguration.actions.actionsOrientation == "horizontal") {
	                            spacer.style.flex = "0 0 " + hostConfiguration.actions.buttonSpacing + "px";
	                        }
	                        else {
	                            spacer.style.height = hostConfiguration.actions.buttonSpacing + "px";
	                        }
	                        Utils.appendChild(buttonStrip, spacer);
	                    }
	                    renderedActions++;
	                }
	            }
	            Utils.appendChild(element, buttonStrip);
	        }
	        Utils.appendChild(element, this._actionCardContainer);
	        return renderedActions > 0 ? element : null;
	    };
	    ActionCollection.prototype.addAction = function (action) {
	        if (!action.parent) {
	            this.items.push(action);
	            invokeSetParent(action, this._owner);
	        }
	        else {
	            throw new Error("The action already belongs to another element.");
	        }
	    };
	    ActionCollection.prototype.getAllInputs = function () {
	        var result = [];
	        for (var i = 0; i < this.items.length; i++) {
	            var action = this.items[i];
	            result = result.concat(action.getAllInputs());
	        }
	        return result;
	    };
	    return ActionCollection;
	}());
	var ActionSet = (function (_super) {
	    __extends(ActionSet, _super);
	    function ActionSet() {
	        var _this = _super.call(this) || this;
	        _this._actionCollection = new ActionCollection(_this);
	        _this._actionCollection.onHideActionCardPane = function () { _this.showBottomSpacer(_this); };
	        _this._actionCollection.onShowActionCardPane = function (action) { _this.hideBottomSpacer(_this); };
	        return _this;
	    }
	    ActionSet.prototype.internalRender = function () {
	        return this._actionCollection.render();
	    };
	    ActionSet.prototype.getJsonTypeName = function () {
	        return "ActionSet";
	    };
	    ActionSet.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.actions.separation;
	    };
	    ActionSet.prototype.validate = function () {
	        return this._actionCollection.validate();
	    };
	    ActionSet.prototype.parse = function (json, itemsCollectionPropertyName) {
	        if (itemsCollectionPropertyName === void 0) { itemsCollectionPropertyName = "items"; }
	        _super.prototype.parse.call(this, json);
	        if (json["actions"] != undefined) {
	            var jsonActions = json["actions"];
	            for (var i = 0; i < jsonActions.length; i++) {
	                this.addAction(Action.createAction(jsonActions[i]));
	            }
	        }
	    };
	    ActionSet.prototype.addAction = function (action) {
	        if (action != null) {
	            this._actionCollection.addAction(action);
	        }
	    };
	    ActionSet.prototype.getAllInputs = function () {
	        return this._actionCollection.getAllInputs();
	    };
	    ActionSet.prototype.renderSpeech = function () {
	        // TODO: What's the right thing to do here?
	        return "";
	    };
	    Object.defineProperty(ActionSet.prototype, "isInteractive", {
	        get: function () {
	            return true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ActionSet;
	}(CardElement));
	exports.ActionSet = ActionSet;
	var ContainerBase = (function (_super) {
	    __extends(ContainerBase, _super);
	    function ContainerBase() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._items = [];
	        return _this;
	    }
	    ContainerBase.prototype.showBottomSpacer = function (requestingElement) {
	        if (!requestingElement || (this.isLastItem(requestingElement) && hostConfiguration.actions.showCard.actionMode == "inlineEdgeToEdge")) {
	            this._element.style.paddingBottom = this.padding.bottom + "px";
	            _super.prototype.showBottomSpacer.call(this, this);
	        }
	    };
	    ContainerBase.prototype.hideBottomSpacer = function (requestingElement) {
	        if (!requestingElement || (this.isLastItem(requestingElement) && hostConfiguration.actions.showCard.actionMode == "inlineEdgeToEdge")) {
	            this._element.style.paddingBottom = "0px";
	            _super.prototype.hideBottomSpacer.call(this, this);
	        }
	    };
	    ContainerBase.prototype.internalRender = function () {
	        var _this = this;
	        this._element = document.createElement("div");
	        this._element.className = "container";
	        var backgroundColor = this.getBackgroundColor();
	        if (backgroundColor) {
	            this._element.style.backgroundColor = Utils.stringToCssColor(backgroundColor);
	        }
	        if (this.selectAction) {
	            this._element.classList.add("selectable");
	        }
	        this._element.style.paddingTop = this.padding.top + "px";
	        this._element.style.paddingRight = this.padding.right + "px";
	        this._element.style.paddingBottom = this.padding.bottom + "px";
	        this._element.style.paddingLeft = this.padding.left + "px";
	        this._element.onclick = function (e) {
	            if (_this.selectAction != null) {
	                raiseExecuteActionEvent(_this.selectAction);
	                e.cancelBubble = true;
	            }
	        };
	        if (this._items.length > 0) {
	            var renderedElementCount = 0;
	            for (var i = 0; i < this._items.length; i++) {
	                var renderedElement = isElementAllowed(this._items[i], this.getForbiddenElementTypes()) ? this._items[i].render() : null;
	                if (renderedElement != null) {
	                    if (renderedElementCount > 0 && this._items[i].separation != "none") {
	                        var separationDefinition = this._items[i].separation == "default" ? this._items[i].getDefaultSeparationDefinition() : hostConfiguration.strongSeparation;
	                        Utils.appendChild(this._element, Utils.renderSeparation(separationDefinition, "vertical"));
	                    }
	                    Utils.appendChild(this._element, renderedElement);
	                    renderedElementCount++;
	                }
	            }
	        }
	        return renderedElementCount > 0 ? this._element : null;
	    };
	    ContainerBase.prototype.getBackgroundColor = function () {
	        return null;
	    };
	    Object.defineProperty(ContainerBase.prototype, "hideOverflow", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContainerBase.prototype, "padding", {
	        get: function () {
	            return { left: 0, top: 0, right: 0, bottom: 0 };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContainerBase.prototype.isLastItem = function (item) {
	        return this._items.indexOf(item) == (this._items.length - 1);
	    };
	    ContainerBase.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.container.separation;
	    };
	    ContainerBase.prototype.validate = function () {
	        var result = [];
	        for (var i = 0; i < this._items.length; i++) {
	            if (!hostConfiguration.supportsInteractivity && this._items[i].isInteractive) {
	                result.push({
	                    error: Enums.ValidationError.InteractivityNotAllowed,
	                    message: "Interactivity is not allowed."
	                });
	            }
	            if (!isElementAllowed(this._items[i], this.getForbiddenElementTypes())) {
	                result.push({
	                    error: Enums.ValidationError.InteractivityNotAllowed,
	                    message: "Elements of type " + this._items[i].getJsonTypeName() + " are not allowed in this container."
	                });
	            }
	            result = result.concat(this._items[i].validate());
	        }
	        return result;
	    };
	    ContainerBase.prototype.parse = function (json, itemsCollectionPropertyName) {
	        if (itemsCollectionPropertyName === void 0) { itemsCollectionPropertyName = "items"; }
	        _super.prototype.parse.call(this, json);
	        if (json[itemsCollectionPropertyName] != null) {
	            var items = json[itemsCollectionPropertyName];
	            for (var i = 0; i < items.length; i++) {
	                var elementType = items[i]["type"];
	                var element = AdaptiveCard.elementTypeRegistry.createInstance(elementType);
	                if (!element) {
	                    raiseParseError({
	                        error: Enums.ValidationError.UnknownElementType,
	                        message: "Unknown element type: " + elementType
	                    });
	                }
	                else {
	                    this.addItem(element);
	                    element.parse(items[i]);
	                }
	            }
	        }
	        var selectActionJson = json["selectAction"];
	        if (selectActionJson != undefined) {
	            this.selectAction = Action.createAction(selectActionJson);
	            invokeSetParent(this.selectAction, this);
	        }
	    };
	    ContainerBase.prototype.addItem = function (item) {
	        if (!item.parent) {
	            this._items.push(item);
	            invokeSetParent(item, this);
	        }
	        else {
	            throw new Error("The element already belongs to another container.");
	        }
	    };
	    ContainerBase.prototype.getAllInputs = function () {
	        var result = [];
	        for (var i = 0; i < this._items.length; i++) {
	            var item = this._items[i];
	            result = result.concat(item.getAllInputs());
	        }
	        return result;
	    };
	    ContainerBase.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak;
	        }
	        // render each item
	        var speak = null;
	        if (this._items.length > 0) {
	            speak = '';
	            for (var i = 0; i < this._items.length; i++) {
	                var result = this._items[i].renderSpeech();
	                if (result) {
	                    speak += result;
	                }
	            }
	        }
	        return speak;
	    };
	    return ContainerBase;
	}(CardElement));
	exports.ContainerBase = ContainerBase;
	var Container = (function (_super) {
	    __extends(Container, _super);
	    function Container() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.style = "normal";
	        return _this;
	    }
	    Container.prototype.getBackgroundColor = function () {
	        return this.style == "normal" ? hostConfiguration.container.normal.backgroundColor : hostConfiguration.container.emphasis.backgroundColor;
	    };
	    Container.prototype.internalRender = function () {
	        var renderedContainer = _super.prototype.internalRender.call(this);
	        var styleDefinition = this.style == "normal" ? hostConfiguration.container.normal : hostConfiguration.container.emphasis;
	        if (styleDefinition.borderColor) {
	            renderedContainer.style.borderColor = Utils.stringToCssColor(styleDefinition.borderColor);
	        }
	        if (styleDefinition.borderThickness) {
	            renderedContainer.style.borderTop = styleDefinition.borderThickness.top + "px solid";
	            renderedContainer.style.borderRight = styleDefinition.borderThickness.right + "px solid";
	            renderedContainer.style.borderBottom = styleDefinition.borderThickness.bottom + "px solid";
	            renderedContainer.style.borderLeft = styleDefinition.borderThickness.left + "px solid";
	        }
	        return renderedContainer;
	    };
	    Object.defineProperty(Container.prototype, "padding", {
	        get: function () {
	            var styleDefinition = this.style == "normal" ? hostConfiguration.container.normal : hostConfiguration.container.emphasis;
	            return styleDefinition.padding ? styleDefinition.padding : { top: 0, right: 0, bottom: 0, left: 0 };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Container.prototype.getJsonTypeName = function () {
	        return "Container";
	    };
	    Container.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        this.style = Utils.getValueOrDefault(json["style"], "normal");
	    };
	    return Container;
	}(ContainerBase));
	exports.Container = Container;
	var Column = (function (_super) {
	    __extends(Column, _super);
	    function Column() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.size = "auto";
	        return _this;
	    }
	    Object.defineProperty(Column.prototype, "padding", {
	        get: function () {
	            return { left: 0, top: 0, right: 0, bottom: 0 };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Column.prototype.adjustLayout = function (element) {
	        element.style.minWidth = "0";
	        if (typeof this.size === "number") {
	            element.style.flex = "1 1 " + this.size + "%";
	        }
	        else if (this.size === "auto") {
	            element.style.flex = "0 0 auto";
	        }
	        else {
	            element.style.flex = "1 1 auto";
	        }
	    };
	    Column.prototype.getJsonTypeName = function () {
	        return "Column";
	    };
	    Column.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.column.separation;
	    };
	    Column.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        var sizeValue = json["size"];
	        if (sizeValue) {
	            this.size = sizeValue;
	        }
	    };
	    return Column;
	}(Container));
	exports.Column = Column;
	var ColumnSet = (function (_super) {
	    __extends(ColumnSet, _super);
	    function ColumnSet() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._columns = [];
	        return _this;
	    }
	    ColumnSet.prototype.internalRender = function () {
	        if (this._columns.length > 0) {
	            var element = document.createElement("div");
	            element.style.display = "flex";
	            var renderedColumnCount = 0;
	            for (var i = 0; i < this._columns.length; i++) {
	                var renderedColumn = this._columns[i].render();
	                if (renderedColumn != null) {
	                    Utils.appendChild(element, renderedColumn);
	                    if (this._columns.length > 1 && i < this._columns.length - 1 && this._columns[i + 1].separation != "none") {
	                        var separationDefinition = this._columns[i + 1].separation == "default" ? this._columns[i + 1].getDefaultSeparationDefinition() : hostConfiguration.strongSeparation;
	                        if (separationDefinition) {
	                            var separator = Utils.renderSeparation(separationDefinition, "horizontal");
	                            separator.style.flex = "0 0 auto";
	                            Utils.appendChild(element, separator);
	                        }
	                    }
	                    renderedColumnCount++;
	                }
	            }
	            return renderedColumnCount > 0 ? element : null;
	        }
	        else {
	            return null;
	        }
	    };
	    ColumnSet.prototype.getJsonTypeName = function () {
	        return "ColumnSet";
	    };
	    ColumnSet.prototype.getDefaultSeparationDefinition = function () {
	        return hostConfiguration.columnSet.separation;
	    };
	    ColumnSet.prototype.parse = function (json) {
	        _super.prototype.parse.call(this, json);
	        if (json["columns"] != null) {
	            var jsonColumns = json["columns"];
	            for (var i = 0; i < jsonColumns.length; i++) {
	                var column = new Column();
	                column.parse(jsonColumns[i]);
	                this.addColumn(column);
	            }
	        }
	    };
	    ColumnSet.prototype.addColumn = function (column) {
	        if (!column.parent) {
	            this._columns.push(column);
	            invokeSetParent(column, this);
	        }
	        else {
	            throw new Error("This column already belongs to another ColumnSet.");
	        }
	    };
	    ColumnSet.prototype.renderSpeech = function () {
	        if (this.speak != null) {
	            return this.speak;
	        }
	        // render each item
	        var speak = '';
	        if (this._columns.length > 0) {
	            for (var i = 0; i < this._columns.length; i++) {
	                speak += this._columns[i].renderSpeech();
	            }
	        }
	        return speak;
	    };
	    return ColumnSet;
	}(CardElement));
	exports.ColumnSet = ColumnSet;
	function raiseExecuteActionEvent(action) {
	    if (AdaptiveCard.onExecuteAction != null) {
	        action.prepare(action.parent.getRootElement().getAllInputs());
	        AdaptiveCard.onExecuteAction(action);
	    }
	}
	function raiseShowPopupCardEvent(action) {
	    if (AdaptiveCard.onShowPopupCard != null) {
	        AdaptiveCard.onShowPopupCard(action);
	    }
	}
	function raiseParseError(error) {
	    if (AdaptiveCard.onParseError != null) {
	        AdaptiveCard.onParseError(error);
	    }
	}
	var TypeRegistry = (function () {
	    function TypeRegistry() {
	        this._items = [];
	    }
	    TypeRegistry.prototype.findTypeRegistration = function (typeName) {
	        for (var i = 0; i < this._items.length; i++) {
	            if (this._items[i].typeName === typeName) {
	                return this._items[i];
	            }
	        }
	        return null;
	    };
	    TypeRegistry.prototype.clear = function () {
	        this._items = [];
	    };
	    TypeRegistry.prototype.registerType = function (typeName, createInstance) {
	        var registrationInfo = this.findTypeRegistration(typeName);
	        if (registrationInfo != null) {
	            registrationInfo.createInstance = createInstance;
	        }
	        else {
	            registrationInfo = {
	                typeName: typeName,
	                createInstance: createInstance
	            };
	            this._items.push(registrationInfo);
	        }
	    };
	    TypeRegistry.prototype.unregisterType = function (typeName) {
	        for (var i = 0; i < this._items.length; i++) {
	            if (this._items[i].typeName === typeName) {
	                this._items = this._items.splice(i, 1);
	                return;
	            }
	        }
	    };
	    TypeRegistry.prototype.createInstance = function (typeName) {
	        var registrationInfo = this.findTypeRegistration(typeName);
	        return registrationInfo ? registrationInfo.createInstance() : null;
	    };
	    return TypeRegistry;
	}());
	exports.TypeRegistry = TypeRegistry;
	var ContainerWithActions = (function (_super) {
	    __extends(ContainerWithActions, _super);
	    function ContainerWithActions() {
	        var _this = _super.call(this) || this;
	        _this._actionCollection = new ActionCollection(_this);
	        _this._actionCollection.onHideActionCardPane = function () { _this.showBottomSpacer(null); };
	        _this._actionCollection.onShowActionCardPane = function (action) { _this.hideBottomSpacer(null); };
	        return _this;
	    }
	    ContainerWithActions.prototype.internalRender = function () {
	        _super.prototype.internalRender.call(this);
	        var renderedActions = this._actionCollection.render();
	        if (renderedActions) {
	            Utils.appendChild(this._element, Utils.renderSeparation(hostConfiguration.actions.separation, "vertical"));
	            Utils.appendChild(this._element, renderedActions);
	        }
	        return this._element.children.length > 0 ? this._element : null;
	    };
	    ContainerWithActions.prototype.parse = function (json, itemsCollectionPropertyName) {
	        if (itemsCollectionPropertyName === void 0) { itemsCollectionPropertyName = "items"; }
	        _super.prototype.parse.call(this, json, itemsCollectionPropertyName);
	        if (json["actions"] != undefined) {
	            var jsonActions = json["actions"];
	            for (var i = 0; i < jsonActions.length; i++) {
	                var action = Action.createAction(jsonActions[i]);
	                if (action != null) {
	                    this.addAction(action);
	                }
	            }
	        }
	    };
	    ContainerWithActions.prototype.isLastItem = function (item) {
	        return _super.prototype.isLastItem.call(this, item) && this._actionCollection.items.length == 0;
	    };
	    ContainerWithActions.prototype.addAction = function (action) {
	        this._actionCollection.addAction(action);
	    };
	    ContainerWithActions.prototype.getAllInputs = function () {
	        return _super.prototype.getAllInputs.call(this).concat(this._actionCollection.getAllInputs());
	    };
	    return ContainerWithActions;
	}(ContainerBase));
	exports.ContainerWithActions = ContainerWithActions;
	var AdaptiveCard = (function (_super) {
	    __extends(AdaptiveCard, _super);
	    function AdaptiveCard() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.minVersion = { major: 1, minor: 0 };
	        return _this;
	    }
	    AdaptiveCard.initialize = function () {
	        AdaptiveCard.elementTypeRegistry.clear();
	        AdaptiveCard.elementTypeRegistry.registerType("Container", function () { return new Container(); });
	        AdaptiveCard.elementTypeRegistry.registerType("TextBlock", function () { return new TextBlock(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Image", function () { return new Image(); });
	        AdaptiveCard.elementTypeRegistry.registerType("ImageSet", function () { return new ImageSet(); });
	        AdaptiveCard.elementTypeRegistry.registerType("FactSet", function () { return new FactSet(); });
	        AdaptiveCard.elementTypeRegistry.registerType("ColumnSet", function () { return new ColumnSet(); });
	        AdaptiveCard.elementTypeRegistry.registerType("ActionSet", function () { return new ActionSet(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.Text", function () { return new TextInput(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.Date", function () { return new DateInput(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.Time", function () { return new TimeInput(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.Number", function () { return new NumberInput(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.ChoiceSet", function () { return new ChoiceSetInput(); });
	        AdaptiveCard.elementTypeRegistry.registerType("Input.Toggle", function () { return new ToggleInput(); });
	        AdaptiveCard.actionTypeRegistry.clear();
	        AdaptiveCard.actionTypeRegistry.registerType("Action.Http", function () { return new HttpAction(); });
	        AdaptiveCard.actionTypeRegistry.registerType("Action.OpenUrl", function () { return new OpenUrlAction(); });
	        AdaptiveCard.actionTypeRegistry.registerType("Action.Submit", function () { return new SubmitAction(); });
	        AdaptiveCard.actionTypeRegistry.registerType("Action.ShowCard", function () { return new ShowCardAction(); });
	    };
	    AdaptiveCard.prototype.isVersionSupported = function () {
	        var unsupportedVersion = (AdaptiveCard.currentVersion.major < this.minVersion.major) ||
	            (AdaptiveCard.currentVersion.major == this.minVersion.major && AdaptiveCard.currentVersion.minor < this.minVersion.minor);
	        return !unsupportedVersion;
	    };
	    AdaptiveCard.prototype.getBackgroundColor = function () {
	        return hostConfiguration.adaptiveCard.backgroundColor;
	    };
	    Object.defineProperty(AdaptiveCard.prototype, "padding", {
	        get: function () {
	            return hostConfiguration.adaptiveCard.padding;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AdaptiveCard.prototype.getJsonTypeName = function () {
	        return "AdaptiveCard";
	    };
	    AdaptiveCard.prototype.validate = function () {
	        var result = [];
	        if (this._cardTypeName != "AdaptiveCard") {
	            result.push({
	                error: Enums.ValidationError.MissingCardType,
	                message: "Invalid or missing card type. Make sure the card's type property is set to \"AdaptiveCard\"."
	            });
	        }
	        if (!this.isVersionSupported()) {
	            result.push({
	                error: Enums.ValidationError.UnsupportedCardVersion,
	                message: "The specified card version is not supported."
	            });
	        }
	        return result.concat(_super.prototype.validate.call(this));
	    };
	    AdaptiveCard.prototype.parse = function (json) {
	        this._cardTypeName = json["type"];
	        var minVersion = json["version"];
	        // var minVersion = json["minVersion"];
	        var regEx = /(\d+).(\d+)/gi;
	        var matches = regEx.exec(minVersion);
	        if (matches != null && matches.length == 3) {
	            this.minVersion.major = parseInt(matches[1]);
	            this.minVersion.minor = parseInt(matches[2]);
	        }
	        this.fallbackText = json["fallbackText"];
	        _super.prototype.parse.call(this, json, "body");
	    };
	    AdaptiveCard.prototype.render = function () {
	        var renderedCard;
	        if (!this.isVersionSupported()) {
	            renderedCard = document.createElement("div");
	            renderedCard.innerHTML = this.fallbackText ? this.fallbackText : "The specified card version is not supported.";
	            return renderedCard;
	        }
	        else {
	            return _super.prototype.render.call(this);
	        }
	    };
	    return AdaptiveCard;
	}(ContainerWithActions));
	AdaptiveCard.currentVersion = { major: 1, minor: 0 };
	AdaptiveCard.elementTypeRegistry = new TypeRegistry();
	AdaptiveCard.actionTypeRegistry = new TypeRegistry();
	AdaptiveCard.onExecuteAction = null;
	AdaptiveCard.onShowPopupCard = null;
	AdaptiveCard.onParseError = null;
	exports.AdaptiveCard = AdaptiveCard;
	// This calls acts as a static constructor (see https://github.com/Microsoft/TypeScript/issues/265)
	AdaptiveCard.initialize();
	var InlineAdaptiveCard = (function (_super) {
	    __extends(InlineAdaptiveCard, _super);
	    function InlineAdaptiveCard() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Object.defineProperty(InlineAdaptiveCard.prototype, "padding", {
	        get: function () {
	            return hostConfiguration.actions.showCard.padding;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    InlineAdaptiveCard.prototype.getBackgroundColor = function () {
	        return null;
	    };
	    InlineAdaptiveCard.prototype.getForbiddenActionTypes = function () {
	        return [ShowCardAction];
	    };
	    return InlineAdaptiveCard;
	}(AdaptiveCard));
	var defaultConfiguration = {
	    supportsInteractivity: true,
	    strongSeparation: {
	        spacing: 40,
	        lineThickness: 1,
	        lineColor: "#EEEEEE"
	    },
	    fontFamily: "Segoe UI",
	    fontSizes: {
	        small: 8,
	        normal: 10,
	        medium: 12,
	        large: 14,
	        extraLarge: 16
	    },
	    fontWeights: {
	        lighter: 200,
	        normal: 400,
	        bolder: 600
	    },
	    colors: {
	        dark: {
	            normal: "#0000FF",
	            subtle: "#222222"
	        },
	        light: {
	            normal: "#FFFFFF",
	            subtle: "#DDDDDD"
	        },
	        accent: {
	            normal: "#0000FF",
	            subtle: "#0000DD"
	        },
	        attention: {
	            normal: "#FF6600",
	            subtle: "#DD4400"
	        },
	        good: {
	            normal: "#00FF00",
	            subtle: "#00DD00"
	        },
	        warning: {
	            normal: "#FF0000",
	            subtle: "#DD0000"
	        }
	    },
	    imageSizes: {
	        small: 40,
	        medium: 80,
	        large: 160
	    },
	    actions: {
	        maxActions: 5,
	        separation: {
	            spacing: 20
	        },
	        buttonSpacing: 20,
	        stretch: false,
	        showCard: {
	            actionMode: "inlineEdgeToEdge",
	            inlineCardSpacing: 16,
	            backgroundColor: "#22000000",
	            padding: {
	                top: 16,
	                right: 16,
	                bottom: 16,
	                left: 16
	            }
	        },
	        actionsOrientation: "horizontal",
	        actionAlignment: "left"
	    },
	    adaptiveCard: {
	        backgroundColor: "#00000000",
	        padding: {
	            left: 20,
	            top: 20,
	            right: 20,
	            bottom: 20
	        }
	    },
	    container: {
	        separation: {
	            spacing: 20
	        },
	        normal: {},
	        emphasis: {
	            backgroundColor: "#EEEEEE",
	            borderColor: "#AAAAAA",
	            borderThickness: {
	                top: 1,
	                right: 1,
	                bottom: 1,
	                left: 1
	            },
	            padding: {
	                top: 10,
	                right: 10,
	                bottom: 10,
	                left: 10
	            }
	        }
	    },
	    textBlock: {
	        color: "dark",
	        separations: {
	            small: {
	                spacing: 20,
	            },
	            normal: {
	                spacing: 20
	            },
	            medium: {
	                spacing: 20
	            },
	            large: {
	                spacing: 20
	            },
	            extraLarge: {
	                spacing: 20
	            }
	        }
	    },
	    image: {
	        size: "medium",
	        separation: {
	            spacing: 20
	        }
	    },
	    imageSet: {
	        imageSize: "medium",
	        separation: {
	            spacing: 20
	        }
	    },
	    factSet: {
	        separation: {
	            spacing: 20
	        },
	        title: {
	            color: "dark",
	            size: "normal",
	            isSubtle: false,
	            weight: "bolder"
	        },
	        value: {
	            color: "dark",
	            size: "normal",
	            isSubtle: false,
	            weight: "normal"
	        },
	        spacing: 10
	    },
	    input: {
	        separation: {
	            spacing: 20
	        }
	    },
	    columnSet: {
	        separation: {
	            spacing: 20
	        }
	    },
	    column: {
	        separation: {
	            spacing: 20
	        }
	    }
	};
	var hostConfiguration = defaultConfiguration;
	function setConfiguration(configuration) {
	    hostConfiguration = configuration;
	}
	exports.setConfiguration = setConfiguration;
	function resetConfiguration() {
	    hostConfiguration = defaultConfiguration;
	}
	exports.resetConfiguration = resetConfiguration;
	//# sourceMappingURL=card-elements.js.map

/***/ },
/* 148 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var ValidationError;
	(function (ValidationError) {
	    ValidationError[ValidationError["ActionTypeNotAllowed"] = 0] = "ActionTypeNotAllowed";
	    ValidationError[ValidationError["CollectionCantBeEmpty"] = 1] = "CollectionCantBeEmpty";
	    ValidationError[ValidationError["ElementTypeNotAllowed"] = 2] = "ElementTypeNotAllowed";
	    ValidationError[ValidationError["InteractivityNotAllowed"] = 3] = "InteractivityNotAllowed";
	    ValidationError[ValidationError["MissingCardType"] = 4] = "MissingCardType";
	    ValidationError[ValidationError["PropertyCantBeNull"] = 5] = "PropertyCantBeNull";
	    ValidationError[ValidationError["TooManyActions"] = 6] = "TooManyActions";
	    ValidationError[ValidationError["UnknownActionType"] = 7] = "UnknownActionType";
	    ValidationError[ValidationError["UnknownElementType"] = 8] = "UnknownElementType";
	    ValidationError[ValidationError["UnsupportedCardVersion"] = 9] = "UnsupportedCardVersion";
	})(ValidationError = exports.ValidationError || (exports.ValidationError = {}));
	//# sourceMappingURL=enums.js.map

/***/ },
/* 149 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	
	function markdown(input) {
	        return input
	            // first pass for strong emphasis
	            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
	            .replace(/__([^_]+)__/g, '<strong>$1</strong>')
	            // emphasis
	            .replace(/(^|[^\\])_([^_\s][^_]*)_/g, '$1<em>$2</em>')
	            .replace(/(^|[^\\])\*([^*\s][^*]*)\*/g, '$1<em>$2</em>')
	            // second pass for strong emphasis for cases like ***test***
	            .replace(/__([^_]+)__/g, '<strong>$1</strong>')
	            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
	            // strike through
	            .replace(/~~([^~]+)~~/g, '<del>$1</del>')
	            // image
	            .replace(/!\[(([^]+?))\]\((([^\s]+?)\s?"?([^"]*?)"?)\)/g, '<img src="$3" alt="$1" title="$2"/>')
	            // link
	            .replace(/\[(([^]+?))\]\((([^\s]+?)\s?"?([^"]*?)"?)\)/g, '<a href="$3" title="$2">$1</a>')
	            // new line
	            .replace(/\n/g, '<br />');
	    }
	
	function processMarkdown(text) {
	    return markdown(text);
	    // return markdownProcessor.render(text);
	}
	exports.processMarkdown = processMarkdown;
	function getValueOrDefault(obj, defaultValue) {
	    return obj ? obj : defaultValue;
	}
	exports.getValueOrDefault = getValueOrDefault;
	function isNullOrEmpty(value) {
	    return value === undefined || value === null || value === "";
	}
	exports.isNullOrEmpty = isNullOrEmpty;
	function appendChild(node, child) {
	    if (child != null && child != undefined) {
	        node.appendChild(child);
	    }
	}
	exports.appendChild = appendChild;
	function renderSeparation(separationDefinition, orientation) {
	    var separator = document.createElement("div");
	    if (orientation == "vertical") {
	        if (separationDefinition.lineThickness) {
	            separator.style.marginTop = (separationDefinition.spacing / 2) + "px";
	            separator.style.paddingTop = (separationDefinition.spacing / 2) + "px";
	            separator.style.borderTop = separationDefinition.lineThickness + "px solid " + stringToCssColor(separationDefinition.lineColor);
	        }
	        else {
	            separator.style.height = separationDefinition.spacing + "px";
	        }
	    }
	    else {
	        if (separationDefinition.lineThickness) {
	            separator.style.marginLeft = (separationDefinition.spacing / 2) + "px";
	            separator.style.paddingLeft = (separationDefinition.spacing / 2) + "px";
	            separator.style.borderLeft = separationDefinition.lineThickness + "px solid " + stringToCssColor(separationDefinition.lineColor);
	        }
	        else {
	            separator.style.width = separationDefinition.spacing + "px";
	        }
	    }
	    return separator;
	}
	exports.renderSeparation = renderSeparation;
	function stringToCssColor(color) {
	    var regEx = /#([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})?/gi;
	    var matches = regEx.exec(color);
	    if (matches[4]) {
	        var a = parseInt(matches[1], 16) / 255;
	        var r = parseInt(matches[2], 16);
	        var g = parseInt(matches[3], 16);
	        var b = parseInt(matches[4], 16);
	        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
	    }
	    else {
	        return color;
	    }
	}
	exports.stringToCssColor = stringToCssColor;
	var StringWithSubstitutions = (function () {
	    function StringWithSubstitutions() {
	        this._isProcessed = false;
	        this._original = null;
	        this._processed = null;
	    }
	    StringWithSubstitutions.prototype.substituteInputValues = function (inputs) {
	        this._processed = this._original;
	        var regEx = /\{{2}([a-z0-9_$@]+).value\}{2}/gi;
	        var matches;
	        while ((matches = regEx.exec(this._original)) != null) {
	            var matchedInput = null;
	            for (var i = 0; i < inputs.length; i++) {
	                if (inputs[i].id.toLowerCase() == matches[1].toLowerCase()) {
	                    matchedInput = inputs[i];
	                    break;
	                }
	            }
	            if (matchedInput) {
	                this._processed = this._processed.replace(matches[0], matchedInput.value ? matchedInput.value : "");
	            }
	        }
	        ;
	        this._isProcessed = true;
	    };
	    StringWithSubstitutions.prototype.get = function () {
	        if (!this._isProcessed) {
	            return this._original;
	        }
	        else {
	            return this._processed;
	        }
	    };
	    StringWithSubstitutions.prototype.set = function (value) {
	        this._original = value;
	        this._isProcessed = false;
	    };
	    return StringWithSubstitutions;
	}());
	exports.StringWithSubstitutions = StringWithSubstitutions;
	//# sourceMappingURL=utils.js.map

/***/ },
/* 150 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var AbstractTextFormatter = (function () {
	    function AbstractTextFormatter(regularExpression) {
	        this._regularExpression = regularExpression;
	    }
	    AbstractTextFormatter.prototype.format = function (input) {
	        var matches;
	        var result = input;
	        while ((matches = this._regularExpression.exec(input)) != null) {
	            result = result.replace(matches[0], this.internalFormat(matches));
	        }
	        ;
	        return result;
	    };
	    return AbstractTextFormatter;
	}());
	var DateFormatter = (function (_super) {
	    __extends(DateFormatter, _super);
	    function DateFormatter() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    DateFormatter.prototype.internalFormat = function (matches) {
	        var date = new Date(Date.parse(matches[1]));
	        if (matches[2] != undefined) {
	            var longOrShort = matches[2].toLowerCase();
	            return date.toLocaleDateString(undefined, { day: "numeric", weekday: longOrShort, month: longOrShort, year: "numeric" });
	        }
	        else {
	            return date.toLocaleDateString();
	        }
	    };
	    return DateFormatter;
	}(AbstractTextFormatter));
	var TimeFormatter = (function (_super) {
	    __extends(TimeFormatter, _super);
	    function TimeFormatter() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TimeFormatter.prototype.internalFormat = function (matches) {
	        var date = new Date(Date.parse(matches[1]));
	        return date.toLocaleTimeString();
	    };
	    return TimeFormatter;
	}(AbstractTextFormatter));
	function formatText(text) {
	    var formatters = [
	        new DateFormatter(/\{{2}date\((\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:z|Z|-\d{1,2}))(?:,(long|short))?\)\}{2}/gi),
	        new TimeFormatter(/\{{2}time\((\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:z|Z|-\d{1,2}))\)\}{2}/gi)
	    ];
	    var result = text;
	    for (var i = 0; i < formatters.length; i++) {
	        result = formatters[i].format(result);
	    }
	    return result;
	}
	exports.formatText = formatText;
	//# sourceMappingURL=text-formatters.js.map

/***/ },
/* 151 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function parseSpacingDefinition(obj) {
	    return obj ? {
	        top: obj["top"],
	        right: obj["right"],
	        bottom: obj["bottom"],
	        left: obj["left"]
	    } : null;
	}
	function parseColorDefinition(obj) {
	    return obj ? {
	        normal: obj["normal"],
	        subtle: obj["subtle"]
	    } : null;
	}
	function parseSeparationDefinition(obj) {
	    return obj ? {
	        spacing: obj["spacing"],
	        lineThickness: obj["lineThickness"],
	        lineColor: obj["lineColor"]
	    } : null;
	}
	function parseAdaptiveCardConfiguration(obj) {
	    return obj ? {
	        backgroundColor: obj["backgroundColor"],
	        padding: parseSpacingDefinition(obj["padding"])
	    } : null;
	}
	function parseTextBlockConfiguration(obj) {
	    return obj ? {
	        color: obj["color"],
	        separations: {
	            small: parseSeparationDefinition(obj["separations"]["small"]),
	            normal: parseSeparationDefinition(obj["separations"]["normal"]),
	            medium: parseSeparationDefinition(obj["separations"]["medium"]),
	            large: parseSeparationDefinition(obj["separations"]["large"]),
	            extraLarge: parseSeparationDefinition(obj["separations"]["extraLarge"])
	        }
	    } : null;
	}
	function parseContainerStyleDefinition(obj) {
	    return obj ? {
	        backgroundColor: obj["backgroundColor"],
	        padding: parseSpacingDefinition(obj["padding"]),
	        borderColor: obj["borderColor"],
	        borderThickness: obj["borderThickness"]
	    } : null;
	}
	function parseContainerConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"]),
	        normal: parseContainerStyleDefinition(obj["normal"]),
	        emphasis: parseContainerStyleDefinition(obj["emphasis"])
	    } : null;
	}
	function parseImageConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"]),
	        size: obj["size"]
	    } : null;
	}
	function parseImageSetConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"]),
	        imageSize: obj["imageSize"]
	    } : null;
	}
	function parseTextFormatDefinition(obj) {
	    return obj ? {
	        size: obj["size"],
	        color: obj["color"],
	        isSubtle: obj["isSubtle"],
	        weight: obj["weight"]
	    } : null;
	}
	function parseFactSetConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"]),
	        title: parseTextFormatDefinition(obj["title"]),
	        value: parseTextFormatDefinition(obj["value"]),
	        spacing: obj["spacing"]
	    } : null;
	}
	function parseColumnSetConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"])
	    } : null;
	}
	function parseColumnConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"])
	    } : null;
	}
	function parseShowCardActionConfiguration(obj) {
	    return obj ? {
	        actionMode: obj["actionMode"],
	        inlineCardSpacing: obj["inlineCardSpacing"],
	        backgroundColor: obj["backgroundColor"],
	        padding: parseSpacingDefinition(obj["padding"])
	    } : null;
	}
	function parseActionsConfiguration(obj) {
	    return obj ? {
	        maxActions: obj["maxActions"],
	        supportedActionTypes: obj["supportedActionTypes"],
	        separation: parseSeparationDefinition(obj["separation"]),
	        buttonSpacing: obj["buttonSpacing"],
	        stretch: obj["stretch"],
	        showCard: parseShowCardActionConfiguration(obj["showCard"]),
	        actionsOrientation: obj["orientation"],
	        actionAlignment: obj["horizontalAlignment"]
	    } : null;
	}
	function parseInputConfiguration(obj) {
	    return obj ? {
	        separation: parseSeparationDefinition(obj["separation"])
	    } : null;
	}
	function parseHostConfiguration(serializedConfiguration) {
	    var obj = JSON.parse(serializedConfiguration);
	    return obj ? {
	        supportedElementTypes: obj["supportedElementTypes"],
	        supportsInteractivity: obj["supportsInteractivity"],
	        fontFamily: obj["fontFamily"],
	        fontSizes: {
	            small: obj["fontSizes"]["small"],
	            normal: obj["fontSizes"]["normal"],
	            medium: obj["fontSizes"]["medium"],
	            large: obj["fontSizes"]["large"],
	            extraLarge: obj["fontSizes"]["extraLarge"]
	        },
	        fontWeights: {
	            lighter: obj["fontWeights"]["lighter"],
	            normal: obj["fontWeights"]["normal"],
	            bolder: obj["fontWeights"]["bolder"]
	        },
	        imageSizes: {
	            small: obj["imageSizes"]["small"],
	            medium: obj["imageSizes"]["medium"],
	            large: obj["imageSizes"]["large"],
	        },
	        colors: {
	            dark: parseColorDefinition(obj["colors"]["dark"]),
	            light: parseColorDefinition(obj["colors"]["light"]),
	            accent: parseColorDefinition(obj["colors"]["accent"]),
	            good: parseColorDefinition(obj["colors"]["good"]),
	            warning: parseColorDefinition(obj["colors"]["warning"]),
	            attention: parseColorDefinition(obj["colors"]["attention"])
	        },
	        strongSeparation: parseSeparationDefinition(obj["strongSeparation"]),
	        actions: parseActionsConfiguration(obj["actions"]),
	        adaptiveCard: parseAdaptiveCardConfiguration(obj["adaptiveCard"]),
	        container: parseContainerConfiguration(obj["container"]),
	        textBlock: parseTextBlockConfiguration(obj["textBlock"]),
	        image: parseImageConfiguration(obj["image"]),
	        imageSet: parseImageSetConfiguration(obj["imageSet"]),
	        factSet: parseFactSetConfiguration(obj["factSet"]),
	        column: parseColumnConfiguration(obj["column"]),
	        columnSet: parseColumnSetConfiguration(obj["columnSet"]),
	        input: parseInputConfiguration(obj["input"])
	    } : null;
	}
	exports.parseHostConfiguration = parseHostConfiguration;
	//# sourceMappingURL=host-configuration.js.map

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var basePlayer_1 = __webpack_require__(108);
	var controller_1 = __webpack_require__(110);
	var enums_1 = __webpack_require__(118);
	var i18n_1 = __webpack_require__(112);
	var playerHolderClass = '.videoPlayer';
	var VideoPlayerVM = (function (_super) {
	    __extends(VideoPlayerVM, _super);
	    function VideoPlayerVM(_params, _element) {
	        var _this = this;
	        _super.call(this, _element, _params.thumbnail, enums_1.SwiftCardContentType.video);
	        this._params = _params;
	        this._element = _element;
	        this.toggleMuteText = function () {
	            var key = _this.isMuted() ? 'videoPlayer_button_unmute' : 'videoPlayer_button_mute';
	            return i18n_1.default.fetch(key);
	        };
	        this.onVideoEnded = function () {
	            _this.touchedByUser = false;
	            _this.isPlaying(false);
	        };
	        this.getFullscreenButtonText = function () {
	            var key = _this.isInFullscreen() ? 'videoPlayer_exitFullscreen' : 'videoPlayer_fullscreen';
	            return i18n_1.default.fetch(key);
	        };
	        this.enterFullscreen = function () {
	            if (_this.playerHolder.requestFullscreen) {
	                _this.playerHolder.requestFullscreen();
	            }
	            else if (_this.playerHolder.mozRequestFullScreen) {
	                _this.playerHolder.mozRequestFullScreen();
	            }
	            else if (_this.playerHolder.webkitRequestFullScreen) {
	                _this.playerHolder.webkitRequestFullScreen();
	            }
	            else if (_this.playerHolder.msRequestFullScreen) {
	                _this.playerHolder.msRequestFullScreen();
	            }
	        };
	        this.onProgress = function (e) {
	            console.log(e);
	        };
	        this.exitFullscreen = function () {
	            if (document.exitFullscreen) {
	                document.exitFullscreen();
	            }
	            else if (document.mozCancelFullScreen) {
	                document.mozCancelFullScreen();
	            }
	            else if (document.webkitExitFullscreen) {
	                document.webkitExitFullscreen();
	            }
	            else if (document.msExitFullscreen) {
	                document.msExitFullscreen();
	            }
	        };
	        this.toggleFullscreen = function () {
	            _this.touchedByUser = _this.isPlaying();
	            if (_this.isInFullscreen()) {
	                _this.exitFullscreen();
	            }
	            else {
	                _this.enterFullscreen();
	                controller_1.default.instance.onEnteringFullscreen(_this);
	                _this.trackFullscreenAction();
	            }
	        };
	        this.trackSeekingAction = function () {
	            if (!_this.wasSeeked) {
	                _this.wasSeeked = true;
	            }
	        };
	        this.trackFullscreenAction = function () {
	            if (!_this.wasInFullscreen) {
	                _this.wasInFullscreen = true;
	            }
	        };
	        this.dispose = function () {
	            _this.fullscreenButtonText.dispose();
	        };
	        this.media = _params.media;
	        this.autoplay = _params.autoplay;
	        this.autoloop = _params.autoloop;
	        this.id = _params.messageId;
	        this.showLoadingInfo = _params.showLoadingInfo || true;
	        this.title = _params.title;
	        this.subtitle = _params.subtitle;
	        this.displayCurrentTime = _params.displayCurrentTime;
	        this.displayTotalTime = _params.displayTotalTime;
	        this.displayMuteButton = _params.displayMuteButton;
	        this.isMuted = ko.observable(_params.muted);
	        this.playerHolder = _element.querySelector(playerHolderClass);
	        this.isFullscreenSupported = !!(this.playerHolder.requestFullscreen || this.playerHolder.mozRequestFullScreen || this.playerHolder.webkitRequestFullScreen || this.playerHolder.msRequestFullScreen);
	        this.fullscreenButtonText = ko.computed(this.getFullscreenButtonText);
	        if (this.player) {
	            this.player.muted = _params.muted;
	        }
	        controller_1.default.instance.registerPlayer(this);
	    }
	    VideoPlayerVM.prototype.toggleMute = function () {
	        this.touchedByUser = true;
	        if (this.isMuted()) {
	            this.mute(false);
	        }
	        else {
	            this.mute(true);
	        }
	    };
	    ;
	    return VideoPlayerVM;
	}(basePlayer_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = VideoPlayerVM;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var app_1 = __webpack_require__(26);
	var identityType_1 = __webpack_require__(29);
	var baseMessage_1 = __webpack_require__(120);
	var application_1 = __webpack_require__(47);
	var signinState_1 = __webpack_require__(71);
	var actionTrigger_1 = __webpack_require__(154);
	var CHAT_ENABLED_SUBSCRIPTION = 'isChatEnabled';
	var WelcomeVM = (function (_super) {
	    __extends(WelcomeVM, _super);
	    function WelcomeVM(message, conversation) {
	        var _this = this;
	        _super.call(this, message, conversation);
	        this.loggedIn = ko.observable();
	        this.nameClicked = ko.observable(false);
	        this.isChatEnabled = ko.observable(true);
	        this.isAgent = ko.observable(true);
	        this.isGuest = ko.observable(true);
	        this.avatarUrl = ko.observable();
	        this.displayName = ko.observable();
	        this.title = ko.observable();
	        this.dispose = function () {
	            // super.dispose();
	            application_1.default.instance.SignInManager.unsubscribe('isSignedIn', _this.onAppReadyStateChange);
	            application_1.default.instance.Messaging.mePerson.unsubscribe('displayName', _this.onDisplayNameChange);
	            //  if (this._conversation) {
	            //     this._conversation.unsubscribe(CHAT_ENABLED_SUBSCRIPTION, this.isChatEnabled);
	            // }
	        };
	        this.onDisplayNameChange = function () {
	            _this.setGreetingMessage();
	        };
	        this.onAppReadyStateChange = function () {
	            _this.welcomeMsgHandler();
	        };
	        this.isGuestOnlyMode = app_1.default.isGuestOnlyMode;
	        this._conversation = conversation;
	        // Application.instance.SignInManager.subscribe('state', (value: any)=>{
	        //     if(value === SigninState.SignedOut) {
	        //         this.title(this._conversation.topic)
	        //     }
	        // })
	        application_1.default.instance.SignInManager.subscribe('isSignedIn', this.onAppReadyStateChange);
	        application_1.default.instance.Messaging.mePerson.subscribe('displayName', this.onDisplayNameChange);
	        // this._conversation.subscribe(CHAT_ENABLED_SUBSCRIPTION, this.isChatEnabled);
	        this.isAgent(conversation.isConversationWithBot());
	        this.isGuest(app_1.default.isGuestUser());
	        this.welcomeMsgHandler();
	        this.setGreetingMessage();
	        this.getAvatarUrl();
	        this.getConversationTitle();
	    }
	    WelcomeVM.prototype.getAvatarUrl = function () {
	        var person = application_1.default.instance.StratusManager.getPerson(this._conversation.id, true);
	        if (person.avatarData) {
	            this.avatarUrl(person.avatarData);
	        }
	        else {
	            var conversationId = this._conversation.id;
	            this.subsribeToAvatarUrl(person, conversationId);
	        }
	    };
	    WelcomeVM.prototype.getConversationTitle = function () {
	        var _this = this;
	        if (this._conversation.topic === '' && !this._conversation.isGroup()) {
	            var person_1 = application_1.default.instance.StratusManager.getPerson(this._conversation.id);
	            if (person_1.displayName === person_1.id) {
	                application_1.default.instance.SignInManager.getSkypeToken()
	                    .then(function (token) {
	                    if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                        _this._subscribeToDisplayName(person_1);
	                    }
	                }).catch(function (error) {
	                    if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                        _this._subscribeToDisplayName(person_1);
	                    }
	                    else {
	                        application_1.default.instance.SignInManager.subscribe('state', function () {
	                            if (application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn) {
	                                return;
	                            }
	                            _this._subscribeToDisplayName(person_1);
	                            person_1.fetchDisplayName();
	                        });
	                    }
	                });
	            }
	        }
	        else {
	            this.title(this._conversation.topic);
	            this._conversation.subscribe('topic', function (value) {
	                _this.title(value);
	            });
	        }
	    };
	    WelcomeVM.prototype._subscribeToDisplayName = function (person) {
	        var _this = this;
	        person.displayName && this._handleDisplayName(person);
	        person.subscribe('displayName', function () { return _this._handleDisplayName(person); });
	    };
	    WelcomeVM.prototype._handleDisplayName = function (person) {
	        this.title(person.displayName === person.id ? '' : person.displayName);
	    };
	    WelcomeVM.prototype.subsribeToAvatarUrl = function (person, conversationId) {
	        var _this = this;
	        var subscribeAvatarData = function () {
	            person.subscribe('avatarData', function (url) {
	                if (conversationId !== _this._conversation.id) {
	                    return;
	                }
	                _this.avatarUrl(url);
	            });
	        };
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                subscribeAvatarData();
	            }
	        }).catch(function (error) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                subscribeAvatarData();
	            }
	            else {
	                application_1.default.instance.SignInManager.subscribe('state', function () {
	                    if (application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn) {
	                        return;
	                    }
	                    subscribeAvatarData();
	                    application_1.default.instance.StratusManager.getPerson(_this._conversation.id, true);
	                });
	            }
	        });
	    };
	    WelcomeVM.prototype.signin = function () {
	        application_1.default.instance.SignInManager.login();
	    };
	    WelcomeVM.prototype.sendHi = function () {
	        // if(!this.isChatEnabled()) {
	        //     return;
	        // }
	        // Application.instance.Messaging.sendMessage(this._conversation.id, 'hi', ActionTrigger.WELCOME_MESSAGE);
	        this._conversation.sendMessage('hi', actionTrigger_1.ActionTrigger.WELCOME_MESSAGE);
	    };
	    WelcomeVM.prototype.nameClick = function () {
	        this.nameClicked(true);
	    };
	    WelcomeVM.prototype.signout = function () {
	        this.nameClicked(false);
	        application_1.default.instance.SignInManager.logout('welcome');
	    };
	    WelcomeVM.prototype.welcomeMsgHandler = function () {
	        if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST) {
	            this.loggedIn(false);
	            return;
	        }
	        this.loggedIn(application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedOut);
	    };
	    WelcomeVM.prototype.setGreetingMessage = function () {
	        var me = application_1.default.instance.Messaging.mePerson;
	        this.displayName(me.displayName);
	    };
	    return WelcomeVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = WelcomeVM;


/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	(function (ActionTrigger) {
	    /**
	     * Using of this enum points to application error.
	     */
	    ActionTrigger[ActionTrigger["UNDEFINED"] = 0] = "UNDEFINED";
	    /**
	     * Send button is clicked
	     */
	    ActionTrigger[ActionTrigger["BUTTON_SEND_CLICK"] = 1] = "BUTTON_SEND_CLICK";
	    /**
	     * Enter is pressed
	     */
	    ActionTrigger[ActionTrigger["KEYPRESS_ENTER"] = 2] = "KEYPRESS_ENTER";
	    /**
	     * Send hi from welcome message
	     */
	    ActionTrigger[ActionTrigger["WELCOME_MESSAGE"] = 3] = "WELCOME_MESSAGE";
	    /**
	     * While typing such as typing indicator
	     */
	    ActionTrigger[ActionTrigger["TYPING"] = 4] = "TYPING";
	    ActionTrigger[ActionTrigger["SUGGESTED_ACTION"] = 5] = "SUGGESTED_ACTION";
	    ActionTrigger[ActionTrigger["BUTTON_SWIFT_CLICKED"] = 6] = "BUTTON_SWIFT_CLICKED";
	    /**
	     * Sending a contact request via message
	     */
	    ActionTrigger[ActionTrigger["INVITE"] = 7] = "INVITE";
	})(exports.ActionTrigger || (exports.ActionTrigger = {}));
	var ActionTrigger = exports.ActionTrigger;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var app_1 = __webpack_require__(26);
	var baseMessage_1 = __webpack_require__(120);
	var TranslateVM = (function (_super) {
	    __extends(TranslateVM, _super);
	    function TranslateVM(message, conversation) {
	        _super.call(this, message, conversation);
	        this.myLanguage = ko.observable();
	        this.theirLanguage = ko.observable();
	        this.callToAction = ko.observable();
	        this.myLanguage(app_1.default.translationLanguages[navigator.language.split('-')[0]].name);
	        this.theirLanguage(app_1.default.translationLanguages[app_1.default.translationLanguage].name);
	        this.callToAction('Start translation?');
	    }
	    TranslateVM.prototype.activateTranslation = function () {
	        this.callToAction('');
	        // app.translationStatus(1);
	    };
	    return TranslateVM;
	}(baseMessage_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TranslateVM;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// import * as focusHandler from './focusHandler';
	var keys_1 = __webpack_require__(157);
	var common_1 = __webpack_require__(111);
	var eventHelper_1 = __webpack_require__(158);
	function registerKeyboardNavigationBindingHandler() {
	    var TAB_INDEX_ATTRIBUTE_NAME = 'tabindex';
	    ko.bindingHandlers['keyboardNavigation'] = {
	        init: function (container, valueAccessor) {
	            var focusedElement, isClick = false, options = {
	                persistSelection: true,
	                selectLastItem: valueAccessor().selectLastItem,
	                itemSelector: valueAccessor().itemSelector || ''
	            };
	            var onMouseDown = function () { return isClick = true; };
	            var onMouseUp = function () { return isClick = false; };
	            makeElementSelectable(container);
	            setItemTabIndexes();
	            addListeners();
	            function setItemTabIndexes() {
	                var itemsInList = getItemsInList();
	                itemsInList.forEach(controlElementSelectable);
	            }
	            function getItemsInList() {
	                var itemsInList = container.querySelectorAll(options.itemSelector);
	                return nodeListToArray(itemsInList);
	            }
	            function nodeListToArray(nodeList) {
	                return Array.prototype.slice.call(nodeList);
	            }
	            function addListeners() {
	                container.addEventListener(common_1.default.events.browser.FOCUS, onFocus, true);
	                container.addEventListener(common_1.default.events.browser.BLUR, onBlur, true);
	                container.addEventListener(common_1.default.events.browser.KEYDOWN, onKeyDown);
	                container.addEventListener(common_1.default.events.browser.MOUSEDOWN, onMouseDown);
	                container.addEventListener(common_1.default.events.browser.MOUSEUP, onMouseUp);
	                ko.utils.domNodeDisposal.addDisposeCallback(container, function () {
	                    container.removeEventListener(common_1.default.events.browser.FOCUS, onFocus, true);
	                    container.removeEventListener(common_1.default.events.browser.BLUR, onBlur, true);
	                    container.removeEventListener(common_1.default.events.browser.KEYDOWN, onKeyDown);
	                    container.removeEventListener(common_1.default.events.browser.MOUSEDOWN, onMouseDown);
	                    container.removeEventListener(common_1.default.events.browser.MOUSEUP, onMouseUp);
	                });
	            }
	            function onFocus(event) {
	                var itemsInList;
	                if (!elementIsContainer(event.target)) {
	                    return;
	                }
	                itemsInList = getItemsInList();
	                if (!itemsInList.length) {
	                    return;
	                }
	                controlElementSelectable(container);
	                setItemTabIndexes();
	                if (isClick) {
	                    isClick = false;
	                    return;
	                }
	                if (itemsInList.indexOf(focusedElement) !== -1) {
	                    focusElement(focusedElement);
	                }
	                else if (options.selectLastItem) {
	                    focusElement(itemsInList[itemsInList.length - 1]);
	                }
	                else {
	                    focusElement(itemsInList[0]);
	                }
	            }
	            function onBlur(event) {
	                var target = event.target;
	                window.setTimeout(function () {
	                    var itemsInList = getItemsInList();
	                    if (!isItemSelection()) {
	                        makeElementSelectable(container);
	                    }
	                    function isItemSelection() {
	                        return elementIsContainer(target) || itemsInList.indexOf(document.activeElement) !== -1;
	                    }
	                }, 1);
	            }
	            function onKeyDown(event) {
	                var itemsInList, keyCode = eventHelper_1.default.getKeyCode(event);
	                if (shouldHandleContextMenu(event)) {
	                    openContextMenu(event);
	                    return;
	                }
	                if ((keyCode === keys_1.default.ENTER || keyCode === keys_1.default.SPACE) && document.activeElement === focusedElement) {
	                    focusedElement.click();
	                }
	                if (!shouldHandleList(keyCode)) {
	                    return;
	                }
	                itemsInList = getItemsInList();
	                setItemTabIndexes();
	                event.preventDefault();
	                event.stopPropagation();
	                if (keyCode === keys_1.default.LEFT || keyCode === keys_1.default.UP) {
	                    selectSubsequentItem(-1);
	                }
	                else if (keyCode === keys_1.default.RIGHT || keyCode === keys_1.default.DOWN) {
	                    selectSubsequentItem(1);
	                }
	                else if (keyCode === keys_1.default.HOME) {
	                    selectFirstItem();
	                }
	                else if (keyCode === keys_1.default.END) {
	                    selectLastItem();
	                }
	                return false;
	                function selectSubsequentItem(direction) {
	                    var targetElement = itemsInList[itemsInList.indexOf(event.target)];
	                    do {
	                        targetElement = itemsInList[itemsInList.indexOf(targetElement) + direction];
	                        if (!targetElement) {
	                            break;
	                        }
	                        focusElement(targetElement);
	                    } while (document.activeElement !== targetElement);
	                }
	                function selectFirstItem() {
	                    focusElement(itemsInList[0]);
	                }
	                function selectLastItem() {
	                    focusElement(itemsInList[itemsInList.length - 1]);
	                }
	            }
	            function focusElement(element) {
	                // focusHandler.get().addFocusRequestToQueue(element, focusHandler.Priorities.Immediate);
	                if (element.focus) {
	                    element.focus();
	                }
	                if (options.persistSelection) {
	                    focusedElement = element;
	                }
	            }
	            function makeElementSelectable(element) {
	                element.setAttribute(TAB_INDEX_ATTRIBUTE_NAME, 0);
	            }
	            function controlElementSelectable(element) {
	                element.setAttribute(TAB_INDEX_ATTRIBUTE_NAME, -1);
	            }
	            function elementIsContainer(element) {
	                return element === container;
	            }
	            function shouldHandleList(keyCode) {
	                var handleKeyCodes = [keys_1.default.LEFT, keys_1.default.UP, keys_1.default.RIGHT, keys_1.default.DOWN, keys_1.default.HOME, keys_1.default.END];
	                return handleKeyCodes.indexOf(keyCode) > -1;
	            }
	            function shouldHandleContextMenu(event) {
	                var keyCode = eventHelper_1.default.getKeyCode(event);
	                return event.shiftKey && keyCode === keys_1.default.F10;
	            }
	            function openContextMenu(event) {
	                var rightClickEvent = document.createEvent('MouseEvents'), clientRect = event.target.getBoundingClientRect();
	                event.preventDefault();
	                event.stopPropagation();
	                rightClickEvent.initMouseEvent('contextmenu', true, // bubbles
	                false, // cancelable
	                window, // view
	                0, // mouse click count (?)
	                0, // screen position (?)
	                0, clientRect.right, // client position - here's the meat
	                clientRect.top, false, false, true, false, // ctrl, alt, shift, meta
	                2, // mouse button - 2 means the right button
	                null // relatedTarget - can be just null
	                );
	                event.target.dispatchEvent(rightClickEvent);
	            }
	        }
	    };
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    register: registerKeyboardNavigationBindingHandler
	};


/***/ },
/* 157 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    BACKSPACE: 8,
	    TAB: 9,
	    ENTER: 13,
	    SHIFT: 16,
	    ESCAPE: 27,
	    SPACE: 32,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    END: 35,
	    HOME: 36,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    NUMBER_0: 48,
	    NUMBER_9: 57,
	    NUMPAD_0: 96,
	    NUMPAD_9: 105,
	    A: 65,
	    G: 71,
	    H: 72,
	    J: 74,
	    K: 75,
	    L: 76,
	    Z: 90,
	    F6: 117,
	    F10: 121
	};


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var keys_1 = __webpack_require__(157);
	var keys = keys_1.default, numPadMap = {
	    96: '0',
	    97: '1',
	    98: '2',
	    99: '3',
	    100: '4',
	    101: '5',
	    102: '6',
	    103: '7',
	    104: '8',
	    105: '9'
	};
	function EmptyEmitter() { }
	EmptyEmitter.prototype.emit = function () { };
	EmptyEmitter.prototype.done = function () { };
	function swallow(e) {
	    e.preventDefault();
	}
	function getKeyCode(e) {
	    return e.which || e.keyCode;
	}
	function getNumpadKey(e) {
	    return isNumPadKey(e) ? numPadMap[getKeyCode(e)] : false;
	}
	function isActivation(e) {
	    var keyCode = getKeyCode(e);
	    return keyCode === keys.ENTER || keyCode === keys.SPACE;
	}
	function isAlphaNumericKey(e) {
	    var keyCode = getKeyCode(e);
	    return (keyCode >= keys.NUMBER_0 && keyCode <= keys.NUMBER_9) || (keyCode >= keys.A && keyCode <= keys.Z);
	}
	function isNumPadKey(e) {
	    var keyCode = getKeyCode(e);
	    return keyCode >= keys.NUMPAD_0 && keyCode <= keys.NUMPAD_9;
	}
	function isDeactivation(e) {
	    var keyCode = getKeyCode(e);
	    return keyCode === keys.ESCAPE;
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = {
	    swallow: swallow,
	    getKeyCode: getKeyCode,
	    getNumpadKey: getNumpadKey,
	    isActivation: isActivation,
	    isAlphaNumericKey: isAlphaNumericKey,
	    isNumPadKey: isNumPadKey,
	    // void EmptyEmitter(),
	    isDeactivation: isDeactivation
	};


/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = "<!-- ko if: showContactRequest() -->\n    <div class=\"message contactRequest\">\n        <span data-bind=\"text: titleKey\"></span><span data-bind=\"text: messageKey\"></span>\n    </div>\n<!-- /ko -->\n"

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = "\n<div class=\"message\" role=\"presentation\" data-bind=\"css: {me: messageFromMe, other: !messageFromMe, new: isNew}, attr: {'data-messageType': type}\">\n    <!-- ko if: showAuthor -->\n        <div class=\"author\" data-bind=\"text:author\"></div>\n    <!-- /ko -->\n    <div class=\"lwx-message\" role=\"listitem\">\n        <!-- ko if: !imageContent() && content -->\n            <div class=\"content\" data-bind=\"html: content, style:{backgroundColor:messageColor}\"></div>\n            <!-- ko if: isTranslated -->\n                <div class=\"translation-globe\"><svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12 6c0-.6 0-1-.2-1.6L11.2 3c-.3-.5-.6-1-1-1.2-.3-.4-.7-.7-1.2-1L7.6.2 6 0c-.6 0-1 0-1.6.2L3 .8c-.5.3-1 .6-1.2 1-.4.3-.7.7-1 1.2L.2 4.4 0 6c0 .6 0 1 .2 1.6L.8 9c.3.5.6 1 1 1.2.3.4.7.7 1.2 1l1.4.6L6 12c.6 0 1 0 1.6-.2l1.4-.6c.5-.3 1-.6 1.2-1 .4-.3.7-.7 1-1.2l.6-1.4L12 6zm-1.4 2.4l-.6 1-.8.6c-.2.3-.5.5-.8.6l-1 .4.5-1.3V8.4h2.3zm-3.2 0v.4l-.2.6-.3.6-.6.6c0 .2-.2.3-.3.4l-.3.2s-.4 0-.5-.2l-.3-.4V10c0-.2 0-.4-.3-.6v-.6l-.2-.4h2.8zM11.2 6c0 .5 0 1-.3 1.6H8V4.4h3V6zm-6.6 5c-.3 0-.6-.2-1-.4-.3 0-.6-.3-1-.6 0-.2-.4-.4-.6-.7l-.6-1h2.4c0 .6.2 1 .3 1.4L5 11zm3-5v1.6h-3l-.2-.8V4.4h3l.2.8V6zm3-2.4H8.2c0-.5-.2-1-.3-1.3L7 1c.3 0 .6.2 1 .4.3 0 .6.3.8.6l1 .7.5 1zm-7 4H1v-.8C.7 6.5.7 6.3.7 6v-.8c0-.3.2-.6.3-.8h2.7v3.2zm3.8-4H4.6v-.4l.2-.6L5 2l.3-.6c0-.2.2-.3.3-.4L6 .8s.3 0 .4.2l.3.4.3.6c0 .2 0 .4.2.6v.6l.2.4zM4.6 1L4 2.3v1.3H1.4l.6-1 .7-.6c.3-.3.6-.5 1-.6l1-.4z\" fill=\"#949494\"/></svg></div>\n            <!-- /ko -->\n        <!-- /ko -->\n        <!-- ko if: imageContent -->\n            <div class=\"content image\" data-bind=\"html: imageContent, style:{backgroundColor:messageColor}\"></div>\n        <!-- /ko -->\n    </div>\n    <!-- ko ifnot: deliveryFailed() -->\n        <div class=\"timestamp\" data-bind=\"text: showStatus() ? status : timestamp, css: {sending: showStatus()}\"></div>\n    <!-- /ko -->\n    <!-- ko if: deliveryFailed() -->\n        <div class=\"failedStatus\" data-bind=\"text: status\"></div>\n    <!-- /ko -->\n</div>\n"

/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports = "<div class=\"message swiftContainer\">\n    <!-- ko if: showAuthor -->\n        <div class=\"author\" data-bind=\"text: author\"></div>\n    <!-- /ko -->\n    <div class=\"swift\">\n        <!-- ko if: !swift.isSupported() -->\n            <!-- ko template: { name: 'swiftUnsupported', data: swift } -->\n            <!-- /ko -->\n        <!-- /ko -->\n        <!-- ko if: swift.isSupported() -->\n            <!-- ko if: swift.isCarousel() -->\n                <!-- ko template: { name: 'swiftCarouselCard', data: swift } -->\n                <!-- /ko -->\n            <!-- /ko -->\n            <!-- ko if: !swift.isCarousel() -->\n                <!-- ko template: { name: 'swiftSingleCard', data: swift } -->\n                <!-- /ko -->\n            <!-- /ko -->\n        <!-- /ko -->\n    </div>\n    <div class=\"timestamp\" data-bind=\"text:timestamp\"></div>\n</div>\n"

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = "<!-- DO NOT REMOVE - Adaptive Card template holder -->\n"

/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports = "<div class=\"imagemessage message\" data-bind=\"css: {me: messageFromMe}, attr: {'data-messageType': type}\">\n    <!-- ko if: showAuthor -->\n        <div class=\"author\" data-bind=\"text:author\"></div>\n    <!-- /ko -->\n    <div class=\"PictureSharing\">\n        <a class=\"thumbnailHolder\" data-bind=\"click: downloadImage\" target=\"_blank\" tabindex=\"-1\">\n            <!-- ko if: thumbnailUrl -->\n            <span class=\"thumbnail\" data-bind=\"style: {backgroundImage: 'url(\\'' + thumbnailUrl() + '\\')'}\"></span>\n            <!-- /ko -->\n\n            <!-- ko ifnot: thumbnailUrl -->\n            <span class=\"thumbnail\" style=\"display:none\"></span>\n            <!-- /ko -->\n        </a>\n    </div>\n    <div class=\"timestamp\" data-bind=\"text:timestamp\"></div>\n</div>\n"

/***/ },
/* 164 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filemessage message\" data-bind=\"css: {me: messageFromMe}, attr: {'data-messageType': type}\">\n    <!-- ko if: showAuthor -->\n        <div class=\"author\" data-bind=\"text:author\"></div>\n    <!-- /ko -->\n    <div class=\"bubble\" data-bind=\"css: iconClasses\">\n        <button aria-label=\"download file\" class=\"download\" data-bind=\"click: downloadFile\">\n            <icon-download />\n        </button>\n    </div>\n    <div class=\"meta\">\n        <div class=\"name\" data-bind=\"text: originalName, attr: {title: originalName}\"></div>\n        <div class=\"size\" data-bind=\"text: displaySize, attr: {title: displaySize}\"></div>\n    </div>\n    <div class=\"timestamp\" data-bind=\"text:timestamp\"></div>\n</div>\n"

/***/ },
/* 165 */
/***/ function(module, exports) {

	module.exports = "<div class=\"message welcome\">\n  \n  <!-- ko if: !loggedIn || (loggedIn && displayName) -->\n\t<skype-logo></skype-logo>\n  <!-- /ko -->\n  \n  <!-- ko ifnot: loggedIn -->\n  <div class=\"callToAction\" >\n    <!-- ko if: isAgent -->\n    <button class=\"sayhi\" aria-label=\"Say hi to a bot\" tabindex=\"0\" data-bind=\"click:sendHi\">Say 'hi'</button> \n    <!-- /ko -->\n\n    <!-- ko ifnot: isGuestOnlyMode -->\n    or\n    <span class=\"signin\">\n       <button tabindex=\"0\" aria-label=\"Sign in to save your chat\" data-bind=\"click:signin\">sign in</button> to save your chat.\n    </span>\n    <!-- /ko -->\n\n  </div>\n\t<!-- /ko -->\n\n\t<!-- ko if: loggedIn -->\n\t<div >\n    Welcome back, <button data-bind=\"attr:{'aria-label':displayName}, text:displayName, click: nameClick, css: {nameClicked: nameClicked}\" tabindex=\"0\"></button>!\n  </div>\n  <!-- ko if: nameClicked -->\n  <div>\n    <button class=\"signin\" aria-label=\"Click here to switch accounts\" tabindex=\"0\" data-bind=\"click:signout\">Click here</button> to switch accounts.\n  </div>\n  <!-- /ko -->\n  <!-- /ko -->\n</div>\n"

/***/ },
/* 166 */
/***/ function(module, exports) {

	module.exports = "<div class=\"message welcome\">\n\t<skype-logo></skype-logo>\n  <div>\n    They are speaking <a data-bind=\"text: theirLanguage\"></a>.\n  </div>\n  <div>\n    You are speaking <a data-bind=\"text: myLanguage\"></a>.\n  </div>\n  <div>\n    <a data-bind=\"click:activateTranslation, text: callToAction\"></a>\n  </div>\n</div>\n"

/***/ },
/* 167 */
/***/ function(module, exports) {

	module.exports = "<div class=\"audioPlayer\">\n    <!-- ko if: showCoverImage() -->\n    <div class=\"coverHolder\">\n        <img class=\"thumbnail\" data-bind=\"attr: { src: coverImage.url, alt: coverImage.alt, width: coverImage.uiSize().width, height: coverImage.uiSize().height },\n                style: { left: coverImage.leftAlignment() + 'px', bottom: coverImage.bottomAlignment() + 'px' }\" />\n    </div>\n    <!-- /ko -->\n    <!-- ko if: showLoadingInfo -->\n    <div class=\"loader\" data-bind=\"visible: isLoading()\"></div>\n    <div class=\"error\" data-bind=\"visible: failed()\">\n        <icon-error />\n    </div>\n    <!-- /ko -->\n\n    <div class=\"controlsOverlay\" data-bind=\"click: togglePlay\"></div>\n\n    <audio class=\"player\" data-bind=\"attr: { src: media, poster: thumbnail }, click: togglePlay,\n            event: {canplay: onReady, error: onError, loadedmetadata: onMetadataLoaded, timeupdate: onTimeUpdated, ended: onAudioEnded}\"></audio>\n\n    <div class=\"playerControls\" data-bind=\"visible: canPlay\">\n\n        <button data-bind=\"click: togglePlay, attr: {title: playButtonText}\"\n                class=\"button\" type=\"button\">\n            <!-- ko if: isPlaying() -->\n            <icon-pause></icon-pause>\n            <!-- /ko -->\n            <!-- ko if: !isPlaying() -->\n            <icon-play></icon-play>\n            <!-- /ko -->\n        </button>\n\n        <div class=\"timeline\" data-bind=\"click: onTimelineClick\">\n            <div class=\"timers\">\n                <div class=\"currentTime\" data-bind=\"text: currentTime\"></div>\n                <div class=\"totalTime\" data-bind=\"text: totalTime\"></div>\n            </div>\n            <div class=\"totalProgress\"></div>\n\n            <div class=\"progress\" data-bind=\"attr: {style: currentProgress}\">\n                <div class=\"handle\" data-bind=\"event: {mousedown: onHandleStartDrag}\"></div>\n            </div>\n\n        </div>\n\n    </div>\n</div>\n"

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"videoPlayer\">\n\n    <div class=\"fullsreenInfo\" data-bind=\"visible: isInFullscreen\">\n        <!-- ko if: title -->\n        <h1 data-bind=\"text: title, attr: { title: title }\"></h1>\n        <!-- /ko -->\n        <!-- ko if: subtitle -->\n        <h2 data-bind=\"text: subtitle, attr: { title: subtitle }\"></h2>\n        <!-- /ko -->\n    </div>\n\n    <!-- ko if: showLoadingInfo -->\n    <div class=\"loader\" data-bind=\"visible: isLoading()\"></div>\n    <div class=\"error\" data-bind=\"visible: failed()\">\n        <icon-error />\n    </div>\n    <!-- /ko -->\n\n    <div class=\"controlsOverlay\" data-bind=\"click: togglePlay\"></div>\n\n    <video class=\"player\" data-bind=\"attr: { src: media, poster: thumbnail, loop: autoloop}, click: togglePlay,\n            event: {onprogress: onProgress, canplay: onReady, error: onError, loadedmetadata: onMetadataLoaded, timeupdate: onTimeUpdated, ended: onVideoEnded}\">\n    </video>\n\n    <div class=\"playerControls\" data-bind=\"visible: canPlay\">\n\n        <button data-bind=\"click: togglePlay, attr: {title: playButtonText}\"\n                class=\"button\" type=\"button\">\n            <!-- ko if: isPlaying() -->\n            <icon-pause></icon-pause>\n            <!-- /ko -->\n            <!-- ko if: !isPlaying() -->\n            <icon-play></icon-play>\n            <!-- /ko -->\n        </button>\n\n        <!-- ko if: displayCurrentTime -->\n        <div class=\"currentTime\" data-bind=\"text: currentTime\"></div>\n        <!-- /ko  -->\n\n        <div class=\"timeline\" data-bind=\"click: onTimelineClick\">\n            <div class=\"totalProgress\"></div>\n            <div class=\"progress\" data-bind=\"attr: {style: currentProgress}\">\n                <div class=\"handle\" data-bind=\"event: {mousedown: onHandleStartDrag}\"></div>\n            </div>\n        </div>\n\n        <!-- ko if: displayTotalTime -->\n        <div class=\"totalTime\" data-bind=\"text: totalTime\"></div>\n        <!-- /ko -->\n\n        <!-- ko if: displayMuteButton -->\n        <button data-bind=\"click: toggleMute, attr: {title: toggleMuteText()}\"\n                class=\"button\" type=\"button\">\n            <!-- ko if: isMuted() -->\n            <icon-unmute></icon-unmute>\n            <!-- /ko -->\n            <!-- ko if: !isMuted() -->\n            <icon-mute></icon-mute>\n            <!-- /ko -->\n        </button>\n        <!-- /ko -->\n\n        <!-- ko if: isFullscreenSupported -->\n        <button data-bind=\"click: toggleFullscreen, attr: {title: fullscreenButtonText}\"\n                class=\"button toggleFullscreen\" type=\"button\">\n            <!-- ko if: isInFullscreen() -->\n            <icon-exit-fullscreen></icon-exit-fullscreen>\n            <!-- /ko -->\n            <!-- ko if: !isInFullscreen() -->\n            <icon-enter-fullscreen></icon-enter-fullscreen>\n            <!-- /ko -->\n        </button>\n        <!-- /ko -->\n\n    </div>\n</div>\n"

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports = "<div class=\"gifPlayer\">\n    <!-- ko if: showCoverImage() -->\n    <div class=\"coverHolder\">\n        <img class=\"thumbnail\" data-bind=\"attr: { src: coverImage.url, alt: coverImage.alt, width: coverImage.uiSize().width, height: coverImage.uiSize().height },\n                style: { left: coverImage.leftAlignment() + 'px', bottom: coverImage.bottomAlignment() + 'px' }\" />\n    </div>\n    <!-- /ko -->\n    <!-- ko if: showLoadingInfo -->\n    <div class=\"loader\" data-bind=\"visible: isLoading()\"></div>\n    <div class=\"error\" data-bind=\"visible: failed()\">\n        <icon-error />\n    </div>\n    <!-- /ko -->\n\n    <!-- ko if: media -->\n    <img data-bind=\"visible: canPlay(),\n            attr: { src: media.url,\n                alt: media.alt,\n                width: media.uiSize().width,\n                height: media.uiSize().height\n            }, style: { left: media.leftAlignment(),\n                bottom: media.bottomAlignment()\n            },\n            event: { load: onReady, error: onError }\" />\n    <!-- /ko -->\n</div>\n"

/***/ },
/* 170 */
/***/ function(module, exports) {

	"use strict";
	var Theme = (function () {
	    function Theme() {
	    }
	    Theme.DEFAULT = 'default';
	    Theme.DARK = 'dark';
	    return Theme;
	}());
	exports.Theme = Theme;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	/**
	 * Event being published when user completes the
	 * session which is a serie of messages being exchanged with a bot.
	 * Session is ended if:
	 * - user closes/minimizes the chat control
	 * - after a x minutes of inactivity.
	 *
	 * @export
	 * @class SessionEndEvent
	 * @extends {TelemetryEvent}
	 */
	var SessionEndEvent = (function (_super) {
	    __extends(SessionEndEvent, _super);
	    function SessionEndEvent() {
	        _super.call(this, 'kpi_session_end');
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignInEvent
	     */
	    SessionEndEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('timeToComplete', this.ttc, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('chatsCount', this.chatsCount || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return SessionEndEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.SessionEndEvent = SessionEndEvent;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	var theme_1 = __webpack_require__(170);
	/**
	 * Event being published when user starts the
	 * chat session by loading either skype or directline PackageName.
	 *
	 * @export
	 * @class ChatSessionStartEvent
	 * @extends {TelemetryEvent}
	 */
	var SessionStartEvent = (function (_super) {
	    __extends(SessionStartEvent, _super);
	    function SessionStartEvent() {
	        _super.call(this, 'kpi_session_start');
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SessionStartEvent
	     */
	    SessionStartEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('theme', this.theme || theme_1.Theme.DEFAULT, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('tts', this.tts + '', piiType_1.PIIType.NotSet));
	        SessionStartEvent.isAvailable = false;
	        return props;
	    };
	    SessionStartEvent.isAvailable = true;
	    return SessionStartEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.SessionStartEvent = SessionStartEvent;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryEvent_1 = __webpack_require__(23);
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	/**
	 * Event being published when user changes visibility of control:
	 * opens or closes it
	 *
	 * @export
	 * @class VisibilityChangedEvent
	 * @extends {TelemetryEvent}
	 */
	var VisibilityChangedEvent = (function (_super) {
	    __extends(VisibilityChangedEvent, _super);
	    function VisibilityChangedEvent(isOpening) {
	        _super.call(this, 'visibility_change_qos');
	        this.action = isOpening ? 'open' : 'close';
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf VisibilityChangedEvent
	     */
	    VisibilityChangedEvent.prototype.getCustomProperties = function () {
	        var props = new Array();
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('action', this.action, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttsFromLastActivity', this.getTtsFromLastActivity() + '', piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('ttsFromSessionStart', this.getTtsFromSessionStart() + '', piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('actionsNumber', (VisibilityChangedEvent.actionsNumber++) + '', piiType_1.PIIType.NotSet));
	        VisibilityChangedEvent.lastChangeTime = Date.now();
	        return props;
	    };
	    VisibilityChangedEvent.prototype.getTtsFromLastActivity = function () {
	        if (!VisibilityChangedEvent.lastChangeTime) {
	            return 0;
	        }
	        return Date.now() - VisibilityChangedEvent.lastChangeTime;
	    };
	    VisibilityChangedEvent.prototype.getTtsFromSessionStart = function () {
	        if (!VisibilityChangedEvent.sessionStartTime) {
	            VisibilityChangedEvent.sessionStartTime = Date.now();
	        }
	        return Date.now() - VisibilityChangedEvent.sessionStartTime;
	    };
	    VisibilityChangedEvent.actionsNumber = 0;
	    VisibilityChangedEvent.sessionStartTime = Date.now();
	    return VisibilityChangedEvent;
	}(telemetryEvent_1.TelemetryEvent));
	exports.VisibilityChangedEvent = VisibilityChangedEvent;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// import ComponentsRegistrar from './componentsRegistrar';
	var viewModel_1 = __webpack_require__(175);
	var viewModel_2 = __webpack_require__(181);
	var viewModel_3 = __webpack_require__(182);
	var viewModel_4 = __webpack_require__(183);
	var SkypeComponentsRegistrar = (function () {
	    function SkypeComponentsRegistrar() {
	    }
	    SkypeComponentsRegistrar.register = function (chatDataConfig) {
	        // super.register(chatDataConfig, onclose);
	        if (this.isInitialized) {
	            return;
	        }
	        ko.components.register('messages-list', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new viewModel_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(184),
	            synchronous: true
	        });
	        ko.components.register('chat-input', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new viewModel_2.default(params, componentInfo.element, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(185),
	            synchronous: true
	        });
	        ko.components.register('conversation', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new viewModel_3.default(params, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(186),
	            synchronous: true
	        });
	        ko.components.register('lwc-signin', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new viewModel_4.default(params, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(187),
	            synchronous: true
	        });
	        this.isInitialized = true;
	    };
	    SkypeComponentsRegistrar.unregister = function () {
	        ko.components.unregister('messages-list');
	        ko.components.unregister('chat-input');
	        ko.components.unregister('conversation');
	        this.isInitialized = false;
	    };
	    SkypeComponentsRegistrar.isInitialized = false;
	    return SkypeComponentsRegistrar;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeComponentsRegistrar;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var app_1 = __webpack_require__(26);
	var Message_1 = __webpack_require__(176);
	var application_1 = __webpack_require__(47);
	var translatorService_1 = __webpack_require__(179);
	var messageUtils_1 = __webpack_require__(130);
	var api_1 = __webpack_require__(44);
	var scrollUtils_1 = __webpack_require__(180);
	var Direction_1 = __webpack_require__(121);
	var identityParser_1 = __webpack_require__(13);
	var CHAT_ENABLED_SUBSCRIPTION_CHANNEL = 'isChatEnabled';
	var SCROLL_END_BUFFER = 100;
	var TYPING_INDICATOR_TIMEOUT = 5000;
	var API_CLICK_ACTION = 'swc:action:click';
	var API_ELEMENT_SELECTOR = '.message';
	var MessagesList = (function () {
	    function MessagesList(_params, _element) {
	        var _this = this;
	        this._params = _params;
	        this._element = _element;
	        this.isWelMsgAdded = false;
	        this.messagesList = ko.observableArray();
	        this.showJumpArrow = ko.observable(false);
	        this.showSuggestedActions = ko.observable(false);
	        this.hasSuggestedActionOnLeft = ko.observable(true);
	        this.hasSuggestedActionOnRight = ko.observable(true);
	        this.clientHeight = ko.observable('100%');
	        this.isTyping = ko.observable();
	        this.typingMessage = ko.observable('');
	        this.languages = ko.observableArray();
	        this.translatorActive = ko.observable(false);
	        this._canMarkNewMessage = false;
	        this._fetchingInProgress = false;
	        this._isFirstLoad = true;
	        this._isScrollAnimating = false;
	        this.init = function () {
	            app_1.default.translatorEnabled && translatorService_1.default.getLanguages().then(function (languages) {
	                app_1.default.translationLanguages = languages.text;
	                // Object.keys(languages.text).map(function(key) {
	                //     return { id: key, name: this[key].name};
	                // }, languages.text);
	            });
	            // app.translationStatus.subscribe((value: number) => {
	            //     console.log(value);
	            //     this.translatorActive(value === 1);
	            // });
	            application_1.default.instance.Messaging.getMePerson().then(function (mePerson) {
	                _this.meUserName = mePerson.id;
	                _this._initConversationMessagesList();
	                // this._idSubscription = this._params.conversation.subscribe('id', this._onIdUpdate);
	                _this._addBotGreetingMessage();
	                _this._addWelcomeMessage();
	                _this._addContactRequestMessage();
	                _this._scrollToBottom();
	                _this._setMinHeight();
	                _this._element.addEventListener('scroll', _this._onScroll);
	            });
	        };
	        this.invokeSuggestedAction = function (action) {
	            if (action && typeof action.action === 'function') {
	                action.action();
	            }
	        };
	        this.suggestionChanged = function () {
	            var value;
	            if (_this._suggestionArea.scrollLeft === 0) {
	                value = false;
	            }
	            else {
	                value = true;
	            }
	            _this.hasSuggestedActionOnLeft(value);
	            if (_this._suggestionArea.scrollLeft === _this._suggestionArea.scrollWidth - _this._suggestionArea.clientWidth) {
	                value = false;
	            }
	            else {
	                value = true;
	            }
	            _this.hasSuggestedActionOnRight(value);
	        };
	        this.scrollSuggestionsToLeft = function () {
	            _this._scrollSuggestedArea(_this._suggestionArea.scrollLeft - _this._suggestionArea.clientWidth);
	        };
	        this.scrollSuggestionsToRight = function () {
	            _this._scrollSuggestedArea(_this._suggestionArea.scrollLeft + _this._suggestionArea.clientWidth);
	        };
	        this._scrollSuggestedArea = function (to) {
	            scrollUtils_1.scrollTo(to, 250, 'scrollLeft', _this._suggestionArea, function () { return _this.suggestionChanged(); });
	        };
	        this._onScroll = function () {
	            if (_this.messagesList().length && _this._element.scrollTop < 20 && !_this._fetchingInProgress) {
	                _this._fetchingInProgress = true;
	                _this.conversation.loadMoreMessages().then(function () { return _this._fetchingInProgress = false; });
	            }
	            if (_this._element.scrollTop < _this._element.scrollHeight - _this._element.clientHeight - 500 && !_this._isScrollAnimating) {
	                _this.showJumpArrow(true);
	            }
	            if (_this._element.scrollTop + 250 >= _this._element.scrollHeight - _this._element.clientHeight) {
	                _this.showJumpArrow(false);
	            }
	            _this._lastScrollHeight = _this._element.scrollHeight;
	        };
	        // visibility
	        /// new visible messages
	        this._visibleMessages = [];
	        // private markVisibleNodes(viewPortTimeout) {
	        //     clearTimeout(scrollingTimeout);
	        //     scrollingTimeout = setTimeout(processInvisibleMessages, viewPortTimeout);
	        // }
	        // visibility
	        this.jumpToBottom = function () { return _this._scrollToBottom(400); };
	        this.dispose = function () {
	            console.log('[messagesListVM] dispose');
	            if (_this.conversation && _this.conversation.messages) {
	                _this.conversation.messages.unsubscribe(_this._onNewMessages);
	                _this.conversation.messages.splice(0, _this.conversation.messages.length);
	            }
	            _this.messagesList().forEach(function (message) {
	                message.dispose();
	            });
	            // if (this._idSubscription) {
	            //     this._idSubscription.dispose();
	            // }
	            _this._element.removeEventListener('scroll', _this._onScroll);
	            _this.messagesList().splice(0, _this.messagesList().length);
	        };
	        this._initConversationMessagesList = function () {
	            // if (conversationId.indexOf('https') > -1) {
	            //     return;
	            // }
	            // this.conversation = Application.instance.Messaging.getOrCreateConversation(conversationId);
	            if (_this.conversation.messages.length > 0) {
	                _this._canMarkNewMessage = true;
	                if (!MessagesList.initTelemetrySent) {
	                    MessagesList.initTelemetrySent = true;
	                }
	                for (var key in _this.conversation.messages) {
	                    if (_this._checkUserMessageSent(_this.conversation.messages[key])) {
	                        break;
	                    }
	                    ;
	                }
	                (_a = _this.messagesList).push.apply(_a, _this.conversation.messages);
	                setTimeout(_this._scrollToBottom, 0);
	            }
	            _this.conversation.messages.subscribe(_this._onNewMessages.bind(_this));
	            _this.conversation.subscribe('isTyping', _this._onTypingIndicator.bind(_this));
	            _this.person = application_1.default.instance.StratusManager.getPerson(_this.conversation.id);
	            _this.typingMessage(_this.adjustBotName(_this.person.displayName));
	            _this.person.subscribe('displayName', function (value) {
	                _this.typingMessage(_this.adjustBotName(value));
	            });
	            var _a;
	            // this.showGreetingMessage()
	        };
	        this.addMessage = function (content) {
	            var botGreeting = new Message_1.default(false);
	            botGreeting.type = 'UserMessage';
	            botGreeting.direction = Direction_1.Direction.Incoming;
	            botGreeting.content = content;
	            botGreeting.status = -1;
	            this.conversation.messages.push(botGreeting);
	        };
	        // private _onIdUpdate = (newConversationId: string): void => {
	        //     if (this.conversation) {
	        //         if (this.conversation.messages) {
	        //             console.log('[messagesListVM] unsubscribing from conversation update');
	        //             this.conversation.messages.unsubscribe(this._onNewMessages);
	        //         }
	        //         this.messagesList([]);
	        //     }
	        //     this._initConversationMessagesList();
	        // }
	        this._checkUserMessageSent = function (item) {
	            if (_this._params.userMessageSent()) {
	                console.log('[messagesListVM] _checkUserMessageSent sent');
	                return true;
	            }
	            else {
	                console.log('[messagesListVM] _checkUserMessageSent who knows');
	                if (item.type === 'UserMessage' && item.direction === Direction_1.Direction.Outgoing) {
	                    _this._params.userMessageSent(true);
	                    _this._setMinHeight();
	                }
	                return false;
	            }
	        };
	        this._swcClickEventHandler = function (e) {
	            var payload = e.target.getAttribute('data-swc-payload');
	            payload && api_1.default.triggerEvent('click', payload) && e.preventDefault();
	        };
	        this.newMessageRendered = function (node) {
	            Object.keys(api_1.default.registry).length && messageUtils_1.default.attachActionToLinks(node, API_ELEMENT_SELECTOR, API_CLICK_ACTION, _this._swcClickEventHandler);
	        };
	        // todo: in the next step, we should replace viewmodel list with model to avoid duplicity and inconsistency
	        this._onNewMessages = function (messages, changes) {
	            if (!_this._canMarkNewMessage) {
	                _this._canMarkNewMessage = true;
	            }
	            if (!MessagesList.initTelemetrySent) {
	                MessagesList.initTelemetrySent = true;
	            }
	            // todo: we need to consolidate array and observable array implementation
	            // consider how to invoke update only when all messages in batch were sorted
	            var pivot = _this.messagesList()[0] ? _this.messagesList()[0].timestamp.getTime() : 0;
	            var recentMessages = [];
	            var historyMessages = [];
	            var tmp = document.createElement("div");
	            // we need to do this as the back link can return time inconsistent list
	            changes.newItems.forEach(function (item) {
	                _this._checkUserMessageSent(item);
	                if (item.isDeleted) {
	                    console.log('[messagesListVM] onNewMessages: not adding deleted message ' + item.key);
	                    return;
	                }
	                item.subscribe('isDeleted', _this.removeDeletedMessage.bind(_this, item));
	                (pivot > item.timestamp.getTime() ? historyMessages : recentMessages).push(item);
	            });
	            // we need to do this as the back link can return time inconsistent list
	            app_1.default.translatorEnabled && recentMessages.forEach(function (item) {
	                // if (app.translationStatus() === 0 && item.type === 'UserMessage' && (!!item.senderId && !PersonHelper.isMePerson(PersonHelper.normalizePersonId(item.senderId)))) {
	                //     translator.detect(item.content).then((language: string) => {
	                //         if ((<any>navigator).languages.indexOf(language) === -1) {
	                //             app.translationLanguage = language;
	                //             this._addTranslationMessage();
	                //             setTimeout(this._scrollToBottom, 0);
	                //         } else {
	                //             app.translationStatus(2);
	                //         }
	                //     });
	                // } else if (app.translationStatus() === 1  && item.type === 'UserMessage' && !!item.senderId && !PersonHelper.isMePerson(PersonHelper.normalizePersonId(item.senderId))) {
	                //     translator.translate(app.translationLanguage, navigator.language.split('-')[0], item.content).then((translation: string) => {
	                //         item.content = translation;
	                //         item.isTranslated = true;
	                //     });
	                // }
	            });
	            recentMessages.length && (_a = _this.messagesList).push.apply(_a, recentMessages);
	            historyMessages.length && (_b = _this.messagesList).unshift.apply(_b, historyMessages);
	            if (_this._isFirstLoad || recentMessages.length) {
	                _this._processSuggestedActions(messages);
	            }
	            if (_this._isFirstLoad) {
	                _this._isFirstLoad = false;
	                _this._scrollToBottom();
	                _this._lastScrollHeight = _this._element.scrollHeight;
	            }
	            else if (recentMessages.length) {
	                _this._scrollToBottom(360);
	            }
	            else {
	                _this._scrollToLast();
	            }
	            var _a, _b;
	        };
	        this._processSuggestedActions = function (messages) {
	            var lastMessage = messages[messages.length - 1];
	            if (lastMessage && lastMessage.type === 'SwiftCard' && lastMessage.suggestedActions.length) {
	                _this.suggestedActions(lastMessage.suggestedActions);
	                _this.showSuggestedActions(true);
	                _this.suggestionChanged();
	                setTimeout(function () { return _this._scrollToBottom(250); }, 250);
	            }
	            else {
	                _this.suggestedActions([]);
	                _this.showSuggestedActions(false);
	            }
	        };
	        this._scrollToBottom = function (duration) {
	            if (duration) {
	                _this.showJumpArrow(false);
	                _this._scrollMessageListTo(_this._element.scrollHeight, duration);
	            }
	            else {
	                _this._element.scrollTop = _this._element.scrollHeight;
	            }
	        };
	        this._scrollToLast = function () {
	            _this._element.scrollTop = _this._element.scrollHeight - _this._lastScrollHeight;
	        };
	        this._scrollMessageListTo = function (to, duration) {
	            _this._isScrollAnimating = true;
	            scrollUtils_1.scrollTo(to, duration, 'scrollTop', _this._element, function () { return _this._isScrollAnimating = false; });
	        };
	        this.conversation = _params.conversation;
	        this._params.enable() ? this.init() : this._params.enable.subscribe(function (on) { return on && _this.init(); });
	        this.suggestedActions = ko.observableArray([]);
	        this.isDirectLine = this.conversation.isDirectLineBackend();
	        this._suggestionArea = document.getElementById('suggestionArea');
	        window.addEventListener('resize', function () {
	            console.log('reszie');
	            _this.suggestionChanged();
	        });
	    }
	    MessagesList.prototype._cancelEvent = function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        e.returnValue = false;
	    };
	    MessagesList.prototype._setMinHeight = function () {
	        this.clientHeight(this._element.clientHeight ? this._element.clientHeight + 'px' : '100%');
	    };
	    MessagesList.prototype.getVisibleSeed = function (element, parent, viewport) {
	        if (!element || !viewport || !parent) {
	            return null;
	        }
	        else if (parent.children.length < 2) {
	            return element; // mark it and don't pass thru seeding
	        }
	        var viewportRect = viewport.getBoundingClientRect();
	        var children = parent.children;
	        var elementRect = null;
	        var iMin = 0;
	        var iMax = children.length - 1;
	        var index;
	        var previousIndex;
	        while (element) {
	            elementRect = element.getBoundingClientRect();
	            if (elementRect.top > viewportRect.bottom) {
	                iMax = Array.prototype.indexOf.call(children, element); // shortcut children array
	            }
	            else if (elementRect.bottom < viewportRect.top) {
	                iMin = Array.prototype.indexOf.call(children, element); // shortcut children array
	            }
	            else {
	                return element; // is in viewport
	            }
	            index = this._getMiddle(iMin, iMax);
	            if (previousIndex === index) {
	                break;
	            }
	            previousIndex = index;
	            element = children[index];
	        }
	        return null;
	    };
	    MessagesList.prototype._getMiddle = function (min, max) {
	        return min + ((max - min) >> 1); // we only need integer division by 2
	    };
	    MessagesList.prototype._isInView = function (element, vRect) {
	        var elemRect = element.getBoundingClientRect(), heightVariation = elemRect.height / 2;
	        return (elemRect.top + heightVariation <= vRect.bottom && elemRect.bottom - heightVariation >= vRect.top);
	    };
	    MessagesList.prototype._seeding = function (element, parent, viewport) {
	        var _this = this;
	        var viewportRect = viewport.getBoundingClientRect();
	        var arr = [];
	        arr.push(element);
	        var movedOutOfView = function (currentNode) {
	            if (currentNode && currentNode.nodeType === 1) {
	                if (_this._isInView(currentNode, viewportRect)) {
	                    arr.push(currentNode);
	                    return false;
	                }
	                else {
	                    return true;
	                }
	            }
	            return false;
	        };
	        var node = element.nextSibling;
	        while (node) {
	            if (movedOutOfView(node)) {
	                break;
	            }
	            node = node.nextSibling;
	        }
	        node = element.previousSibling;
	        while (node) {
	            if (movedOutOfView(node)) {
	                break;
	            }
	            node = node.previousSibling;
	        }
	        return arr;
	    };
	    MessagesList.prototype.processInvisibleMessages = function (container, viewport) {
	        var oldVisibleMessages = this._visibleMessages.slice();
	        var elem = this.getVisibleSeed(container.lastElementChild, container, viewport); // we should use last visible element as a seed
	        if (elem) {
	            this._visibleMessages = this._seeding(elem, container, viewport);
	        }
	        for (var i = 0; i < oldVisibleMessages.length; i++) {
	            if (this._visibleMessages.indexOf(oldVisibleMessages[i]) < 0) {
	                oldVisibleMessages[i].style.background = 'red';
	            }
	        }
	        this._visibleMessages.forEach(function (message) {
	            message.style.background = 'blue';
	        });
	        //eventListener.onMessageVisibilityChange(visibleMessages);
	    };
	    MessagesList.prototype.adjustBotName = function (name) {
	        if (this.conversation.definition.Title) {
	            return this.conversation.definition.Title;
	        }
	        if (!name || name === identityParser_1.default.getNormalizeId(this.conversation.id)) {
	            return this.conversation.isAgent() ? 'Bot' : 'Person';
	        }
	        return name;
	    };
	    MessagesList.prototype._addWelcomeMessage = function () {
	        var welcomeMessage = new Message_1.default(false);
	        welcomeMessage.type = 'Welcome';
	        this.messagesList.push(welcomeMessage);
	    };
	    MessagesList.prototype._addTranslationMessage = function () {
	        var translateMessage = new Message_1.default(false);
	        translateMessage.type = 'Translate';
	        this.messagesList.push(translateMessage);
	    };
	    MessagesList.prototype._addContactRequestMessage = function () {
	        var contactRequestMessage = new Message_1.default(false);
	        contactRequestMessage.type = 'ContactRequest';
	        this.messagesList.push(contactRequestMessage);
	    };
	    MessagesList.prototype._addBotGreetingMessage = function () {
	        var _this = this;
	        if (!this.conversation.isAgent()) {
	            return;
	        }
	        if (this.conversation.isNew === undefined) {
	            this.conversation.subscribe('isNew', function (value) {
	                _this._addBotGreetingMessage();
	            });
	            return;
	        }
	        if (!!!this.conversation.isNew) {
	            return;
	        }
	        if (!this.person) {
	            return;
	        }
	        if (this.person.description) {
	            this.addMessage(this.person.description);
	        }
	        this.person.subscribe('description', function (value) {
	            _this.addMessage(value);
	        });
	    };
	    MessagesList.prototype.removeDeletedMessage = function (message, isDeleted) {
	        console.log('[messagesListVM] removeDeletedMessages : ' + message.key);
	        this.messagesList.remove(message);
	        message.dispose();
	        message = null;
	    };
	    MessagesList.prototype._onTypingIndicator = function (value) {
	        this.isTyping(value);
	        if (this._typingIndicatorTimoutId) {
	            clearTimeout(this._typingIndicatorTimoutId);
	        }
	        if (value) {
	            var self_1 = this;
	            this._typingIndicatorTimoutId = setTimeout(function () {
	                self_1.isTyping(false);
	                self_1._typingIndicatorTimoutId = undefined;
	            }, TYPING_INDICATOR_TIMEOUT);
	        }
	    };
	    MessagesList.initTelemetrySent = false;
	    return MessagesList;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessagesList;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ObservableBase_1 = __webpack_require__(76);
	var ObservableCollection_1 = __webpack_require__(177);
	var DeliveryStatus_1 = __webpack_require__(178);
	var Message = (function (_super) {
	    __extends(Message, _super);
	    function Message(isSystemMessage, payload) {
	        _super.call(this);
	        this.type = 'UserMessage';
	        this.timestamp = new Date();
	        this._payload = payload;
	        this._status = DeliveryStatus_1.DeliveryStatus.Pending;
	        this.suggestedActions = new ObservableCollection_1.ObservableCollection();
	        if (isSystemMessage) {
	            this.type = 'SystemMessage';
	        }
	    }
	    Object.defineProperty(Message.prototype, "id", {
	        get: function () {
	            return this._id;
	        },
	        set: function (value) {
	            if (value !== this._id) {
	                this._id = value;
	                this.publish('id', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "key", {
	        get: function () {
	            return this._key;
	        },
	        set: function (value) {
	            if (value !== this._key) {
	                this._key = value;
	                this.publish('key', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "content", {
	        get: function () {
	            return this._content;
	        },
	        set: function (value) {
	            if (value !== this._content) {
	                this._content = value;
	                this.publish('content', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "imageContent", {
	        get: function () {
	            return this._imageContent;
	        },
	        set: function (value) {
	            if (value !== this._imageContent) {
	                this._imageContent = value;
	                this.publish('imageContent', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "translation", {
	        get: function () {
	            return this._content;
	        },
	        set: function (value) {
	            if (value !== this._translation) {
	                this._translation = value;
	                this.publish('translation', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "timestamp", {
	        get: function () {
	            return this._timestamp;
	        },
	        set: function (value) {
	            if (value !== this._timestamp) {
	                this._timestamp = value;
	                this.publish('timestamp', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "senderId", {
	        get: function () {
	            return this._senderId;
	        },
	        set: function (value) {
	            if (value !== this._senderId) {
	                this._senderId = value;
	                this.publish('senderId', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "sender", {
	        get: function () {
	            return this._sender;
	        },
	        set: function (value) {
	            if (value !== this._sender) {
	                this._sender = value;
	                this.publish('sender', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "direction", {
	        get: function () {
	            return this._direction;
	        },
	        set: function (value) {
	            if (value !== this._direction) {
	                this._direction = value;
	                this.publish('direction', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "status", {
	        get: function () {
	            return this._status;
	        },
	        set: function (value) {
	            if (value !== this._status) {
	                this._status = value;
	                this.publish('status', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "skypeEditedId", {
	        get: function () {
	            return this._skypeEditedId;
	        },
	        set: function (value) {
	            if (value !== this._skypeEditedId) {
	                this._skypeEditedId = value;
	                this.publish('skypeEditedId', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "composeTime", {
	        get: function () {
	            return this._composeTime;
	        },
	        set: function (value) {
	            if (value !== this._composeTime) {
	                this._composeTime = value;
	                this.publish('composeTime', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "isDeleted", {
	        get: function () {
	            return !this._content && !!this._skypeEditedId;
	        },
	        set: function (value) {
	            if (value !== this._isDeleted) {
	                this._isDeleted = value;
	                this.publish('isDeleted', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "isTranslated", {
	        get: function () {
	            return this._isTranslated;
	        },
	        set: function (value) {
	            if (value !== this._isTranslated) {
	                this._isTranslated = value;
	                this.publish('isTranslated', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "payload", {
	        get: function () {
	            return this._payload;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Message;
	}(ObservableBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Message;


/***/ },
/* 177 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ObservableCollection = (function (_super) {
	    __extends(ObservableCollection, _super);
	    function ObservableCollection() {
	        var _this = this;
	        _super.apply(this, arguments);
	        this.callbacks = new Array();
	        this.publish = function (args) {
	            if (!args) {
	                args = new CollectionChangedEventArgs();
	                args.newItems = new Array();
	            }
	            _this.callbacks.forEach(function (callback) {
	                callback(_this, args);
	            });
	        };
	    }
	    ObservableCollection.prototype.push = function () {
	        var items = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            items[_i - 0] = arguments[_i];
	        }
	        _super.prototype.push.apply(this, items);
	        var args = new CollectionChangedEventArgs();
	        args.newItems = items;
	        this.publish(args);
	        return _super.prototype.length;
	    };
	    ObservableCollection.prototype.pop = function () {
	        var item = _super.prototype.pop.call(this);
	        this.publish();
	        return item;
	    };
	    ObservableCollection.prototype.shift = function () {
	        var result = _super.prototype.shift.call(this);
	        this.publish();
	        return result;
	    };
	    ObservableCollection.prototype.unshift = function () {
	        var items = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            items[_i - 0] = arguments[_i];
	        }
	        _super.prototype.unshift.apply(this, items);
	        var args = new CollectionChangedEventArgs();
	        args.newItems = items;
	        this.publish(args);
	        return _super.prototype.length;
	    };
	    /**
	      * Sorts an array.
	      * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.
	      */
	    ObservableCollection.prototype.sort = function (compareFn) {
	        var result = _super.prototype.sort.call(this, compareFn);
	        this.publish();
	        return result;
	    };
	    ObservableCollection.prototype.splice = function (start, deleteCount) {
	        var items = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            items[_i - 2] = arguments[_i];
	        }
	        var result;
	        if (deleteCount) {
	            if (items) {
	                result = _super.prototype.splice.apply(this, [start, deleteCount].concat(items));
	            }
	            else {
	                result = _super.prototype.splice.call(this, start, deleteCount);
	            }
	        }
	        else {
	            result = _super.prototype.splice.call(this, start);
	        }
	        this.publish();
	        return result;
	    };
	    ObservableCollection.prototype.subscribe = function (callback) {
	        this.callbacks.push(callback);
	    };
	    ObservableCollection.prototype.unsubscribe = function (callback) {
	        var callbackIndex = this.callbacks.indexOf(callback);
	        if (callbackIndex > -1) {
	            this.callbacks.splice(callbackIndex, 1);
	        }
	    };
	    ObservableCollection.prototype.dispose = function () {
	        var _this = this;
	        this.callbacks.forEach(function (callback, index) {
	            _this.callbacks[index] = null;
	        });
	        this.callbacks = [];
	    };
	    return ObservableCollection;
	}(Array));
	exports.ObservableCollection = ObservableCollection;
	var CollectionChangedEventArgs = (function () {
	    function CollectionChangedEventArgs() {
	    }
	    Object.defineProperty(CollectionChangedEventArgs.prototype, "newItems", {
	        get: function () {
	            return this._newItems;
	        },
	        set: function (newValue) {
	            this._newItems = newValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CollectionChangedEventArgs;
	}());
	exports.CollectionChangedEventArgs = CollectionChangedEventArgs;


/***/ },
/* 178 */
/***/ function(module, exports) {

	"use strict";
	(function (DeliveryStatus) {
	    DeliveryStatus[DeliveryStatus["Pending"] = 0] = "Pending";
	    DeliveryStatus[DeliveryStatus["Sent"] = 1] = "Sent";
	    DeliveryStatus[DeliveryStatus["Failed"] = 2] = "Failed";
	})(exports.DeliveryStatus || (exports.DeliveryStatus = {}));
	var DeliveryStatus = exports.DeliveryStatus;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(fetch) {"use strict";
	var application_1 = __webpack_require__(47);
	var TRANSLATE = 'https://dev.microsofttranslator.com/api/skype/translate';
	var LANGUAGES = 'https://dev.microsofttranslator.com/api/languages';
	var DETECT = 'https://f3cc4fc2.ngrok.io/detect';
	var translatorClientAppId = 'FF63883DDDED40068EC45030A601460C';
	var TranslatorService = (function () {
	    function TranslatorService() {
	    }
	    TranslatorService.translate = function (from, to, text) {
	        var uri = TRANSLATE + "?from=" + from + "&to=" + to + "&text=" + text;
	        return this._requestWithToken(uri);
	    };
	    TranslatorService.detect = function (text) {
	        var uri = DETECT + "?text=" + text;
	        return new Promise(function (resolve, reject) {
	            var postParams = {
	                method: 'GET'
	            };
	            return fetch(encodeURI(uri), postParams).then(function (response) {
	                response.json().then(function (value) {
	                    var language = value.string.$t.split('-')[0];
	                    resolve(language);
	                }).catch(function (error) {
	                    reject(error);
	                });
	            }, function (error) {
	                reject(error);
	            });
	        });
	    };
	    TranslatorService.getLanguages = function () {
	        var uri = LANGUAGES;
	        return this._requestWithToken(uri);
	    };
	    TranslatorService._requestWithToken = function (uri) {
	        var headers = new Headers();
	        var postParams = {};
	        return new Promise(function (resolve, reject) {
	            application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	                headers.append('Content-Type', 'application/x-www-form-urlencoded');
	                headers.append('X-Skypetoken', token);
	                headers.append('X-ScenarioId', translatorClientAppId);
	                postParams.method = 'GET';
	                postParams.headers = headers;
	                return fetch(encodeURI(uri), postParams).then(function (response) {
	                    response.json().then(function (value) {
	                        resolve(value);
	                    }).catch(function (error) {
	                        reject(error);
	                    });
	                }, function (error) {
	                    reject(error);
	                });
	            });
	        });
	    };
	    return TranslatorService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TranslatorService;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ },
/* 180 */
/***/ function(module, exports) {

	"use strict";
	exports.scrollTo = function (to, duration, direction, element, callback) {
	    var value = direction === 'scrollLeft' ? element.scrollLeft : element.scrollTop;
	    var difference = to - value;
	    var perTick = difference / duration * 10;
	    setTimeout(function () {
	        var newValue = value + perTick;
	        if (direction === 'scrollLeft') {
	            element.scrollLeft = newValue;
	        }
	        else {
	            element.scrollTop = newValue;
	        }
	        duration = duration - 10;
	        if (newValue === to || duration <= 0) {
	            if (callback) {
	                callback();
	            }
	            return;
	        }
	        exports.scrollTo(to, duration, direction, element, callback);
	    }, 10);
	};


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Message_1 = __webpack_require__(176);
	var Direction_1 = __webpack_require__(121);
	var i18n_1 = __webpack_require__(112);
	var application_1 = __webpack_require__(47);
	// import SuggestionList from './suggestionList/suggestionList';
	var actionTrigger_1 = __webpack_require__(154);
	var config_1 = __webpack_require__(27);
	var debounce = __webpack_require__(140);
	var CHAT_ENABLED_SUBSCRIPTION = 'isChatEnabled';
	var TYPING_INDICATOR_INTERVAL = 1000;
	var ChatInput = (function () {
	    function ChatInput(_params, element, chatConfig) {
	        var _this = this;
	        this._params = _params;
	        this.element = element;
	        this.chatConfig = chatConfig;
	        this.inputHasValue = ko.observable(false);
	        this.placeholder = i18n_1.default.fetch('area_text_insertText');
	        this.isFileTransferEnabled = ko.observable(false);
	        this.maxLength = config_1.default.MSG_MAX_LENGTH;
	        this.init = function () {
	            if (_this._params.conversation.id.indexOf('https') === -1) {
	                // this.conversation = Application.instance.Messaging.getOrCreateConversation(this._params.id());
	                _this._textarea.addEventListener('input', function (event) {
	                    _this.inputHasValue(_this._textarea.value.trim().length > 0);
	                });
	            }
	            // this._idSubscription = this._params.id.subscribe(this._onIdUpdate);
	            // this.suggestionList = new SuggestionList();
	            _this.sendButtonColor = ko.computed(_this.onSendButtonColor);
	            _this.isFileTransferEnabled = ko.computed(_this.onFileTransferEnabled);
	            _this.isSendMessageEnabled = ko.computed(_this.onSendMessageEnabled);
	        };
	        this.onSendButtonColor = function () {
	            return _this.chatConfig.ColorMessage == null ? '#00AFF0' : 'grey';
	        };
	        this.onFileTransferEnabled = function () {
	            return _this.chatConfig.CanUploadFile;
	        };
	        this.onSendMessageEnabled = function () {
	            return _this.inputHasValue();
	        };
	        this.dispose = function () {
	            // if(this._idSubscription) {
	            //     this._idSubscription.dispose();
	            // }
	            // if (this.conversation) {
	            //     this.conversation.unsubscribe(CHAT_ENABLED_SUBSCRIPTION, this.isChatEnabled);
	            // }
	        };
	        this.conversation = _params.conversation;
	        this._textarea = element.querySelector('textarea');
	        this._fileSelector = element.querySelector('#myFiles');
	        this.isChatEnabled = ko.observable(true);
	        this.sendButtonColor = ko.computed(this.onSendButtonColor);
	        // this._idSubscription = this._params.id.subscribe(this._onIdUpdate);
	        this._params.enable() ? this.init() : this._params.enable.subscribe(function (on) { return on && _this.init(); });
	        this._typingIndicator = debounce(function () {
	            _this.conversation.isTyping = _this._textarea.value.length > 0;
	        }, TYPING_INDICATOR_INTERVAL);
	    }
	    ChatInput.prototype.sendMessage = function (actionTrigger) {
	        if (this._textarea.value.length > config_1.default.MSG_MAX_LENGTH) {
	            return;
	        }
	        if (!this._textarea.value.trim()) {
	            return;
	        }
	        var searchCmd = 'skypesearch:';
	        if (this._textarea.value.toLowerCase().indexOf(searchCmd) === 0) {
	            this.search(this._textarea.value.substr(searchCmd.length).trim());
	            return;
	        }
	        actionTrigger = actionTrigger === actionTrigger_1.ActionTrigger.UNDEFINED ? actionTrigger_1.ActionTrigger.BUTTON_SEND_CLICK : actionTrigger;
	        this.conversation.sendMessage(this._textarea.value, actionTrigger);
	        this._textarea.value = '';
	        this.inputHasValue(false);
	    };
	    ChatInput.prototype.search = function (searchkey) {
	        var _this = this;
	        console.log(searchkey);
	        application_1.default.instance.SearchManager.searchSkypeContacts(searchkey).then(function (profiles) {
	            profiles.forEach(function (item) {
	                var msg = new Message_1.default(false);
	                msg.content = item.name;
	                msg.direction = Direction_1.Direction.Incoming;
	                msg.status = -1;
	                _this.conversation.messages.push(msg);
	            });
	        });
	        this._textarea.value = '';
	        this.inputHasValue(false);
	    };
	    ChatInput.prototype.sendButtonHandler = function () {
	        this.sendMessage(actionTrigger_1.ActionTrigger.BUTTON_SEND_CLICK);
	    };
	    ChatInput.prototype.selectFile = function () {
	        this.openFileSelector('');
	    };
	    ChatInput.prototype.selectImage = function () {
	        this.openFileSelector('.gif,.jpg,.jpeg,.png');
	    };
	    ChatInput.prototype.openFileSelector = function (accept) {
	        if (!this._fileSelector) {
	            return;
	        }
	        this._fileSelector.value = '';
	        this._fileSelector.accept = accept;
	        this._fileSelector.click();
	    };
	    ChatInput.prototype.sendFile = function () {
	        if (!this._fileSelector || this._fileSelector.files.length === 0) {
	            return;
	        }
	        for (var index = 0; index < this._fileSelector.files.length; index++) {
	            var data = this._fileSelector.files[index];
	            application_1.default.instance.AmsManager.sendFile(this.conversation, data);
	        }
	        this._textarea.focus();
	    };
	    ChatInput.prototype.onKeyDown = function (self, event) {
	        this._typingIndicator();
	        var code = event.keyCode || event.which;
	        // if (!this.suggestionList.handleKeyDown(self.suggestionList, event, code)) {
	        //     return false;
	        // }
	        if (code !== 13) {
	            return true;
	        }
	        if (event.shiftKey) {
	            return true;
	        }
	        event.preventDefault();
	        this.sendMessage(actionTrigger_1.ActionTrigger.KEYPRESS_ENTER);
	        //handleInput not triggered because of preventDefault()
	        // this.suggestionList.handleInput(self._textarea, self._conversation);
	        return false;
	    };
	    ChatInput.prototype.handleInput = function (self, event) {
	        // this.suggestionList.handleInput(self._textarea, self._conversation);
	    };
	    return ChatInput;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ChatInput;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var config_1 = __webpack_require__(27);
	var app_1 = __webpack_require__(26);
	var api_1 = __webpack_require__(44);
	var actionNames_1 = __webpack_require__(35);
	var signinState_1 = __webpack_require__(71);
	var sdkMode_1 = __webpack_require__(30);
	var identityType_1 = __webpack_require__(29);
	var i18n_1 = __webpack_require__(112);
	var visibilityChangedEvent_1 = __webpack_require__(173);
	var endpoint = __webpack_require__(86);
	var Conversation = (function () {
	    function Conversation(_params, chatDataConfig) {
	        var _this = this;
	        this._params = _params;
	        this.chatDataConfig = chatDataConfig;
	        // public conversationId = ko.observable<string>();
	        this.showComponent = ko.observable(false);
	        this.isCollapsed = ko.observable(false);
	        this.title = ko.observable();
	        this.isPopUp = !!window.opener;
	        this.avatarUrl = ko.observable();
	        this.isAgent = ko.observable(false);
	        this.signedIn = ko.observable(true);
	        this.showLoginPage = ko.observable(false);
	        this.privacyStatement = ko.observable();
	        this.termOfUse = ko.observable();
	        this.showTermsOfUse = ko.observable();
	        this.showPrivacyStatement = ko.observable();
	        this.showPrivacyAgreement = ko.observable();
	        this.userMessageSent = ko.observable(false);
	        this.isGuest = ko.observable(true);
	        this.privacyStatementText = i18n_1.default.fetch('header_privacyPolicy');
	        this.termOfUseText = i18n_1.default.fetch('header_termsOfUse');
	        this.MSServiceAndPrivacyAgreement = i18n_1.default.fetch('ms_service_privacy_agreement', {
	            linkMSA: 'https://www.microsoft.com/en-us/servicesagreement/',
	            linkPrivacy: 'https://privacy.microsoft.com/en-us/privacystatement'
	        });
	        this._postbox = new ko.subscribable();
	        this.init = function () {
	            var onAppStateChanged = function () {
	                console.log('[conversationVM] state changed to ', application_1.default.instance.SignInManager.state);
	                _this.isGuest(app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST);
	                // TODO: remove this mistery condition which shows messages on screen
	                _this.updateSignedInState();
	            };
	            application_1.default.instance.SignInManager.subscribe('state', onAppStateChanged);
	            api_1.default.registerEvent('forceExpandChat', function () {
	                _this.isCollapsed(false);
	                if (_this.conversation.sdkMode !== sdkMode_1.SDKMode.DIRECT_LINE_TOKEN) {
	                    endpoint.startActivation();
	                }
	            });
	            onAppStateChanged();
	            // this.conversationId = this._params.conversation.id;
	            // if (this._isJoinLink(this.conversationId())) {
	            //     if (this.signedIn()) {
	            //         this._joinToGroupConversation(true);
	            //     }
	            //     return;
	            // }
	            _this._initConversation();
	        };
	        this.signIn = function () {
	            var loginMethod = application_1.default.instance.SignInManager.login;
	            // if (this._isJoinLink(this.conversationId())) {
	            //     loginMethod = Application.instance.SignInManager.joinFlow.bind(this, decodeURIComponent(this.conversationId()));
	            // }
	            loginMethod(function (skypeToken) {
	                if (!!skypeToken) {
	                    // if (this._isJoinLink(this.conversationId())) {
	                    //     this._joinToGroupConversation(false);
	                    // } else {
	                    //     this.signedIn(true);
	                    // }
	                    _this.signedIn(true);
	                }
	            });
	        };
	        // public tabClickHandler = (tabData: ITabData) => {
	        //     this._params.conversation.id = tabData.id; // TODO: figure out better way than updating params !!!!
	        // };
	        this.dispose = function () {
	            if (_this._idSubscription) {
	                _this._idSubscription.dispose();
	            }
	            // this._signInSubscription.dispose();
	        };
	        this._isJoinLink = function (id) {
	            return id.indexOf('https') > -1;
	        };
	        this._initConversation = function () {
	            if (!_this._isJoinLink(_this.conversation.id)) {
	                _this._changeConversation(_this.conversation);
	            }
	            // this._idSubscription = this._params.id.subscribe(this._onIdUpdate);
	        };
	        this.conversation = this._params.conversation;
	        this.enable = this._params.enable;
	        this._params.enable() ? this.init() : this._params.enable.subscribe(function (on) { return on && _this.init(); });
	    }
	    Conversation.prototype.updateSignedInState = function () {
	        if (this.conversation.sdkMode === sdkMode_1.SDKMode.BOT) {
	            this.showLoginPage(false);
	            this.showComponent(true);
	            this.signedIn(application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedOut);
	        }
	        else {
	            this.showLoginPage(application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn || this.isGuest());
	            var canChatWithUser = !this.isGuest() && this.conversation.isConversationWithPerson();
	            this.signedIn(application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedOut && canChatWithUser);
	            this.showComponent(false);
	        }
	    };
	    Conversation.prototype.close = function () {
	        if (app_1.default.frameless) {
	            window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }); /// consider reference to namespace
	        }
	        else if (parent) {
	            parent.postMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }, document.referrer || '*');
	        }
	        var evtData = new visibilityChangedEvent_1.VisibilityChangedEvent(false);
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	        endpoint.stopActivation();
	    };
	    Conversation.prototype.toggleChatSize = function () {
	        this.isCollapsed(!this.isCollapsed());
	        var action = this.isCollapsed() ? actionNames_1.default.CollapseChatWindow : actionNames_1.default.ExpandChatWindow;
	        if (app_1.default.frameless) {
	            window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: action }); /// consider reference to namespace
	        }
	        else if (parent) {
	            parent.postMessage({ origin: config_1.default.ORIGIN, action: action }, document.referrer || '*');
	        }
	        // todo: telemetry
	        if (this.isCollapsed()) {
	            endpoint.stopActivation();
	        }
	        else if (this.conversation.sdkMode !== sdkMode_1.SDKMode.DIRECT_LINE_TOKEN) {
	            endpoint.startActivation();
	        }
	    };
	    // private _joinToGroupConversation = (joinFirst: boolean): void => {
	    //     let self = this;
	    //     let parser = document.createElement('a');
	    //     parser.href = decodeURIComponent(this.conversationId());
	    //     let shortId = parser.pathname.substr(1);
	    //     if (!shortId.length) {
	    //         return;
	    //     }
	    //     require.ensure([], (require) => {
	    //         let joinConversation = (require('../../services/chat/joining') as any).joinConversation;
	    //         fetch(config.CHAT_JOIN_URL, {
	    //             method: 'POST',
	    //             headers: {
	    //                 'Content-Type': 'application/json'
	    //             },
	    //             body: JSON.stringify({ shortId: shortId, type: 'wl' })
	    //         }).then(response => {
	    //             response.json().then(json => {
	    //                 if (joinFirst) {
	    //                     joinConversation(json.Resource).then(() => {
	    //                         self._initConversation();
	    //                         let postData = {
	    //                             origin: config.ORIGIN,
	    //                             action: ActionNames.OpenWebGroupConversation,
	    //                             groupId: json.Resource.substr(3)
	    //                         };
	    //                         parent.postMessage(postData, '*');
	    //                     });
	    //                 } else {
	    //                     self._initConversation();
	    //                     let postData = {
	    //                         origin: config.ORIGIN,
	    //                         action: ActionNames.OpenWebGroupConversation,
	    //                         groupId: json.Resource.substr(3)
	    //                     };
	    //                     parent.postMessage(postData, '*');
	    //                 }
	    //             });
	    //         });
	    //     }, 'button-join');
	    // }
	    Conversation.prototype._subscribeToDisplayName = function (person) {
	        var _this = this;
	        person.displayName && this._handleDisplayName(person);
	        person.subscribe('displayName', function () { return _this._handleDisplayName(person); });
	    };
	    Conversation.prototype._handleDisplayName = function (person) {
	        this.title(person.displayName === person.id ? '' : person.displayName);
	        this.conversation.topic = person.displayName;
	    };
	    Conversation.prototype.subsribeToAvatarUrl = function (person, conversationId) {
	        var _this = this;
	        var subscribeAvatarData = function () {
	            person.subscribe('avatarData', function (url) {
	                if (conversationId !== _this.conversation.id) {
	                    return;
	                }
	                _this.avatarUrl(url);
	            });
	        };
	        application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                subscribeAvatarData();
	            }
	        }).catch(function (error) {
	            if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                subscribeAvatarData();
	            }
	            else {
	                application_1.default.instance.SignInManager.subscribe('state', function () {
	                    if (application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn) {
	                        return;
	                    }
	                    subscribeAvatarData();
	                    application_1.default.instance.StratusManager.getPerson(_this.conversation.id, true);
	                });
	            }
	        });
	    };
	    Conversation.prototype._changeConversation = function (conversation) {
	        var _this = this;
	        this.isGuest(app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST || application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn);
	        this.conversation = conversation; //Application.instance.Messaging.getOrCreateConversation(newConversationId);
	        if (this.conversation.sdkMode === sdkMode_1.SDKMode.BOT) {
	            this.showLoginPage(false);
	        }
	        else {
	            //this.showLoginPage(Application.instance.SignInManager.state !== SigninState.SignedIn || this.isGuest());
	            this.updateSignedInState();
	        }
	        this.isAgent(this.conversation.isAgent());
	        if (!this.conversation.topic && !this.conversation.isGroup()) {
	            var person_1 = application_1.default.instance.StratusManager.getPerson(this.conversation.id);
	            if (person_1.displayName === person_1.id) {
	                application_1.default.instance.SignInManager.getSkypeToken()
	                    .then(function (token) {
	                    if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                        _this._subscribeToDisplayName(person_1);
	                    }
	                }).catch(function (error) {
	                    if (application_1.default.instance.SignInManager.state === signinState_1.SigninState.SignedIn) {
	                        _this._subscribeToDisplayName(person_1);
	                    }
	                    else {
	                        application_1.default.instance.SignInManager.subscribe('state', function () {
	                            if (application_1.default.instance.SignInManager.state !== signinState_1.SigninState.SignedIn) {
	                                return;
	                            }
	                            _this._subscribeToDisplayName(person_1);
	                            person_1.fetchDisplayName();
	                        });
	                    }
	                });
	            }
	        }
	        else {
	            var title = this.conversation.topic;
	            this.title(title);
	        }
	        if (this.chatDataConfig.Avatar) {
	            this.avatarUrl(this.chatDataConfig.Avatar);
	        }
	        else if (this.conversation.avatar) {
	            this.avatarUrl(this.conversation.avatar);
	        }
	        else {
	            if (this.conversation.isGroup()) {
	                this.conversation.subscribe('avatar', this.avatarUrl);
	            }
	            else {
	                var person = application_1.default.instance.StratusManager.getPerson(this.conversation.id, true);
	                if (person.avatarData) {
	                    this.avatarUrl(person.avatarData);
	                }
	                else {
	                    var conversationId = this.conversation.id;
	                    this.subsribeToAvatarUrl(person, conversationId);
	                }
	            }
	        }
	        console.log('application: ', app_1.default);
	        if (this.conversation.sdkMode === sdkMode_1.SDKMode.BOT) {
	            var person = application_1.default.instance.StratusManager.getPerson(this.conversation.id);
	            application_1.default.instance.AgentsManager.getAgent(person.id).then(function (agent) {
	                if (agent && agent.agentDescriptions && agent.agentDescriptions.length === 1) {
	                    var agentDesc = agent.agentDescriptions[0];
	                    var privacyStatement = _this.conversation.definition.PrivacyUri || agentDesc.privacyStatement;
	                    var touUri = _this.conversation.definition.TermsOfUseUri || agentDesc.tos;
	                    _this.privacyStatement(privacyStatement);
	                    _this.termOfUse(touUri);
	                    _this.showPrivacyStatement(agentDesc.privacyStatement && agentDesc.privacyStatement.length > 0);
	                    _this.showTermsOfUse(agentDesc.tos && agentDesc.tos.length > 0);
	                }
	            });
	        }
	    };
	    return Conversation;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Conversation;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var actionNames_1 = __webpack_require__(35);
	var config_1 = __webpack_require__(27);
	var visibilityChangedEvent_1 = __webpack_require__(173);
	var app_1 = __webpack_require__(26);
	var identityType_1 = __webpack_require__(29);
	var SigninVM = (function () {
	    function SigninVM(params, chatConfig) {
	        var _this = this;
	        this.chatConfig = chatConfig;
	        this.signinEnabled = ko.observable(false);
	        this.signIn = function () {
	            if (!_this.signinEnabled()) {
	                // TODO: do this on UI level or add styles
	                return;
	            }
	            // let loginMethod = Application.instance.SignInManager.login;
	            // if (this._isJoinLink(this.conversationId())) {
	            //     loginMethod = Application.instance.SignInManager.joinFlow.bind(this, decodeURIComponent(this.conversationId()));
	            // }
	            application_1.default.instance.SignInManager.login(function (skypeToken) {
	                _this.isSignedIn(!!skypeToken);
	                // if (!!skypeToken) {
	                //     this.isSignedIn(true);
	                // } else{
	                //     this.isSignedIn(false);
	                // }
	            });
	        };
	        this._isJoinLink = function (id) {
	            return id.indexOf('https') > -1;
	        };
	        this.isSignedIn = params.isSignedIn;
	        this.isGuestOnlyMode = app_1.default.isGuestOnlyMode;
	        this.conversation = params.conversation;
	        this.conversationId = ko.observable(this.conversation.id);
	        this.signinEnabled(application_1.default.instance.isCleared || (this.conversation.isConversationWithPerson() && app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST));
	        application_1.default.instance.subscribe('isCleared', this.applicationClearedHandler.bind(this));
	    }
	    SigninVM.prototype.close = function () {
	        if (app_1.default.frameless) {
	            window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }); /// consider reference to namespace
	        }
	        else if (parent) {
	            parent.postMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }, document.referrer || '*');
	        }
	        var evtData = new visibilityChangedEvent_1.VisibilityChangedEvent(false);
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	    };
	    SigninVM.prototype.applicationClearedHandler = function () {
	        this.signinEnabled(application_1.default.instance.isCleared);
	    };
	    return SigninVM;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SigninVM;
	;


/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports = "<div class=\"messages\" >\n    <!-- ko if: isDirectLine -->\n    <div class=\"skypeLogo\">\n        <skype-logo></skype-logo>\n    </div>\n    <!-- /ko -->\n    <!-- ko foreach: {data: messagesList, afterAdd:newMessageRendered } -->\n        <!-- ko component: {\n            name: type.toLowerCase(),\n            params: {\n                message: $data,\n                conversation: $parent.conversation,\n                meUserName: $parent.meUserName,\n                suggestedActions: $parent.suggestedActions\n            }\n        } -->\n        <!-- /ko -->\n\n    <!-- /ko -->\n    <div class=\"branding\" aria-hidden=\"true\" tabindex=\"-2\" data-bind=\"css: {isTyping: isTyping(), emptyBottomMargin: showSuggestedActions()}\">\n        <div class=\"typingIndicator\">\n            <div class=\"bubble\">\n            </div>\n            <div class=\"bubble\">\n            </div>\n            <div class=\"bubble\">\n            </div>\n            <div>\n                <span data-bind=\"text:typingMessage\"></span> is responding...\n            </div>\n        </div>\n        <div class=\"translate\" data-bind=\"css: { isTranslating: translatorActive}\">\n            <div class=\"translation-globe\">\n                <icon-globus></icon-globus>\n            </div>\n            <div>\n                Translator: <strong>active</strong>\n            </div>\n        </div>\n    </div>\n    <div class=\"suggested-actions\" data-bind=\"css: {'show-suggested-actions': showSuggestedActions()}\">\n        <!-- ko if: showSuggestedActions() -->\n        <div class=\"navBtnWrapper\" data-bind=\"click: scrollSuggestionsToLeft, css: { disabled: !hasSuggestedActionOnLeft()}\">\n            <div class=\"left\" role=\"button\" aria-role=\"button\" data-bind=\"attr: {tabindex: hasSuggestedActionOnLeft() ? 0 : undefined}\">\n                <icon-arrow class=\"icon\"></icon-arrow>\n            </div>\n        </div>\n        <!-- /ko -->\n        <div id=\"suggestionArea\" class=\"actionItems\" data-bind=\"foreach: {data: suggestedActions}, scroll: suggestionsChanged\">\n            <button class=\"actionItem\" data-bind=\"click: $parent.invokeSuggestedAction, css: {image: $parent.isDirectLine && $data.image_url, icon: !$parent.isDirectLine && (actionType === 'openUrl' || actionType === 'call') }\">\n                <!-- ko if: $parent.isDirectLine-->\n                    <!-- ko if: $data.title -->\n                    <p class=\"swc-title\" data-bind=\"text: title\"></p>\n                    <!-- /ko -->\n\n                    <!-- ko if: $data.image_url -->\n                    <img class=\"image\" data-bind=\"attr:{src: image_url}\"></img>\n                    <!-- /ko -->\n                <!-- /ko -->\n\n                <!-- ko if: !$parent.isDirectLine-->\n                    <!-- ko if: actionType === 'openUrl' -->\n                    <icon-open-url class=\"icon\"></icon-open-url>\n                    <!-- /ko -->\n                    <!-- ko if: actionType === 'call' -->\n                    <icon-call-start class=\"icon\"></icon-call-start>\n                    <!-- /ko -->\n                    <p data-bind=\"text: title\"></p>\n                <!-- /ko -->\n            </button>\n        </div>\n        <!-- ko if: showSuggestedActions() -->\n        <div class=\"navBtnWrapper\" data-bind=\"click: scrollSuggestionsToRight, css: { disabled: !hasSuggestedActionOnRight()}\">\n            <div role=\"button\" aria-role=\"button\" data-bind=\"attr: {tabindex: hasSuggestedActionOnRight() ? 0 : undefined}\">\n                <icon-arrow class=\"icon\"></icon-arrow>\n            </div>\n        </div>\n        <!-- /ko -->\n    </div>\n    <div class=\"down-arrow\" data-bind=\"css: {'show-down-arrow': showJumpArrow()}, click: jumpToBottom\">\n        <div class=\"down-btn\" aria-role=\"button\" data-bind=\"attr: {tabindex: showJumpArrow() ? 0 : undefined}\">Scroll to bottom</div>\n    </div>\n\n\n</div>\n\n<script type=\"text/html\" id=\"swiftUnsupported\">\n    <div class=\"lwx-message\">\n        <div class=\"card unsupported\">\n            <span class=\"main emoticon sad animated\">\n                <span class=\"icon\">&#9785;</span>\n            </span>\n            <div class=\"text\">\n                <div data-bind=\"text: unsupportedText\"></div>\n            </div>\n            <div class=\"buttons\">\n                <div class=\"button\" data-bind=\"attr: { tabindex: (button && button.isValid()) ? 0 : null, role: (button && button.isValid()) ? 'button' : null, title: (button && button.isValid()) ? button.tooltip : null },\n                                            enterKey: (button && button.isValid()) ? button.action : null,\n                                            click: (button && button.isValid()) ? button.action : null, clickBubble: false\">\n                    <span class=\"normal\" data-bind=\"text: button.tooltip\"></span>\n                </div>\n            </div>\n        </div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftSingleCard\">\n<div class=\"lwx-message\" role=\"listitem\">\n    <!-- ko template: { name: 'contentSection' } --><!-- /ko -->\n    <div class=\"card\" data-bind=\"template: { name: cards[0].getContentTypeName() === 'hero' || cards[0].getContentTypeName() === 'thumb' ? 'swiftCard' : 'swiftCard-' + cards[0].getContentTypeName(), data: cards[0]}, css: cards[0].getContentTypeName()\"></div>\n</div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCarouselCard\">\n    <div class=\"lwx-message carousel\" data-bind=\"css: { first: isFirst, last: isLast, multiple: isMultiple, double: cards.length == 2, triple: cards.length == 3 }\">\n        <!-- ko template: { name: 'contentSection' } --><!-- /ko -->\n        <div class=\"carouselContainer\" data-bind=\"css: { multiLine: areButtonsMultiLine },\n                                          foreach: {\n                                              data: cards,\n                                              as: 'card',\n                                              afterRender: function(e, card) { e[1].addEventListener('focus', function() { moveToCard(card); }, true); }\n                                          },\n                                          style: { left: carouselLeftPosition() }\">\n            <div class=\"card\" data-bind=\"template: { name: card.getContentTypeName() === 'hero' || card.getContentTypeName() === 'thumb' ? 'swiftCard' : 'swiftCard-' + card.getContentTypeName(), data: card },\n                                        css: card.getContentTypeName()\"></div>\n\n        </div>\n        <div class=\"prev\" data-bind=\"click: prevCard, enterKey: prevCard, attr: { title: prevCardTitle }\">\n            <icon-arrow class=\"button\" role=\"button\" tabindex=\"0\"></icon-arrow>\n        </div>\n        <div class=\"next\" data-bind=\"click: nextCard, enterKey: nextCard, attr: {title: nextCardTitle}\">\n            <icon-arrow class=\"button\" role=\"button\" tabindex=\"0\"></icon-arrow>\n        </div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard\">\n    <div class=\"cardContent\" data-bind=\"attr: { tabindex: (content.tap && content.tap.isValid()) ? -1 : null, role: (content.tap && content.tap.isValid()) ? 'presentation' : null, title: (content.tap && content.tap.isValid()) ? content.tap.tooltip : null },\n                                              css: { tap: content.tap && content.tap.isValid() },\n                                              enterKey: (content.tap && content.tap.isValid()) ? content.tap.action : null,\n                                              click: (content.tap && content.tap.isValid()) ? content.tap.action : null, clickBubble: false\">\n        <!-- ko if: content.mainSection.isValid() -->\n            <!-- ko template: { name: 'swiftSection', data: content.mainSection } --><!-- /ko -->\n        <!-- /ko -->\n        <div class=\"buttons\" data-bind=\"foreach: { data: content.buttons, as: 'button' }, css: { multiLine: content.areButtonsMultiLine}\">\n            <!-- ko template: { name: 'swiftButton', data: button } --><!-- /ko -->\n        </div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-receipt\">\n    <div data-bind=\"attr: { tabindex: (content.tap && content.tap.isValid()) ? 0 : null, role: (content.tap && content.tap.isValid()) ? 'button' : null, title: (content.tap && content.tap.isValid()) ? content.tap.tooltip : null },\n                                              css: { tap: content.tap && content.tap.isValid() },\n                                              enterKey: (content.tap && content.tap.isValid()) ? content.tap.action : null,\n                                              click: (content.tap && content.tap.isValid()) ? content.tap.action : null, clickBubble: false\">\n        <!-- ko if: title -->\n            <h1 data-bind=\"html: content.title\"></h1>\n        <!-- /ko -->\n        <!-- ko if: content.facts.length !== 0 -->\n            <div class=\"facts\" role=\"list\" data-bind=\"foreach: { data: content.facts, as: 'fact' }\">\n                <!-- ko template: { name: 'swiftFact', data: fact } --><!-- /ko -->\n            </div>\n        <!-- /ko -->\n        <!-- ko if: content.displayedItems().length !== 0 -->\n            <div class=\"items\" role=\"list\" data-bind=\"foreach: { data: content.displayedItems, as: 'item' }\">\n                <div class=\"item\" role=\"listitem\">\n                    <!-- ko template: { name: item.images.length !== 0 ? 'swiftSection' : 'swiftItem', data: item } --><!-- /ko -->\n                </div>\n            </div>\n        <!-- /ko -->\n        <!-- ko if: content.showFoldButton -->\n        <div class=\"button fold\" data-bind=\"attr: { tabindex: -1, role: 'button', title: content.foldButtonText() },\n                                   enterKey: content.triggerFoldAction,\n                                   click: content.triggerFoldAction, clickBubble: false\">\n            <span class=\"normal\" data-bind=\"text: content.foldButtonText()\"></span>\n        </div>\n        <!-- /ko -->\n        <div class=\"summary\">\n            <!-- ko if: content.vat -->\n                <div class=\"line\">\n                    <span class=\"key normal\" data-bind=\"text: content.vatText\"></span>\n                    <span class=\"value normal\" data-bind=\"text: content.vat\"></span>\n                </div>\n            <!-- /ko -->\n            <!-- ko if: content.tax -->\n                <div class=\"line\">\n                    <span class=\"key normal\" data-bind=\"text: content.taxText\"></span>\n                    <span class=\"value normal\" data-bind=\"text: content.tax\"></span>\n                </div>\n            <!-- /ko -->\n            <div class=\"line\">\n                <span class=\"key normal\" data-bind=\"text: content.totalPriceText\"></span>\n                <span class=\"value normal\" data-bind=\"text: content.total\"></span>\n            </div>\n        </div>\n        <div class=\"buttons\" data-bind=\"foreach: { data: content.buttons, as: 'button' }, css: { multiLine: content.areButtonsMultiLine}\">\n            <!-- ko template: { name: 'swiftButton', data: button } --><!-- /ko -->\n        </div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-signin\">\n    <span class=\"main emoticon hi animated\">\n        <span class=\"icon\">&#9787;</span>\n    </span>\n    <div class=\"text\" data-bind=\"html: content.text\"></div>\n    <div class=\"buttons\" data-bind=\"foreach: { data: content.buttons, as: 'button' }\">\n        <!-- ko template: { name: 'swiftButton', data: button } --><!-- /ko -->\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftSection\">\n    <div class=\"section\" data-bind=\"attr: { tabindex: (tap && tap.isValid()) ? 0 : null, role: (tap && tap.isValid()) ? 'presentation' : null, title: (tap && tap.isValid()) ? getTitleByType() : null },\n                css: { tap: tap && tap.isValid() },\n                enterKey: (tap && tap.isValid()) ? tap.action : null,\n                click: (tap && tap.isValid()) ? tap.action : null, clickBubble: false\">\n        <div class=\"textContent\">\n            <!-- ko if: title -->\n                <h1 data-bind=\"html: title, attr: { title: $element.textContent }\"></h1>\n            <!-- /ko -->\n            <!-- ko if: price -->\n                <span class=\"price normal\" data-bind=\"html: price, attr: { title: $element.textContent }\"></span>\n            <!-- /ko -->\n            <!-- ko if: subtitle -->\n                <h2 data-bind=\"html: subtitle, attr: { title: $element.textContent }\"></h2>\n            <!-- /ko -->\n            <!-- ko if: text -->\n                <p class=\"normal\" data-bind=\"html: text, attr: { title: $element.textContent }, css: { expandedText: expandedText() }\"></p>\n            <!-- /ko -->\n        </div>\n        <!-- ko if: images.length > 0 -->\n            <!-- ko with: images[0] -->\n\n                <div class=\"image\" data-bind=\"attr: { tabindex: (tap && tap.isValid()) ? 0 : null, role: (tap && tap.isValid()) ? 'button' : null, title: (tap && tap.isValid()) ? getTitleByType() : null },\n                                              css: { tap: tap && tap.isValid() },\n                                              enterKey: (tap && tap.isValid()) ? tap.action : null,\n                                              click: (tap && tap.isValid()) ? tap.action : null, clickBubble: false\">\n                    <!-- ko if: isValid() -->\n                    <img data-bind=\"attr: { src: url(), alt: alt, width: uiSize().width, height: uiSize().height },\n                                    style: { bottom: bottomAlignment() + 'px'}\" />\n                    <!-- /ko -->\n                </div>\n            <!-- /ko -->\n        <!-- /ko -->\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftButton\">\n    <div class=\"lwx-message button\" data-bind=\"attr: { tabindex: isValid() ? -1 : null, role: isValid() ? 'button' : null, title: tooltip },\n                                   enterKey: isValid() ? action : null,\n                                   click: isValid() ? action : null, clickBubble: false\">\n        <span class=\"normal\" data-bind=\"text: title\"></span>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftFact\">\n    <div class=\"fact\" role=\"listitem\">\n        <span class=\"key normal\" data-bind=\"html: key\"></span>\n        <span class=\"value normal\" data-bind=\"html: value\"></span>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftItem\">\n    <span class=\"swc-title\" data-bind=\"html: title\"></span>\n    <span class=\"price normal\" data-bind=\"text: price\"></span>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-video\">\n    <div class=\"cardContent\" data-bind=\"css: content.aspect\">\n        <div class=\"videoCard\">\n            <videoplayer params=\"media: content.media.video, thumbnail: content.image.url, autoplay: content.autostart, muted: true, autoloop: false, displayMuteButton: true, messageId: $component.message.id, title: content.title, subtitle: content.subtitle\"></videoplayer>\n        </div>\n        <div data-bind=\"template: 'mediaCardSection', data: $data.content\"></div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-audio\">\n    <div class=\"cardContent\">\n        <div class=\"audioCard\">\n            <div class=\"audio-message\" data-bind=\"css: {thumbnail: content.hasThumbnail()}\">\n                <div class=\"media-holder\">\n                    <div class=\"media-content\">\n                        <audioplayer params=\"media: content.media.audio, autoplay: content.autostart, messageId: $component.message.id, coverImage: content.image\"></audioplayer>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div data-bind=\"template: 'mediaCardSection', data: $data.content\"></div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-animation\">\n    <div class=\"cardContent\">\n        <div class=\"animationCard\">\n            <gifplayer params=\"media: content.media.animation, coverImage: content.image\"></gifplayer>\n        </div>\n        <div data-bind=\"template: 'mediaCardSection', data: $data.content\"></div>\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"contentSection\">\n    <!-- ko if: content -->\n    <div class=\"card\" data-bind=\"css: cards[0].getContentTypeName()\">\n        <div class=\"cardContent\">\n            <div class=\"section\">\n                <div class=\"textContent\">\n                    <p class=\"normal\" data-bind=\"html: content\"></p>\n                </div>\n            </div>\n        </div>\n    </div>\n    <!-- /ko -->\n</script>\n\n<script type=\"text/html\" id=\"mediaCardSection\">\n    <!-- ko if: hasTextInfo() -->\n    <div class=\"section\">\n        <div class=\"textContent\">\n            <!-- ko if: title -->\n            <h1 data-bind=\"text: title, attr: { title: title }\"></h1>\n            <!-- /ko -->\n            <!-- ko if: subtitle -->\n            <h2 data-bind=\"text: subtitle, attr: { title: subtitle }\"></h2>\n            <!-- /ko -->\n            <!-- ko if: media -->\n                <!-- ko if: media.sourceDomain -->\n                <h3 data-bind=\"text: media.sourceDomain, attr: { title: media.sourceDomain }\"></h3>\n                <!-- /ko -->\n            <!-- /ko -->\n        </div>\n    </div>\n    <!-- /ko -->\n    <div class=\"buttons\" data-bind=\"foreach: { data: content.buttons, as: 'button' }, css: { multiLine: content.areButtonsMultiLine}\">\n        <!-- ko template: { name: 'swiftButton', data: button } --><!-- /ko -->\n    </div>\n</script>\n\n<script type=\"text/html\" id=\"swiftCard-adaptive\">\n    <adaptivecard params=\"content: content, conversation: _conversation\"></adaptivecard>\n</script>\n"

/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports = "<div class=\"textInputContainer\">\n    <textarea data-bind=\"event: {keydown: onKeyDown, input: handleInput}, attr: {'placeholder': placeholder, 'maxlength':maxLength}\" autofocus></textarea>\n\n    <!-- ko if: inputHasValue() || !chatConfig.CanUploadFile -->\n    <button aria-label=\"send message\" class=\"send\" data-bind=\"click: sendButtonHandler, style:{backgroundColor: sendButtonColor}, attr:{'disabled': !onSendMessageEnabled()}\">\n        <icon-sent />\n    </button>\n    <!-- /ko -->\n\n    <!-- ko if: chatConfig.CanUploadFile -->\n        <input id=\"myFiles\" multiple type=\"file\" data-bind=\"event: {change: sendFile}\"></input>\n\n        <!-- ko if: !inputHasValue() -->\n        <button aria-label=\"send file\" class=\"send file-picker\" tabindex=\"0\" data-bind=\"click: selectFile, style:{fill: sendButtonColor}, attr:{'disabled': !isFileTransferEnabled()}\">\n            <icon-file-img />\n        </button>\n        <!-- /ko -->\n\n    <!-- /ko -->\n</div>\n"

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = "<!-- ko if: showLoginPage -->\n<lwc-signin params=\"isSignedIn: signedIn, conversation: conversation\"></lwc-signin>\n<!-- /ko -->\n\n<!-- ko if: signedIn -->\n    <!-- ko if: chatDataConfig.ShowHeader -->\n    <div class=\"swc-header\">\n        <div class=\"preview\">Preview</div>\n        <!-- ko if: avatarUrl -->\n        <div class=\"headerAvatar\" aria-label=\"avatar\" tabindex=\"0\"  data-bind=\"style: {backgroundImage: 'url(\\'' + avatarUrl() + '\\')'}\">\n            <!-- ko if: isAgent -->\n                <!-- ko component: \"icon-hexagon\" -->\n                <!-- /ko -->\n            <!-- /ko -->\n        </div>\n        <!-- /ko -->\n        <div class=\"topic\">\n            <div class=\"swc-title\" tabindex=\"0\" data-bind=\"attr:{'aria-label':title}, text: title\"></div>\n            <div class=\"terms\">\n                <!-- ko if: showTermsOfUse -->\n                <a class=\"termsOfUse\" data-bind=\"attr:{href:termOfUse}, text: termOfUseText\" target=\"_blank\"></a>\n                <!-- /ko -->\n\n                <!-- ko if: showPrivacyStatement -->\n                <a class=\"privacy\" data-bind=\"attr:{href:privacyStatement}, text: privacyStatementText\" target=\"_blank\"></a>\n                <!-- /ko -->\n            </div>\n        </div>\n        <div class=\"controls\">\n\n        <!-- ko if: chatDataConfig.CanCollapse-->\n            <button aria-label=\"minimize window\" data-bind=\"click:toggleChatSize\" class=\"collapse\">\n                <span data-bind=\"css: { collapsed: isCollapsed()}\" class=\"mdash\"></span>\n            </button>\n        <!--/ko  -->\n\n        <!-- ko if: chatDataConfig.CanClose -->\n            <button aria-label=\"close window\" data-bind=\"click:close\" class=\"close\">\n                <icon-close class=\"svg-icon\"></icon-close>\n            </button>\n        <!-- /ko -->\n        </div>\n    </div>\n    <!-- /ko -->\n    <messages-list role=\"list\" aria-live=\"polite\" data-bind=\"keyboardNavigation: { itemSelector: '.lwx-message, .actionItem, .button, a', selectLastItem: true }, css: {'no-header': !chatDataConfig.ShowHeader, 'collapsed': isCollapsed()}\"  params=\"conversation: conversation, userMessageSent: userMessageSent, enable: enable\"></messages-list>\n    <!-- ko if: isGuest() && !userMessageSent() -->\n        <div class=\"msa-privacy\">\n             <div data-bind=\"html: MSServiceAndPrivacyAgreement\" class=\"text\"></div>\n        </div>\n    <!-- /ko -->\n    <chat-input params=\"conversation: conversation, enable: enable\" data-bind=\"css: {collapsed: isCollapsed()}\"></chat-input>\n<!-- /ko -->\n"

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports = "<div class=\"sign-in-wrapper\">\n    <div class=\"sign-in-header\">\n        <skype-logo></skype-logo>\n    </div>\n    <div class=\"sign-in-content\">\n        \n        <!-- ko ifnot:isGuestOnlyMode -->\n        <div tabindex=\"0\" aria-label=\"Please sign in to start chatting\">\n            Please sign in to start chatting.\n        </div>\n        <button tabindex=\"0\" class=\"sign-in-button\" data-bind=\"click: signIn\">Sign in</button>\n        <!-- /ko -->\n\n        <!-- ko if:isGuestOnlyMode -->\n        <div tabindex=\"0\" aria-label=\"You cannot sign in when guest only mode enabled\">\n            You cannot signin when \"guestonly\" mode enabled.\n        </div>\n        <!-- /ko -->\n\n        <!-- ko if: chatConfig.CanClose -->\n        <button tabindex=\"0\" class=\"sign-in-cancel\" data-bind=\"click: close\">Cancel</button>\n        <!-- /ko -->\n    </div>\n    <div class=\"sign-in-header\"></div>\n</div>\n"

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	// import ComponentsRegistrar from './componentsRegistrar';
	var directLineViewModel_1 = __webpack_require__(189);
	var directLineViewModel_2 = __webpack_require__(190);
	var directLineViewModel_3 = __webpack_require__(191);
	var DirectLineComponentsRegistrar = (function () {
	    function DirectLineComponentsRegistrar() {
	    }
	    DirectLineComponentsRegistrar.register = function (chatDataConfig) {
	        if (this.isInitialized) {
	            return;
	        }
	        ko.components.register('dl-messages-list', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new directLineViewModel_1.default(params, componentInfo.element);
	                }
	            },
	            template: __webpack_require__(184),
	            synchronous: true
	        });
	        ko.components.register('dl-chat-input', {
	            viewModel: {
	                createViewModel: function (params, componentInfo) {
	                    return new directLineViewModel_2.default(params, componentInfo.element, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(185),
	            synchronous: true
	        });
	        ko.components.register('dl-conversation', {
	            viewModel: {
	                createViewModel: function (params) {
	                    return new directLineViewModel_3.default(params, chatDataConfig);
	                }
	            },
	            template: __webpack_require__(192),
	            synchronous: true
	        });
	        this.isInitialized = true;
	    };
	    DirectLineComponentsRegistrar.unregister = function () {
	        ko.components.unregister('dl-messages-list');
	        ko.components.unregister('dl-chat-input');
	        ko.components.unregister('dl-conversation');
	        this.isInitialized = false;
	    };
	    DirectLineComponentsRegistrar.isInitialized = false;
	    return DirectLineComponentsRegistrar;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectLineComponentsRegistrar;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var messageUtils_1 = __webpack_require__(130);
	var actionTrigger_1 = __webpack_require__(154);
	var scrollUtils_1 = __webpack_require__(180);
	var api_1 = __webpack_require__(44);
	var TYPING_INDICATOR_TIMEOUT = 5000;
	var API_CLICK_ACTION = 'swc:action:click';
	var API_ELEMENT_SELECTOR = '.message';
	var DirectLineMessagesList = (function () {
	    function DirectLineMessagesList(_params, _element) {
	        var _this = this;
	        this._params = _params;
	        this._element = _element;
	        this.messagesList = ko.observableArray();
	        this.clientHeight = ko.observable('100%');
	        this.showJumpArrow = ko.observable(false);
	        this.isTyping = ko.observable();
	        this.typingMessage = ko.observable('');
	        this.languages = ko.observableArray();
	        this.showSuggestedActions = ko.observable(false);
	        this.hasSuggestedActionOnLeft = ko.observable(true);
	        this.hasSuggestedActionOnRight = ko.observable(true);
	        this.translatorActive = ko.observable(false);
	        this._isScrollAnimating = false;
	        this._blockScroll = true;
	        this.invokeSuggestedAction = function (action) {
	            _this.conversation.sendMessage(action.title || action.payload, actionTrigger_1.ActionTrigger.SUGGESTED_ACTION, action);
	        };
	        this.suggestionChanged = function () {
	            var value;
	            if (_this._suggestionArea.scrollLeft === 0) {
	                value = false;
	            }
	            else {
	                value = true;
	            }
	            _this.hasSuggestedActionOnLeft(value);
	            if (_this._suggestionArea.scrollLeft === _this._suggestionArea.scrollWidth - _this._suggestionArea.clientWidth) {
	                value = false;
	            }
	            else {
	                value = true;
	            }
	            _this.hasSuggestedActionOnRight(value);
	        };
	        this.scrollSuggestionsToLeft = function () {
	            _this._scrollSuggestedArea(_this._suggestionArea.scrollLeft - _this._suggestionArea.clientWidth);
	        };
	        this.scrollSuggestionsToRight = function () {
	            _this._scrollSuggestedArea(_this._suggestionArea.scrollLeft + _this._suggestionArea.clientWidth);
	        };
	        this._scrollSuggestedArea = function (to) {
	            scrollUtils_1.scrollTo(to, 250, 'scrollLeft', _this._suggestionArea, function () { return _this.suggestionChanged(); });
	        };
	        this._swcClickEventHandler = function (e) {
	            var payload = e.target.getAttribute('data-swc-payload');
	            payload && api_1.default.triggerEvent('click', payload) && e.preventDefault();
	        };
	        this.newMessageRendered = function (node) {
	            Object.keys(api_1.default.registry).length && messageUtils_1.default.attachActionToLinks(node, API_ELEMENT_SELECTOR, API_CLICK_ACTION, _this._swcClickEventHandler);
	        };
	        this._initConversationMessagesList = function () {
	            _this.conversation = _this._params.conversation;
	            if (_this.conversation.messages.length > 0) {
	                (_a = _this.messagesList).push.apply(_a, _this.conversation.messages);
	                setTimeout(_this._scrollToBottom, 0);
	            }
	            _this.conversation.messages.subscribe(_this._onNewMessages);
	            _this.conversation.subscribe('isTyping', _this._onTypingIndicator.bind(_this));
	            var _a;
	        };
	        this.dispose = function () {
	            if (_this.conversation) {
	                _this.conversation.messages.unsubscribe(_this._onNewMessages);
	            }
	            _this.messagesList().forEach(function (message) {
	                message.dispose();
	            });
	        };
	        this.jumpToBottom = function () {
	            _this._scrollToBottom(400);
	        };
	        this._onNewMessages = function (messages, changes) {
	            (_a = _this.messagesList).push.apply(_a, changes.newItems);
	            _this._processSuggestedActions(changes.newItems[0]);
	            _this._scrollToBottom();
	            var _a;
	        };
	        this._processSuggestedActions = function (lastMessage) {
	            if (lastMessage.suggestedActions.length) {
	                _this.suggestedActions(lastMessage.suggestedActions);
	                _this.showSuggestedActions(true);
	                _this.suggestionChanged();
	                setTimeout(function () { return _this._scrollToBottom(250); }, 250);
	            }
	            else {
	                _this.suggestedActions([]);
	                _this.showSuggestedActions(false);
	            }
	        };
	        this._scrollToBottom = function (duration) {
	            if (duration) {
	                _this.showJumpArrow(false);
	                _this._isScrollAnimating = true;
	                _this._scrollTo(_this._element.scrollHeight, duration ? duration : 0);
	            }
	            else {
	                _this._element.scrollTop = _this._element.scrollHeight;
	            }
	        };
	        this._scrollToLast = function () {
	            _this._element.scrollTop = _this._element.scrollHeight - _this._lastScrollHeight;
	        };
	        this._scrollTo = function (to, duration) {
	            if (duration <= 0) {
	                _this._isScrollAnimating = false;
	                return;
	            }
	            var difference = to - _this._element.scrollTop;
	            var perTick = difference / duration * 10;
	            setTimeout(function () {
	                _this._element.scrollTop = _this._element.scrollTop + perTick;
	                if (_this._element.scrollTop === to) {
	                    return;
	                }
	                _this._scrollTo(to, duration - 10);
	            }, 10);
	        };
	        this._initConversationMessagesList();
	        this.typingMessage(this.adjustBotName(''));
	        this._params.conversation.subscribe('topic', function (value) {
	            _this.typingMessage(_this.adjustBotName(value));
	        });
	        this._suggestionArea = document.getElementById('suggestionArea');
	        this.suggestedActions = ko.observableArray([]);
	        this.isDirectLine = this.conversation.isDirectLineBackend();
	        window.addEventListener('resize', function () {
	            console.log('reszie');
	            _this.suggestionChanged();
	        });
	    }
	    DirectLineMessagesList.prototype.adjustBotName = function (name) {
	        if (this.conversation.definition.Title) {
	            return this.conversation.definition.Title;
	        }
	        if (!name) {
	            return 'Bot';
	        }
	        return name;
	    };
	    DirectLineMessagesList.prototype._onTypingIndicator = function (value) {
	        this.isTyping(value);
	        if (this._typingIndicatorTimoutId) {
	            clearTimeout(this._typingIndicatorTimoutId);
	        }
	        if (value) {
	            var self_1 = this;
	            this._typingIndicatorTimoutId = setTimeout(function () {
	                self_1.isTyping(false);
	                self_1._typingIndicatorTimoutId = undefined;
	            }, TYPING_INDICATOR_TIMEOUT);
	        }
	    };
	    return DirectLineMessagesList;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectLineMessagesList;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../customTypings/skype.d.ts" />
	/// <reference path="../../../typings/index.d.ts" />
	"use strict";
	var actionTrigger_1 = __webpack_require__(154);
	var i18n_1 = __webpack_require__(112);
	var DirectLineChatInputVM = (function () {
	    function DirectLineChatInputVM(_params, element, chatConfig) {
	        var _this = this;
	        this._params = _params;
	        this.element = element;
	        this.chatConfig = chatConfig;
	        this.isChatEnabled = ko.observable(true);
	        this.isSendingEnabled = ko.observable(false);
	        this.placeholder = i18n_1.default.fetch('area_text_insertText');
	        this.maxLength = 2000;
	        this.onSendEnabled = function () {
	            return _this.chatConfig && _this.chatConfig.ColorMain !== null ? _this.chatConfig.ColorMain : '';
	        };
	        this.onSendMessageEnabled = function () {
	            return _this.inputHasValue() && _this.isChatEnabled();
	        };
	        this._conversation = _params.conversation;
	        this._textarea = element.querySelector('textarea');
	        this.inputHasValue = ko.observable(false);
	        this._textarea.addEventListener('input', function (event) {
	            _this.isSendingEnabled(true);
	            _this.inputHasValue(!!_this._textarea.value);
	        });
	        this.sendButtonColor = ko.computed(this.onSendEnabled);
	        this.isFileTransferEnabled = ko.computed(function () {
	            return false;
	        });
	        this.isSendMessageEnabled = ko.computed(this.onSendMessageEnabled);
	    }
	    DirectLineChatInputVM.prototype.sendMessage = function (actionTrigger) {
	        // window.SkypeWebControl.SDK.MessagingService.sendMessage(null, this._textarea.value, actionTrigger);
	        this._conversation.sendMessage(this._textarea.value, actionTrigger);
	        this._textarea.value = '';
	        this.inputHasValue(false);
	    };
	    DirectLineChatInputVM.prototype.sendFile = function () { };
	    DirectLineChatInputVM.prototype.selectFile = function () { };
	    DirectLineChatInputVM.prototype.onKeyDown = function (self, event) {
	        var code = event.keyCode || event.which;
	        if (code !== 13) {
	            return true;
	        }
	        if (event.shiftKey) {
	            return true;
	        }
	        event.preventDefault();
	        this.sendMessage(actionTrigger_1.ActionTrigger.KEYPRESS_ENTER);
	        return false;
	    };
	    DirectLineChatInputVM.prototype.handleInput = function (self, event) {
	    };
	    DirectLineChatInputVM.prototype.sendButtonHandler = function () {
	        this.sendMessage(actionTrigger_1.ActionTrigger.BUTTON_SEND_CLICK);
	    };
	    return DirectLineChatInputVM;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectLineChatInputVM;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var i18n_1 = __webpack_require__(112);
	var actionNames_1 = __webpack_require__(35);
	var config_1 = __webpack_require__(27);
	var app_1 = __webpack_require__(26);
	var api_1 = __webpack_require__(44);
	var DirectLineViewModel = (function () {
	    function DirectLineViewModel(_params, chatDataConfig) {
	        var _this = this;
	        this._params = _params;
	        this.chatDataConfig = chatDataConfig;
	        this.conversationId = ko.observable();
	        this.showComponent = ko.observable(true);
	        this.isCollapsed = ko.observable(false);
	        this.title = ko.observable();
	        // public isPopUp = !!window.opener;
	        this.avatarUrl = ko.observable('');
	        this.signedIn = ko.observable(true);
	        this.isAgent = ko.observable(true);
	        this.isChatEnabled = ko.observable(true);
	        this.showContactRequest = ko.observable(false);
	        this.privacyStatement = ko.observable();
	        this.termOfUse = ko.observable();
	        this.showTermsOfUse = ko.observable(false);
	        this.showPrivacyStatement = ko.observable(false);
	        this.showLoginPage = ko.observable(false);
	        this.userMessageSent = ko.observable(true);
	        this.isGuest = ko.observable(true);
	        this.showPrivacyAgreement = ko.observable();
	        this.privacyStatementText = i18n_1.default.fetch('header_privacyPolicy');
	        this.termOfUseText = i18n_1.default.fetch('header_termsOfUse');
	        this.MSServiceAndPrivacyAgreement = i18n_1.default.fetch('ms_service_privacy_agreement', {
	            linkMSA: 'https://www.microsoft.com/en-us/servicesagreement/',
	            linkPrivacy: 'https://privacy.microsoft.com/en-us/privacystatement'
	        });
	        this.enable = this._params.enable;
	        this.conversation = _params.conversation;
	        this.setTitle();
	        this.setAvatar();
	        api_1.default.registerEvent('forceExpandChat', function () { return _this.isCollapsed(false); });
	    }
	    DirectLineViewModel.prototype.close = function () {
	        if (app_1.default.frameless) {
	            window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }); /// consider reference to namespace
	        }
	        else if (parent) {
	            parent.postMessage({ origin: config_1.default.ORIGIN, action: actionNames_1.default.HideChatWindow }, document.referrer || '*');
	        }
	    };
	    DirectLineViewModel.prototype.toggleChatSize = function () {
	        this.isCollapsed(!this.isCollapsed());
	        var action = this.isCollapsed() ? actionNames_1.default.CollapseChatWindow : actionNames_1.default.ExpandChatWindow;
	        if (app_1.default.frameless) {
	            window.SkypeWebControl.SDK.Chat.resolveMessage({ origin: config_1.default.ORIGIN, action: action }); /// consider reference to namespace
	        }
	        else if (parent) {
	            parent.postMessage({ origin: config_1.default.ORIGIN, action: action }, document.referrer || '*');
	        }
	        // todo: telemetry
	    };
	    DirectLineViewModel.prototype.setTitle = function () {
	        var _this = this;
	        if (this.chatDataConfig.Title) {
	            this.title(this.chatDataConfig.Title);
	        }
	        else {
	            this.conversation.subscribe('topic', function (value) {
	                _this.title(_this.conversation.topic);
	            });
	        }
	    };
	    DirectLineViewModel.prototype.setAvatar = function () {
	        var avatarUrl = this.chatDataConfig.Avatar ? this.chatDataConfig.Avatar : this.conversation.avatar;
	        this.avatarUrl(avatarUrl);
	    };
	    return DirectLineViewModel;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectLineViewModel;


/***/ },
/* 192 */
/***/ function(module, exports) {

	module.exports = "<!-- ko if: showLoginPage -->\n<lwc-signin params=\"isSignedIn: signedIn, conversationId: conversation.id\"></lwc-signin>\n<!-- /ko -->\n\n<!-- ko if: showComponent && signedIn -->\n    <!-- ko if: chatDataConfig.ShowHeader -->\n    <div class=\"swc-header\">\n        <div class=\"preview\">Preview</div>\n        <!-- ko if: avatarUrl -->\n        <div class=\"headerAvatar\" aria-label=\"avatar\" tabindex=\"0\"  data-bind=\"style: {backgroundImage: 'url(\\'' + avatarUrl() + '\\')'}\">\n            <!-- ko if: isAgent -->\n                <!-- ko component: \"icon-hexagon\" -->\n                <!-- /ko -->\n            <!-- /ko -->\n        </div>\n        <!-- /ko -->\n        <div class=\"topic\">\n            <div class=\"swc-title\" tabindex=\"0\" data-bind=\"attr:{'aria-label':title}, text: title\"></div>\n            <div class=\"terms\">\n                <!-- ko if: showTermsOfUse -->\n                <a class=\"termsOfUse\" data-bind=\"attr:{href:termOfUse}, text: termOfUseText\" target=\"_blank\"></a>\n                <!-- /ko -->\n\n                <!-- ko if: showPrivacyStatement -->\n                <a class=\"privacy\" data-bind=\"attr:{href:privacyStatement}, text: privacyStatementText\" target=\"_blank\"></a>\n                <!-- /ko -->\n            </div>\n        </div>\n        <div class=\"controls\">\n\n        <!-- ko if: chatDataConfig.CanCollapse-->\n            <button aria-label=\"minimize window\" data-bind=\"click:toggleChatSize\" class=\"collapse\">\n                <span data-bind=\"css: { collapsed: isCollapsed()}\" class=\"mdash\"></span>\n            </button>\n        <!--/ko  -->\n\n        <!-- ko if: chatDataConfig.CanClose -->\n            <button aria-label=\"close window\" data-bind=\"click:close\" class=\"close\">\n                <icon-close class=\"svg-icon\"></icon-close>\n            </button>\n        <!-- /ko -->\n        </div>\n    </div>\n    <!-- /ko -->\n    <dl-messages-list role=\"list\" aria-live=\"polite\" data-bind=\"keyboardNavigation: { itemSelector: '.lwx-message, .actionItem, .container', selectLastItem: true }, css: {'no-header': !chatDataConfig.ShowHeader, 'collapsed': isCollapsed()}\"  params=\"conversation: conversation, userMessageSent: userMessageSent, enable: enable\"></dl-messages-list>\n    <!-- ko if: isGuest() && !userMessageSent() -->\n        <div class=\"msa-privacy\">\n             <div data-bind=\"html: MSServiceAndPrivacyAgreement\" class=\"text\"></div>\n        </div>\n    <!-- /ko -->\n    <dl-chat-input params=\"conversation: conversation, enable: enable\" data-bind=\"css: {collapsed: isCollapsed()}\"></dl-chat-input>\n<!-- /ko -->\n"

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var browser_1 = __webpack_require__(41);
	var urlHelper_1 = __webpack_require__(42);
	var StyleLoader = (function () {
	    function StyleLoader() {
	    }
	    /**
	     * Adds a css stylesheet link to the head if it is not already there.
	     *
	     * @static
	     * @param {string} uri
	     * @param {boolean} [isRelative]
	     * @returns {void}
	     *
	     * @memberOf HTMLManager
	     */
	    StyleLoader.addStyle = function (uri, isRelative, onLoaded) {
	        var absoluteUrl = uri;
	        if (isRelative) {
	            absoluteUrl = urlHelper_1.default.getAbsoluteUrl(absoluteUrl, 'css');
	        }
	        if (this.hasStyle(absoluteUrl)) {
	            if (onLoaded) {
	                onLoaded();
	            }
	            return;
	        }
	        var document = browser_1.default.getDocument();
	        var style = document.createElement('link');
	        style.type = 'text/css';
	        style.rel = 'stylesheet';
	        style.href = absoluteUrl;
	        if (onLoaded) {
	            style.onload = onLoaded;
	        }
	        document.getElementsByTagName('head')[0].appendChild(style);
	    };
	    StyleLoader.hasStyle = function (absolutePath) {
	        for (var i = 0; i < document.styleSheets.length; i++) {
	            if (document.styleSheets[i].href === absolutePath) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return StyleLoader;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = StyleLoader;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ObservableBase_1 = __webpack_require__(76);
	var ObservableCollection_1 = __webpack_require__(177);
	var conversationType_1 = __webpack_require__(14);
	var skypeMessagingService_1 = __webpack_require__(195);
	var directLineMessagingService_1 = __webpack_require__(221);
	var sdkMode_1 = __webpack_require__(30);
	var messagingBackend_1 = __webpack_require__(38);
	var identityParser_1 = __webpack_require__(13);
	var conversationEndEvent_1 = __webpack_require__(226);
	var application_1 = __webpack_require__(47);
	var Conversation = (function (_super) {
	    __extends(Conversation, _super);
	    function Conversation(id, definition) {
	        var _this = this;
	        _super.call(this);
	        this.definition = definition;
	        this._topic = '';
	        this._isChatEnabled = false;
	        // private _backend: MessagingBackend
	        /**
	         * Mode in which SDK markup is defined.
	         *
	         * @static
	         * @type {SDKMode}
	         * @memberOf App
	         */
	        this.sdkMode = sdkMode_1.SDKMode.UNDEFINED;
	        this.isGroup = function () {
	            return _this.id.indexOf('19:') === 0;
	        };
	        this.isAgent = function () {
	            return _this.id.indexOf('28:') === 0;
	        };
	        this.isConversationWithBot = function () {
	            if (!_this.id) {
	                return false;
	            }
	            return _this.id.split(':')[0] === '28' || _this.id.split(':')[0] === '99';
	        };
	        this.isConversationWithPerson = function () {
	            if (!_this.id) {
	                return false;
	            }
	            return _this.id.split(':')[0] === '8';
	        };
	        /**
	         * Backend service being use by the control.
	         *
	         * @static
	         * @type {MessagingBackend}
	         * @memberOf App
	         */
	        this.backend = messagingBackend_1.MessagingBackend.UNDETERMINED;
	        /**
	        * Messages sent by user during the session
	        *
	        * @static
	        * @type {number}
	        * @memberOf App
	        */
	        this.messagesSent = 0;
	        /**
	        * Messages received by user during the session
	        *
	        * @static
	        * @type {number}
	        * @memberOf App
	        */
	        this.messagesReceived = 0;
	        this._id = id;
	        this.sdkMode = this.getSDKMode();
	        this._messages = new ObservableCollection_1.ObservableCollection();
	        this._allMessages = new ObservableCollection_1.ObservableCollection();
	        this._participants = new ObservableCollection_1.ObservableCollection();
	        this._messagingService = identityParser_1.default.isToken(id) ? new directLineMessagingService_1.default(this) : new skypeMessagingService_1.default(this);
	        this._conversationEndEvt = new conversationEndEvent_1.default(this);
	    }
	    Object.defineProperty(Conversation.prototype, "id", {
	        get: function () {
	            return this._id;
	        },
	        set: function (value) {
	            if (value !== this._id) {
	                this._id = value;
	                this.publish('id', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "topic", {
	        get: function () {
	            return this._topic;
	        },
	        set: function (value) {
	            if (value !== this._topic) {
	                this._topic = value;
	                this.publish('topic', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "messages", {
	        get: function () {
	            return this._messages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "allMessages", {
	        get: function () {
	            return this._allMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "participants", {
	        get: function () {
	            return this._participants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "isChatEnabled", {
	        get: function () {
	            return this._isChatEnabled;
	        },
	        set: function (value) {
	            this._isChatEnabled = value;
	            this.publish('isChatEnabled', value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "avatar", {
	        get: function () {
	            return this._avatar;
	        },
	        set: function (value) {
	            if (value !== this._avatar) {
	                this._avatar = value;
	                this.publish('avatar', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Conversation.prototype, "isNew", {
	        get: function () {
	            return this._isNew;
	        },
	        set: function (value) {
	            if (value !== this._isNew) {
	                this._isNew = value;
	                this.publish('isNew', value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Conversation.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        application_1.default.instance.TelemetryService.sendEvent(this._conversationEndEvt);
	        if (this._messages) {
	            var message = void 0;
	            for (var i = 0; i < this._messages.length; i++) {
	                message = this._messages[i];
	                message.dispose();
	            }
	            this._messages.dispose();
	            this._messages.splice(0, this._messages.length);
	        }
	        this._isDisposed = true;
	        this._messagingService.dispose();
	    };
	    Conversation.prototype.getConversationType = function () {
	        // if(this.isGroup()) {
	        //     return ConversationType.;
	        // }
	        if (this.isAgent()) {
	            return conversationType_1.default.AGENT;
	        }
	        if (this.isDirectLineBackend()) {
	            return conversationType_1.default.DIRECT_LINE;
	        }
	        return conversationType_1.default.PERSON;
	    };
	    Object.defineProperty(Conversation.prototype, "isTyping", {
	        get: function () {
	            return this._isTyping;
	        },
	        set: function (value) {
	            if (this._isTyping === value) {
	                return;
	            }
	            this._messagingService.setIsTyping(value);
	            this._isTyping = value;
	            this.publish('isTyping', value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Conversation.prototype.sendMessage = function (text, origin, payload) {
	        this.messagesSent++;
	        this._messagingService.sendMessage(text, origin, payload);
	    };
	    Conversation.prototype.sendImage = function (payload) {
	        this.messagesSent++;
	        return this._messagingService.sendImage(payload);
	    };
	    Conversation.prototype.sendFile = function (payload) {
	        return this._messagingService.sendFile(payload);
	    };
	    Conversation.prototype.sendSwift = function (payload) {
	        return this._messagingService.sendSwift(payload);
	    };
	    Conversation.prototype.start = function () {
	        this._isDisposed = false;
	        return this._messagingService.startConversation();
	    };
	    Conversation.prototype.getSentMessagesCount = function () {
	        return 0;
	    };
	    Conversation.prototype.getReceviedMessagesCount = function () {
	        return 0;
	    };
	    Conversation.prototype.getBackend = function () {
	        if (this.backend !== messagingBackend_1.MessagingBackend.UNDEFINED) {
	            return this.backend;
	        }
	        switch (this.id.split(':')[0]) {
	            case '8':
	            case '28':
	            case '19':
	                this.backend = messagingBackend_1.MessagingBackend.SKYPE;
	                break;
	            case '99':
	                this.backend = messagingBackend_1.MessagingBackend.DIRECT_LINE;
	                break;
	            default:
	                return messagingBackend_1.MessagingBackend.UNDETERMINED;
	        }
	        return this.backend;
	    };
	    Conversation.prototype.getSDKMode = function () {
	        if (this.sdkMode !== sdkMode_1.SDKMode.UNDEFINED) {
	            return this.sdkMode;
	        }
	        var sdkMode;
	        switch (this.id.split(':')[0]) {
	            case '8':
	                sdkMode = sdkMode_1.SDKMode.PERSON;
	                break;
	            case '28':
	                sdkMode = sdkMode_1.SDKMode.BOT;
	                break;
	            case '19':
	                sdkMode = sdkMode_1.SDKMode.THREAD;
	                break;
	            case '99':
	                sdkMode = sdkMode_1.SDKMode.DIRECT_LINE_TOKEN;
	                break;
	            default:
	                sdkMode = sdkMode_1.SDKMode.UNDEFINED;
	        }
	        return sdkMode;
	    };
	    Conversation.prototype.loadMoreMessages = function () {
	        return this._messagingService.loadMoreMessages(this);
	    };
	    Conversation.prototype.isDirectLineBackend = function () {
	        return this.getBackend() === messagingBackend_1.MessagingBackend.DIRECT_LINE;
	    };
	    Conversation.prototype.isSkypeBackend = function () {
	        return this.getBackend() === messagingBackend_1.MessagingBackend.SKYPE;
	    };
	    Object.defineProperty(Conversation.prototype, "isDisposed", {
	        get: function () {
	            return this._isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Conversation.prototype.sendDataToBot = function (payload) {
	        if (!this.isAgent()) {
	            return Promise.resolve();
	        }
	        return this._messagingService.sendDataToBot(payload);
	    };
	    return Conversation;
	}(ObservableBase_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Conversation;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var app_1 = __webpack_require__(26);
	var application_1 = __webpack_require__(47);
	var messageSentEvent_1 = __webpack_require__(196);
	var messageType_1 = __webpack_require__(197);
	var handler_1 = __webpack_require__(198);
	var DeliveryStatus_1 = __webpack_require__(178);
	var actionTrigger_1 = __webpack_require__(154);
	var errorHandler_1 = __webpack_require__(15);
	var encoder_1 = __webpack_require__(201);
	var conversation_1 = __webpack_require__(83);
	var chat_1 = __webpack_require__(77);
	var messageReceivedEvent_1 = __webpack_require__(219);
	var messagesFetchEvent_1 = __webpack_require__(220);
	var conversationLoadEvent_1 = __webpack_require__(89);
	var identityType_1 = __webpack_require__(29);
	var Direction_1 = __webpack_require__(121);
	var domPurifyService_1 = __webpack_require__(131);
	var messagingBackend_1 = __webpack_require__(38);
	var imgUrlRX = /(^|\s)(https?:\/\/[^\s]*\.(?:png\?\d+|png|jpg\?\d+|jpg|jpeg\?\d+|jpeg|gif))($|<|\s)/gim;
	var imgUrlReplacement = '<a class="replacedImg" href="$2" target="_blank"><img src="$2" alt=""></a>';
	var imgUrlReplacementRules = { ALLOWED_TAGS: ['img', 'a'], ALLOWED_ATTR: ['target', 'src', 'alt', 'class', 'href'] };
	var SkypeMessagingService = (function () {
	    function SkypeMessagingService(conversation) {
	        var _this = this;
	        this.conversation = conversation;
	        this._encoder = new encoder_1.default();
	        this.isOneToOneOrBot = function () {
	            return _this.conversation.isConversationWithPerson() || _this.conversation.isConversationWithBot();
	        };
	        this.startGroupConversation = function () {
	            _this.subscribeToConversation();
	            return chat_1.fetchThread(_this.conversation.id).then(function (rawConversation) {
	                if (rawConversation.properties) {
	                    _this.conversation.avatar = rawConversation.properties.picture;
	                    _this.conversation.topic = rawConversation.properties.topic;
	                    rawConversation.members.forEach(function (member) {
	                        //TODO: register to participant changes
	                        _this.conversation.participants.push(application_1.default.instance.StratusManager.getPerson(member.id));
	                    });
	                }
	            });
	        };
	        this.startConversationWithPerson = function () {
	            var personId = _this.conversation.id.slice(2);
	            console.log('startConversationWithPerson personId: ' + personId);
	            var subscribeToConversation = function () {
	                return application_1.default.instance.ContactsManager.isPersonContact(_this.conversation.id).then(function (isContact) {
	                    if (isContact) {
	                        console.log('personId: ' + personId + ' is contact.');
	                        _this.conversation.isChatEnabled = true;
	                        _this.conversation.isNew = false;
	                        return _this.subscribeToConversation();
	                    }
	                    else {
	                        _this.conversation.isChatEnabled = false;
	                        _this.conversation.isNew = true;
	                        console.log('personId: ' + personId + ' is NOT contact.');
	                        return chat_1.subscribeContactPersence(personId, function () {
	                            chat_1.unsubscribeContactPresence(personId);
	                            console.log('personId: ' + personId + ' accepted CR and is now contact.');
	                            _this.subscribeToConversation();
	                            _this.conversation.isChatEnabled = true;
	                        }).then(function () {
	                            console.log('sending contact request to personId: ' + personId);
	                            // TODO: customize the contact request message
	                            // TODO: handle case when CR is not send
	                            // TODO: in case of group conversation send user's mri
	                            application_1.default.instance.ContactsManager.addContact(_this.conversation.id, 'Hi, I would like to add you to my contacts.');
	                        });
	                    }
	                });
	            };
	            return _this.executeWhenSignedIn(subscribeToConversation);
	        };
	        this.startConversationWithBot = function (sendRequest) {
	            if (sendRequest === void 0) { sendRequest = true; }
	            var id = _this.conversation.id;
	            var botId = _this.conversation.id.slice(3);
	            var self = _this;
	            console.log('startConversationWithBot botId: ' + botId);
	            var startWithBot = function () {
	                console.log('[START CONVERSATION WITH BOT]::check if contact');
	                // SEND CONTACT REQUEST IF CONTACT IS MISSING
	                application_1.default.instance.ContactsManager.isPersonContact(id).then(function (isContact) {
	                    if (isContact) {
	                        console.log('botId: ' + botId + ' is contact.');
	                        self.subscribeToConversation();
	                        _this.conversation.isChatEnabled = true;
	                        if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.GUEST) {
	                            _this.conversation.isNew = true;
	                        }
	                    }
	                    else {
	                        console.log('botId: ' + botId + ' is NOT contact.');
	                        _this.conversation.isChatEnabled = false;
	                        _this.conversation.isNew = true;
	                        if (sendRequest) {
	                            console.log('sending contact request to botId: ' + botId);
	                            // TODO: handle case when CR is not send?
	                            application_1.default.instance.AgentsManager.addAgent(botId);
	                        }
	                        _this._checkContactTimeout = setTimeout(function () {
	                            console.log('[CONVERSATION MANAGER]::wating for contact request acceptance');
	                            self.startConversationWithBot(false);
	                        }, 1000);
	                    }
	                }, function (error) {
	                    // TODO: what should happen when start failed
	                    console.error('START FAILED');
	                    console.error(error);
	                    debugger;
	                });
	            };
	            return _this.executeWhenSignedIn(startWithBot);
	        };
	        this.subscribeToConversation = function () {
	            console.log('[messagingService]::subscribe to conversation');
	            _this._needToReset = true;
	            var self = _this;
	            _this._startConversationSetupTime = Date.now();
	            return chat_1.subscribeConversation(_this.conversation.id, _this._eventHandler.bind(_this, _this.conversation))
	                .then(function () {
	                var fetchUserMessages = function (date) {
	                    chat_1.fetchMessages(_this.conversation.id).then(self._messagesHandler.bind(self, _this.conversation, date), function (error) {
	                        self.sendConversationLoadEvent(0, Date.now(), error.errorCode || 500);
	                    });
	                };
	                if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.SKYPE) {
	                    fetchUserMessages(Date.now());
	                    return;
	                }
	                if (_this.currentUserHasHistory(self.conversation.id)) {
	                    fetchUserMessages(Date.now());
	                }
	                else {
	                    self.sendConversationLoadEvent(0, Date.now());
	                }
	                // esorokin: uncomment when chat service will return recent conversations for a guest user
	                // checkIfConversationExist(this.conversation.id).then((existingConversation: IRawConversation) => {
	                //     if (existingConversation) {
	                //         fetchUserMessages(Date.now());
	                //     } else {
	                //         self.sendConversationLoadEvent(0, Date.now());
	                //     }
	                // })
	            });
	        };
	        if (!conversation) {
	            errorHandler_1.default.throwError(10500, 'conversation is missing');
	        }
	        this.conversation.backend = messagingBackend_1.MessagingBackend.SKYPE;
	        this._messageTypesHandler = new handler_1.default();
	        application_1.default.instance.Messaging.fetchMePerson();
	    }
	    /********************************
	    *** Interface implmementation ***
	    *********************************/
	    SkypeMessagingService.prototype.sendMessage = function (text, origin, payload, sanitize) {
	        if (sanitize === void 0) { sanitize = true; }
	        var messageSentEvent = new messageSentEvent_1.MessageSentEvent(this.conversation);
	        messageSentEvent.messageLength = text.length;
	        messageSentEvent.origin = origin;
	        messageSentEvent.messageType = messageType_1.MessageType.TEXT;
	        messageSentEvent.origin = origin;
	        var content = (!sanitize) ? text : this._encoder.encode(text, this.conversation, app_1.default.mePerson);
	        return this.sendMessageToService({
	            content: content,
	            messagetype: 'RichText',
	            contenttype: 'text',
	            composetime: new Date().toISOString(),
	            clientmessageid: Date.now().toString(),
	            // imdisplayname: this.mePerson.displayName,
	            'Has-Mentions': this.messageContainsMention(content),
	            actionTrigger: origin
	        }, messageSentEvent);
	    };
	    SkypeMessagingService.prototype.sendImage = function (payload) {
	        var messageSentEvent = new messageSentEvent_1.MessageSentEvent(this.conversation);
	        messageSentEvent.messageType = messageType_1.MessageType.IMAGE;
	        return this.sendMessageToService({
	            content: payload,
	            contenttype: 'text',
	            messagetype: 'RichText/UriObject',
	            composetime: new Date().toISOString(),
	            clientmessageid: Date.now().toString(),
	            // imdisplayname: this.mePerson.displayName,
	            actionTrigger: actionTrigger_1.ActionTrigger.UNDEFINED
	        }, messageSentEvent);
	    };
	    SkypeMessagingService.prototype.sendFile = function (payload) {
	        var messageSentEvent = new messageSentEvent_1.MessageSentEvent(this.conversation);
	        messageSentEvent.messageType = messageType_1.MessageType.FILE;
	        return this.sendMessageToService({
	            content: payload,
	            contenttype: 'text',
	            messagetype: 'RichText/Media_GenericFile',
	            composetime: new Date().toISOString(),
	            clientmessageid: Date.now().toString(),
	            // imdisplayname: this.mePerson.displayName,
	            actionTrigger: actionTrigger_1.ActionTrigger.UNDEFINED
	        }, messageSentEvent);
	    };
	    SkypeMessagingService.prototype.sendSwift = function (payload) {
	        var messageSentEvent = new messageSentEvent_1.MessageSentEvent(this.conversation);
	        messageSentEvent.messageType = messageType_1.MessageType.SWIFT;
	        return this.sendMessageToService({
	            content: payload,
	            contenttype: 'text',
	            messagetype: 'RichText',
	            composetime: new Date().toISOString(),
	            clientmessageid: Date.now().toString(),
	            // imdisplayname: this.mePerson.displayName,
	            actionTrigger: actionTrigger_1.ActionTrigger.UNDEFINED
	        }, messageSentEvent);
	    };
	    SkypeMessagingService.prototype.setIsTyping = function (isTyping) {
	        return this.sendMessageToService({
	            content: '',
	            contenttype: 'text',
	            messagetype: isTyping ? 'Control/Typing' : 'Control/ClearTyping',
	            composetime: new Date().toISOString(),
	            // imdisplayname: this.mePerson.displayName,
	            clientmessageid: Date.now().toString(),
	            actionTrigger: actionTrigger_1.ActionTrigger.TYPING
	        }, null);
	    };
	    SkypeMessagingService.prototype.startConversation = function () {
	        if (!this.isOneToOneOrBot()) {
	            return this.startGroupConversation();
	        }
	        else {
	            if (this.conversation.isConversationWithPerson()) {
	                return this.startConversationWithPerson();
	            }
	            else {
	                return this.startConversationWithBot();
	            }
	        }
	    };
	    SkypeMessagingService.prototype.loadMoreMessages = function (conversation) {
	        if (this._backwardLink) {
	            return chat_1.fetchMessagesByLink(this._backwardLink).then(this._messagesHandler.bind(this, conversation, Date.now()));
	        }
	        else {
	            return Promise.resolve();
	        }
	    };
	    SkypeMessagingService.prototype.stopListeningConversation = function () {
	        chat_1.unsubscribeConversation(this.conversation.id);
	    };
	    SkypeMessagingService.prototype.dispose = function () {
	        this.stopListeningConversation();
	        if (this._checkContactTimeout) {
	            clearTimeout(this._checkContactTimeout);
	            this._checkContactTimeout = null;
	        }
	    };
	    /********************************
	    *** PRIVATE Methods ***
	    *********************************/
	    SkypeMessagingService.prototype.sendMessageToService = function (messageData, messageSentEvent) {
	        var _this = this;
	        var messageModel = this._messageTypesHandler.generateOutgoing(messageData), startTime = Date.now();
	        if (messageModel) {
	            // if (app.translatorEnabled && app.translationStatus() === 1) {
	            //     messageModel.isTranslated = true;
	            // }
	            this.conversation.messages.push(messageModel);
	        }
	        if (this.conversation.isConversationWithBot() && messageData.messagetype === 'RichText') {
	            this.conversation.isTyping = true;
	        }
	        var onSuccess = function (response) {
	            console.log('[skypeConversationsManager] :: sendMessageToService : success');
	            if (messageModel) {
	                messageModel.status = DeliveryStatus_1.DeliveryStatus.Sent;
	            }
	            // in case of typing indicator, do not count it in messagesSent counter
	            if (messageSentEvent) {
	                if (messageSentEvent.origin !== actionTrigger_1.ActionTrigger.TYPING) {
	                    _this.conversation.messagesSent++;
	                }
	                messageSentEvent.index++;
	                messageSentEvent.timeToSend = Date.now() - startTime;
	                messageSentEvent.status = 200;
	                application_1.default.instance.TelemetryService.sendEvent(messageSentEvent);
	            }
	        };
	        var onFailure = function (response) {
	            console.log('[skypeConversationsManager] :: sendMessageToService : failure');
	            if (messageModel) {
	                messageModel.status = DeliveryStatus_1.DeliveryStatus.Failed;
	            }
	            if (messageSentEvent) {
	                messageSentEvent.status = response.status;
	                messageSentEvent.errorCode = response.errorCode;
	                messageSentEvent.errorMessage = response.message;
	                messageSentEvent.timeToSend = Date.now() - startTime;
	                application_1.default.instance.TelemetryService.sendEvent(messageSentEvent);
	            }
	        };
	        // if (app.translationStatus() === 1) {
	        //     return translator.translate(navigator.language.split('-')[0], app.translationLanguage, messageData.content).then( (translation:string) => {
	        //         messageData.content = translation;
	        //         return sendMessage(conversationId, messageData).then(onSuccess, onFailure);
	        //     });
	        // } else {
	        //     return sendMessage(conversationId, messageData).then(onSuccess, onFailure);
	        // }
	        return conversation_1.sendMessage(this.conversation.id, messageData).then(onSuccess, onFailure);
	    };
	    SkypeMessagingService.prototype.sendDataToBot = function (payload) {
	        return conversation_1.sendDataToBot(this.conversation.id, { name: 'SWC', conversation: { id: app_1.default.currentUserName }, value: payload });
	    };
	    SkypeMessagingService.prototype.messageContainsMention = function (content) {
	        var mentionPattern = /<at id="(.*?)">.*?<\/at>/g;
	        return mentionPattern.test(content).toString().toLowerCase();
	    };
	    SkypeMessagingService.prototype.executeWhenSignedIn = function (callback) {
	        return application_1.default.instance.SignInManager.getSkypeToken().then(function (token) {
	            callback();
	        })
	            .catch(function () {
	            console.log('[skypeConversationsManager] TODO: check that sending/receving messages is working after relogin!');
	        });
	    };
	    SkypeMessagingService.prototype.sendConversationLoadEvent = function (messagesCount, fetchFinishedTime, status) {
	        if (!conversationLoadEvent_1.ConversationLoadEvent.isAvailable) {
	            return;
	        }
	        conversationLoadEvent_1.ConversationLoadEvent.isAvailable = false;
	        var conLoadEvt = new conversationLoadEvent_1.ConversationLoadEvent(this.conversation);
	        conLoadEvt.messagesCount = messagesCount;
	        conLoadEvt.status = status;
	        conLoadEvt.timeToLoad = fetchFinishedTime - this._startConversationSetupTime;
	        conLoadEvt.timeToRender = Date.now() - fetchFinishedTime;
	        application_1.default.instance.TelemetryService.sendEvent(conLoadEvt);
	    };
	    /*
	    Data Handlers
	    */
	    SkypeMessagingService.prototype._eventHandler = function (conversation, resourceType, resource) {
	        switch (resourceType) {
	            case 'NewMessage':
	                if (this._messageTypesHandler.isTypingIndicator(resource)) {
	                    conversation.isTyping = resource.messagetype === 'Control/Typing';
	                    break;
	                }
	                this._setHistoryParamToCache(conversation.id);
	                var newMessage = this.processNewMessage(conversation, resource);
	                if (newMessage && newMessage.direction === Direction_1.Direction.Incoming) {
	                    conversation.isTyping = false;
	                    var evt = new messageReceivedEvent_1.default(this.conversation);
	                    evt.messageType = newMessage.type;
	                    application_1.default.instance.TelemetryService.sendEvent(evt);
	                    conversation.messagesReceived++;
	                }
	                break;
	            default:
	                break;
	        }
	    };
	    SkypeMessagingService.prototype._messagesHandler = function (conversation, fetchingStartTime, messages) {
	        var _this = this;
	        if (!conversation.messages) {
	            console.log('[skypeCOnversationsManager] messagesHandler: messages in conversation are not available');
	            this.sendConversationLoadEvent(0, Date.now(), 200);
	            return;
	        }
	        if (!messages) {
	            this.sendConversationLoadEvent(0, Date.now(), 200);
	            return;
	        }
	        var renderStartTime = Date.now();
	        this._backwardLink = messages._metadata.backwardLink;
	        var messageModels = [];
	        messages.messages.forEach(function (resource) {
	            _this.processNewMessage(conversation, resource, messageModels);
	        });
	        messageModels.sort(function (a, b) {
	            if (a.timestamp > b.timestamp) {
	                return 1;
	            }
	            else if (a.timestamp < b.timestamp) {
	                return -1;
	            }
	            return 0;
	        });
	        var evtData = new messagesFetchEvent_1.MessagesFetchEvent(this.conversation);
	        evtData.messageCount = messages.messages.length;
	        evtData.status = 200;
	        evtData.timeToFetch = Date.now() - fetchingStartTime;
	        application_1.default.instance.TelemetryService.sendEvent(evtData);
	        (_a = conversation.messages).push.apply(_a, messageModels);
	        this.sendConversationLoadEvent(messages.messages.length, renderStartTime, 200);
	        var _a;
	    };
	    SkypeMessagingService.prototype.processNewMessage = function (conversation, resource, messages) {
	        function isSystemMessage(message) {
	            return !!(message && message.type === 'SystemMessage');
	        }
	        messages = messages || conversation.messages;
	        var newMessage = this._messageTypesHandler.handle(resource);
	        if (!newMessage) {
	            console.error('[skypeConversationsMnager] processNewMessage - unable to process a message: ' + resource.messagetype);
	            console.error(resource);
	            return null;
	        }
	        newMessage.status = DeliveryStatus_1.DeliveryStatus.Sent;
	        if (isSystemMessage(newMessage)) {
	            messages.push(newMessage);
	            return newMessage;
	        }
	        var existingMessage = this.getExistingMessage(newMessage, messages, conversation.messages);
	        if (!existingMessage && !!newMessage.skypeEditedId) {
	            // newMessage - is edit of some existing message. 
	            // Need to hide it till original message appear
	            var existingEdit = this.filterMessagesByKey(conversation.allMessages, newMessage.key);
	            if (existingEdit) {
	                this._messageTypesHandler.updateExistingMessage(existingEdit, newMessage);
	            }
	            else {
	                conversation.allMessages.push(newMessage);
	            }
	            return newMessage;
	        }
	        if (!existingMessage && !newMessage.skypeEditedId) {
	            var existingEdit = this.filterMessagesByKey(conversation.allMessages, newMessage.key);
	            if (existingEdit) {
	                this._messageTypesHandler.updateExistingMessage(existingEdit, newMessage);
	                messages.push(existingEdit);
	                return existingEdit;
	            }
	        }
	        if (imgUrlRX.test(newMessage.content)) {
	            newMessage.content = newMessage.content.replace(imgUrlRX, '$1' + domPurifyService_1.default.dompurify.sanitize(imgUrlReplacement, imgUrlReplacementRules) + '$3');
	        }
	        if (existingMessage) {
	            this._messageTypesHandler.updateExistingMessage(existingMessage, newMessage);
	        }
	        else {
	            messages.push(newMessage);
	        }
	        return newMessage;
	    };
	    SkypeMessagingService.prototype.getExistingMessage = function (newMessage, messages, existingMessages) {
	        var diffArrays = existingMessages !== messages;
	        var existingMessage = this.filterMessagesByKey(existingMessages, newMessage.key);
	        if (existingMessage) {
	            return existingMessage;
	        }
	        if (diffArrays) {
	            existingMessage = this.filterMessagesByKey(messages, newMessage.key);
	        }
	        return existingMessage;
	    };
	    SkypeMessagingService.prototype.filterMessagesByKey = function (messages, key) {
	        return messages.filter(function (message) {
	            return message.key === key;
	        })[0];
	    };
	    SkypeMessagingService.prototype._setHistoryParamToCache = function (conversationId) {
	        // esorokin: temporary hack until chatS fix issue with returning empty recent conversations list for guests
	        if (app_1.default.currentUserIdentityType === identityType_1.IdentityType.SKYPE) {
	            // no need to set history indicator for skype user
	            return;
	        }
	        if (this.currentUserHasHistory(conversationId)) {
	            return;
	        }
	        var history = application_1.default.instance.Storage.getItem('skype|hasHistory') || '';
	        history = history === '' ? conversationId : history + ';' + conversationId;
	        application_1.default.instance.Storage.setItem('skype|hasHistory', history);
	    };
	    SkypeMessagingService.prototype.currentUserHasHistory = function (conversationId) {
	        var history = application_1.default.instance.Storage.getItem('skype|hasHistory') || '';
	        return history.indexOf(conversationId) >= 0;
	    };
	    return SkypeMessagingService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkypeMessagingService;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	var actionTrigger_1 = __webpack_require__(154);
	var messageType_1 = __webpack_require__(197);
	var conversationDataEvent_1 = __webpack_require__(65);
	var errorHandler_1 = __webpack_require__(15);
	/**
	 * An event being published after a message sending
	 * completes and reports QoS and KPI factors.
	 *
	 * @export
	 * @class MessageSentEvent
	 * @extends {TelemetryEvent}
	 */
	var MessageSentEvent = (function (_super) {
	    __extends(MessageSentEvent, _super);
	    function MessageSentEvent(conversation) {
	        _super.call(this, 'kpi_message_sent', conversation);
	        this.index = 0;
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf MessageSentEvent
	     */
	    MessageSentEvent.prototype.getSharedCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('timeSent', this.timeToSend, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.status || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorCode', this.errorCode || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('errorMessage', this.errorMessage || telemetryEvent_1.NA, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messageLength', this.messageLength || 0, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messageType', this.getMessageType(), piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('index', this.index + '', piiType_1.PIIType.NotSet));
	        var sendAction = telemetryEvent_1.NA;
	        switch (this.origin) {
	            case actionTrigger_1.ActionTrigger.BUTTON_SEND_CLICK:
	                sendAction = 'button';
	                break;
	            case actionTrigger_1.ActionTrigger.KEYPRESS_ENTER:
	                sendAction = 'enter';
	                break;
	            case actionTrigger_1.ActionTrigger.WELCOME_MESSAGE:
	                sendAction = 'welcome';
	                break;
	            default:
	                sendAction = this.origin ? this.origin + '' : telemetryEvent_1.NA;
	                break;
	        }
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('origin', sendAction, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    MessageSentEvent.prototype.getCustomProperties = function () {
	        return this.getSharedCustomProperties();
	    };
	    MessageSentEvent.prototype.getMessageType = function () {
	        switch (this.messageType) {
	            case messageType_1.MessageType.TEXT:
	                return 'text';
	            case messageType_1.MessageType.IMAGE:
	                return 'image';
	            case messageType_1.MessageType.FILE:
	                return 'file';
	            case messageType_1.MessageType.SWIFT:
	                return 'swift';
	            case messageType_1.MessageType.EMOTICON:
	                return 'emoticon';
	            case messageType_1.MessageType.QUICK_REPLY:
	                return 'quick reply';
	            case messageType_1.MessageType.UNDETERMINED:
	                return telemetryEvent_1.NA;
	            default:
	                errorHandler_1.default.throwError(10250, 'Unknown Message type:' + this.messageType);
	        }
	        return telemetryEvent_1.NA;
	    };
	    return MessageSentEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	exports.MessageSentEvent = MessageSentEvent;


/***/ },
/* 197 */
/***/ function(module, exports) {

	"use strict";
	(function (MessageType) {
	    MessageType[MessageType["UNDEFINED"] = 0] = "UNDEFINED";
	    MessageType[MessageType["UNDETERMINED"] = 10] = "UNDETERMINED";
	    MessageType[MessageType["TEXT"] = 100] = "TEXT";
	    MessageType[MessageType["IMAGE"] = 200] = "IMAGE";
	    MessageType[MessageType["FILE"] = 300] = "FILE";
	    MessageType[MessageType["SWIFT"] = 400] = "SWIFT";
	    MessageType[MessageType["TYPING"] = 500] = "TYPING";
	    MessageType[MessageType["EMOTICON"] = 600] = "EMOTICON";
	    MessageType[MessageType["QUICK_REPLY"] = 700] = "QUICK_REPLY";
	})(exports.MessageType || (exports.MessageType = {}));
	var MessageType = exports.MessageType;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var xmmFallback_1 = __webpack_require__(199);
	var textMessage_1 = __webpack_require__(207);
	var addMember_1 = __webpack_require__(208);
	var deleteMember_1 = __webpack_require__(210);
	var roleUpdate_1 = __webpack_require__(211);
	var topicUpdate_1 = __webpack_require__(212);
	var pictureUpdate_1 = __webpack_require__(213);
	var historyDisclosed_1 = __webpack_require__(214);
	var joiningEnabled_1 = __webpack_require__(215);
	var swiftCard_1 = __webpack_require__(216);
	var image_1 = __webpack_require__(217);
	var file_1 = __webpack_require__(218);
	var MessageTypesHandler = (function () {
	    function MessageTypesHandler() {
	        this._processors = [];
	        this._xmmFallbackProcessor = new xmmFallback_1.default();
	        this._processors.push(new textMessage_1.default());
	        this._processors.push(new addMember_1.default());
	        this._processors.push(new deleteMember_1.default());
	        this._processors.push(new roleUpdate_1.default());
	        this._processors.push(new topicUpdate_1.default());
	        this._processors.push(new pictureUpdate_1.default());
	        this._processors.push(new historyDisclosed_1.default());
	        this._processors.push(new joiningEnabled_1.default());
	        this._processors.push(new swiftCard_1.default());
	        this._processors.push(new image_1.default());
	        this._processors.push(new file_1.default());
	    }
	    MessageTypesHandler.prototype.handle = function (resource) {
	        var processedModel;
	        var processorIndex = 0;
	        while (!processedModel && processorIndex < this._processors.length) {
	            processedModel = this._processors[processorIndex].process(resource);
	            processorIndex++;
	        }
	        if (!processedModel) {
	            processedModel = this._xmmFallbackProcessor.process(resource);
	            if (processedModel) {
	                console.warn('UNKNOWN XMM MESSAGE', resource);
	            }
	            else {
	                console.warn('UNKNOWN MESSAGE TYPE', resource);
	            }
	        }
	        return processedModel;
	    };
	    MessageTypesHandler.prototype.generateOutgoing = function (payload) {
	        var processedModel;
	        var processorIndex = 0;
	        while (!processedModel && processorIndex < this._processors.length) {
	            processedModel = this._processors[processorIndex].generate(payload);
	            processorIndex++;
	        }
	        return processedModel;
	    };
	    MessageTypesHandler.prototype.updateExistingMessage = function (message, newMessage) {
	        if (!newMessage) {
	            return message;
	        }
	        if (newMessage.composeTime < message.composeTime) {
	            // 'newMessage' is older than existing one
	            message.timestamp = newMessage.timestamp;
	            return null;
	        }
	        message.id = newMessage.id;
	        message.content = newMessage.content;
	        message.status = newMessage.status;
	        message.timestamp = newMessage.timestamp;
	        if (newMessage.skypeEditedId && !newMessage.content) {
	            message.isDeleted = true;
	        }
	        return message;
	    };
	    MessageTypesHandler.prototype.isTypingIndicator = function (resource) {
	        return resource.messagetype === 'Control/Typing' || resource.messagetype === 'Control/ClearTyping';
	    };
	    return MessageTypesHandler;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessageTypesHandler;
	;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var i18n_1 = __webpack_require__(112);
	var messageTypesWithFallbackMessage = [
	    'RichText/UriObject',
	    'RichText/Media_GenericFile',
	    'RichText/Media_Video',
	    'RichText/Media_FlikMsg',
	    'RichText/Media_Card',
	    'RichText/Contacts',
	    'RichText/Location'
	];
	var XmmFallbackProcessor = (function (_super) {
	    __extends(XmmFallbackProcessor, _super);
	    function XmmFallbackProcessor() {
	        _super.apply(this, arguments);
	    }
	    XmmFallbackProcessor.prototype.process = function (resource) {
	        if (messageTypesWithFallbackMessage.indexOf(resource.messagetype) < 0) {
	            return null;
	        }
	        var xmmFallbackMessageMatch = resource.content.match(/^<uriobject[^>]*?>(.*?)<\/uriobject>$/i);
	        if (!xmmFallbackMessageMatch) {
	            var dirtyContent = resource.skypeeditedid ? resource.content : i18n_1.default.fetch('m_unsupported');
	            return this._createMessageModel(resource, dirtyContent);
	        }
	        return this._createMessageModel(resource, xmmFallbackMessageMatch[1]);
	    };
	    return XmmFallbackProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = XmmFallbackProcessor;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var encoder_1 = __webpack_require__(201);
	var Message_1 = __webpack_require__(176);
	var Direction_1 = __webpack_require__(121);
	var utils_1 = __webpack_require__(81);
	var application_1 = __webpack_require__(47);
	var personHelper_1 = __webpack_require__(72);
	var MessageTypeProcessor = (function () {
	    function MessageTypeProcessor() {
	        this.encoder = new encoder_1.default();
	    }
	    MessageTypeProcessor.prototype.generate = function (resource) {
	        return null;
	    };
	    MessageTypeProcessor.prototype._createMessageModel = function (resource, customDirtyContent, isSystemMessage) {
	        if (isSystemMessage === void 0) { isSystemMessage = false; }
	        var messageModel = new Message_1.default(isSystemMessage);
	        var content = (typeof customDirtyContent !== 'undefined') ? customDirtyContent : resource.content;
	        if (!isSystemMessage) {
	            messageModel.senderId = personHelper_1.default.normalizePersonId(utils_1.getConversationIdFromUrl(resource.from));
	            messageModel.sender = application_1.default.instance.StratusManager.getPerson(messageModel.senderId);
	        }
	        messageModel.id = resource.id;
	        messageModel.content = this.encoder.decode(content);
	        messageModel.timestamp = new Date(resource.originalarrivaltime);
	        messageModel.composeTime = new Date(resource.composetime);
	        messageModel.skypeEditedId = resource.skypeeditedid;
	        // todo: check ids for system messages
	        messageModel.key = resource.clientmessageid || resource.skypeeditedid || resource.id || '0';
	        messageModel.direction = isSystemMessage || !personHelper_1.default.isMePerson(personHelper_1.default.normalizePersonId(messageModel.senderId))
	            ? Direction_1.Direction.Incoming : Direction_1.Direction.Outgoing;
	        return messageModel;
	    };
	    MessageTypeProcessor.prototype._generateOutgoingModel = function (payload) {
	        var message = new Message_1.default(false);
	        message.id = payload.clientmessageid;
	        message.timestamp = new Date(payload.composetime);
	        message.key = payload.clientmessageid;
	        message.senderId = application_1.default.instance.Messaging.mePerson.id;
	        message.direction = Direction_1.Direction.Outgoing;
	        return message;
	    };
	    return MessageTypeProcessor;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessageTypeProcessor;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var urlDomTransformer_1 = __webpack_require__(202);
	var newLineDomTransformer_1 = __webpack_require__(203);
	var mentionDomEncoder_1 = __webpack_require__(137);
	var mentionDomDecoder_1 = __webpack_require__(204);
	var formatter_1 = __webpack_require__(206);
	var escape = __webpack_require__(46);
	var domPurifyService_1 = __webpack_require__(131);
	var Encoder = (function () {
	    function Encoder() {
	        var _this = this;
	        this.encode = function (text, conversation, mePerson) {
	            var parser = new DOMParser();
	            var safeText = escape(text);
	            var textWithFormatting = formatter_1.default.addFormatting(safeText);
	            var dataHtml = parser.parseFromString(textWithFormatting, 'text/html');
	            var hasParserError = dataHtml.getElementsByTagName('parsererror').length !== 0;
	            if (hasParserError) {
	                return safeText;
	            }
	            try {
	                _this.outgoingDomTransformers.forEach(function (encoder) {
	                    try {
	                        encoder.transformRawToXml(dataHtml, dataHtml.body, conversation, mePerson);
	                    }
	                    catch (e) {
	                        console.log('Error during parsing: ' + e);
	                    }
	                });
	                return _this.convertHtmlDomToXmlString(dataHtml);
	            }
	            catch (e) {
	                console.log('Exception during encoding: ' + e);
	                return safeText;
	            }
	        };
	        this.decode = function (text, conversation, mePerson) {
	            var parser = new DOMParser();
	            // let safeText = DomPurifyService.sanitize(text, this.dompurifyConfig);
	            var safeText = domPurifyService_1.default.dompurify.sanitize(text, _this.dompurifyConfig);
	            var dataHtml = parser.parseFromString(safeText, 'text/html');
	            var hasParserError = dataHtml.getElementsByTagName('parsererror').length !== 0;
	            if (hasParserError) {
	                return safeText;
	            }
	            try {
	                _this.incomingDomTransformers.forEach(function (encoder) {
	                    try {
	                        encoder.transformRawToXml(dataHtml, dataHtml.body, conversation, mePerson);
	                    }
	                    catch (e) {
	                        console.log('Error during parsing: ' + e);
	                    }
	                });
	                return _this.convertHtmlDomToXmlString(dataHtml);
	            }
	            catch (e) {
	                console.log('Exception during decoding: ' + e);
	                return domPurifyService_1.default.dompurify.sanitize(text, _this.dompurifyConfig);
	            }
	        };
	        this.convertHtmlDomToXmlString = function (htmlDom) {
	            var xmlDom = htmlDom.implementation.createDocument(htmlDom.body.namespaceURI, 'message', null);
	            while (htmlDom.body.childNodes.length !== 0) {
	                xmlDom.childNodes[0].appendChild(htmlDom.body.childNodes[0]);
	            }
	            var xml = xmlDom.childNodes[0].outerHTML;
	            return xml.replace(/(?:^<message.*?>|<\/message>$)/g, '');
	        };
	        this.AddLinkElementTarget = function (currentNode, data, config) {
	            if (currentNode && currentNode.tagName && currentNode.tagName.toLowerCase() === 'a') {
	                if (!currentNode.hasAttribute('target')) {
	                    currentNode.setAttribute('target', '_blank');
	                }
	            }
	            return currentNode;
	        };
	        this.outgoingDomTransformers = [
	            new urlDomTransformer_1.URLDomTransformer(),
	            new newLineDomTransformer_1.NewLineDomTransformer(),
	            new mentionDomEncoder_1.MentionDomEncoder(),
	        ];
	        this.incomingDomTransformers = [
	            new newLineDomTransformer_1.NewLineDomTransformer(),
	            new mentionDomDecoder_1.MentionDomDecoder(),
	        ];
	        this.dompurifyConfig = {
	            ALLOWED_TAGS: ['a', 'b', 'i', 's', 'br', 'at'],
	            ALLOWED_ATTR: ['tabindex', 'title', 'href', 'target', 'id']
	        };
	        domPurifyService_1.default.dompurify.addHook('beforeSanitizeAttributes', this.AddLinkElementTarget);
	    }
	    Encoder.prototype.getDomPurify = function () {
	        return window.DOMPurify;
	    };
	    return Encoder;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Encoder;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var wordDomTransformer_1 = __webpack_require__(138);
	var URLDomTransformer = (function (_super) {
	    __extends(URLDomTransformer, _super);
	    function URLDomTransformer() {
	        _super.apply(this, arguments);
	    }
	    URLDomTransformer.prototype.isElementAllowed = function (element) {
	        return element.nodeName.toLowerCase() !== 'a';
	    };
	    URLDomTransformer.prototype.wordRawToXml = function (dom, word) {
	        var match = word.match(/^(?:https?:\/\/|mailto:)(.+)$/i), url = match && match[0], title = match && match[1];
	        if (!url) {
	            match = word.match(/^[^@]+@(?:\w+(?:\.\w+)+)$/i);
	            url = match && ('mailto:' + match[0]);
	            title = match && match[0];
	        }
	        if (!url) {
	            match = word.match(/^(?:www(?:\.\w+){2,})|(?:.+\.(?:com|org|net|edu|gov|mil|aero|arpa|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|pro|tel|travel|[a-z]{2,3}))$/i);
	            url = match && ('http://' + match[0]);
	            title = match && match[0];
	        }
	        if (url) {
	            return [this.createXmlElement(dom, url, title)];
	        }
	        return [];
	    };
	    URLDomTransformer.prototype.wordMatcher = function () {
	        return /\S+/g;
	    };
	    URLDomTransformer.prototype.createXmlElement = function (dom, url, title) {
	        var link = dom.createElement('a');
	        link.setAttribute('href', url);
	        link.setAttribute('title', url);
	        link.setAttribute('target', '_blank');
	        link.setAttribute('tabindex', '-1');
	        link.innerText = title;
	        return link;
	    };
	    return URLDomTransformer;
	}(wordDomTransformer_1.WordDomTransformer));
	exports.URLDomTransformer = URLDomTransformer;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var wordDomTransformer_1 = __webpack_require__(138);
	var NewLineDomTransformer = (function (_super) {
	    __extends(NewLineDomTransformer, _super);
	    function NewLineDomTransformer() {
	        _super.apply(this, arguments);
	    }
	    NewLineDomTransformer.prototype.isElementAllowed = function (element) {
	        return element.nodeName.toLowerCase() !== 'pre';
	    };
	    NewLineDomTransformer.prototype.wordRawToXml = function (dom, word) {
	        return [this.createXmlElement(dom)];
	    };
	    NewLineDomTransformer.prototype.getAllWords = function (text) {
	        var regex = /\r?\n/g, match, result = new Array();
	        while ((match = regex.exec(text)) !== null) {
	            result.push(match);
	        }
	        return result;
	    };
	    NewLineDomTransformer.prototype.createXmlElement = function (dom) {
	        return dom.createElement('br');
	    };
	    return NewLineDomTransformer;
	}(wordDomTransformer_1.WordDomTransformer));
	exports.NewLineDomTransformer = NewLineDomTransformer;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var domTransformerBase_1 = __webpack_require__(205);
	var MentionDomDecoder = (function (_super) {
	    __extends(MentionDomDecoder, _super);
	    function MentionDomDecoder() {
	        _super.apply(this, arguments);
	    }
	    MentionDomDecoder.prototype.isElementAllowed = function (element) {
	        return element.nodeName.toLowerCase() !== 'i' ||
	            element.className.toLowerCase().indexOf('mention') === -1;
	    };
	    MentionDomDecoder.prototype.xmlNodeToHtml = function (dom, item) {
	        if (item.nodeName.toLowerCase() === 'at' && item.attributes.getNamedItem('id')) {
	            var mention = dom.createElement('i');
	            mention.setAttribute('class', 'mention');
	            mention.setAttribute('title', item.attributes.getNamedItem('id').value);
	            mention.innerText = item.textContent;
	            return [mention];
	        }
	        return [];
	    };
	    return MentionDomDecoder;
	}(domTransformerBase_1.DomTransformerBase));
	exports.MentionDomDecoder = MentionDomDecoder;


/***/ },
/* 205 */
/***/ function(module, exports) {

	"use strict";
	var DomTransformerBase = (function () {
	    function DomTransformerBase() {
	    }
	    DomTransformerBase.prototype.transformRawToXml = function (dom, message, conversation, mePerson) {
	        var stack = [];
	        stack.push(message);
	        while (stack.length !== 0) {
	            var item = stack.pop();
	            if (this.encodeTextNodeToXml(dom, item, conversation, mePerson) &&
	                item.nodeType !== Node.TEXT_NODE && this.isElementAllowed(item)) {
	                this.pushChildNodes(stack, item);
	            }
	        }
	    };
	    // returns true if element needs to be further parsed
	    DomTransformerBase.prototype.encodeTextNodeToXml = function (dom, item, conversation, mePerson) {
	        var parent = item.parentNode, newNodes = this.xmlNodeToHtml(dom, item, conversation, mePerson);
	        if (newNodes.length === 0) {
	            return true;
	        }
	        for (var i = 0; i < newNodes.length; i++) {
	            parent.insertBefore(newNodes[i], item);
	        }
	        parent.removeChild(item);
	        return false;
	    };
	    DomTransformerBase.prototype.pushChildNodes = function (stack, item) {
	        for (var i = 0; i < item.childNodes.length; i++) {
	            stack.push(item.childNodes[i]);
	        }
	    };
	    return DomTransformerBase;
	}());
	exports.DomTransformerBase = DomTransformerBase;


/***/ },
/* 206 */
/***/ function(module, exports) {

	"use strict";
	var Formatter = (function () {
	    function Formatter() {
	    }
	    Formatter.addFormatting = function (text) {
	        text = Formatter.addFormattingTags(text, 'b', /(\s|^|_|~|i>|b>|s>)\*((?!\*\s).)*\*(\s|$|_|~|<)/gi, '*');
	        text = Formatter.addFormattingTags(text, 'i', /(\s|^|\*|~|i>|b>|s>)_((?!_\s).)*_(\s|$|\*|~|<)/gi, '_');
	        text = Formatter.addFormattingTags(text, 's', /(\s|^|_|\*|i>|b>|s>)~((?!~\s).)*~(\s|$|_|\*|<)/gi, '~');
	        return text;
	    };
	    Formatter.addFormattingTags = function (text, tag, formatRegex, sign) {
	        var res = text.match(formatRegex);
	        while (res && res.length > 0 && res[0].trim().length != 2) {
	            res.forEach(function (val) {
	                var replacableText = val.trim();
	                replacableText = replacableText.substring(replacableText.indexOf(sign), replacableText.lastIndexOf(sign) + 1);
	                var formattedText = replacableText.substr(1, replacableText.length - 2);
	                formattedText = Formatter.createStartTag(tag, sign) + formattedText + Formatter.createEndTag(tag);
	                text = text.replace(replacableText, formattedText);
	            });
	            res = text.match(formatRegex);
	        }
	        return text;
	    };
	    Formatter.createStartTag = function (tagName, sign) {
	        return '<' + tagName + ' raw_pre="' + sign + '" raw_post="' + sign + '">';
	    };
	    Formatter.createEndTag = function (tagName) {
	        return '</' + tagName + '>';
	    };
	    return Formatter;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Formatter;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var TextMessageProcessor = (function (_super) {
	    __extends(TextMessageProcessor, _super);
	    function TextMessageProcessor() {
	        _super.apply(this, arguments);
	    }
	    TextMessageProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'RichText' && resource.messagetype !== 'Text') {
	            return null;
	        }
	        return this._createMessageModel(resource);
	    };
	    TextMessageProcessor.prototype.generate = function (payload) {
	        if (payload.messagetype !== 'RichText') {
	            return null;
	        }
	        var messageModel = this._generateOutgoingModel(payload);
	        messageModel.content = payload.content;
	        return messageModel;
	    };
	    return TextMessageProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TextMessageProcessor;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var AddMemberProcessor = (function (_super) {
	    __extends(AddMemberProcessor, _super);
	    function AddMemberProcessor() {
	        _super.apply(this, arguments);
	    }
	    AddMemberProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/AddMember') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent, resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        memberMessageHelper._targets.forEach(memberMessageHelper._subscribeOnceToPersonsName);
	        return memberMessageHelper._messageModel;
	    };
	    AddMemberProcessor.prototype._generateContent = function (memberProcessor) {
	        if (memberProcessor._isSelfAction()) {
	            return i18n_1.default.fetch('joinedConversation', {
	                participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	            });
	        }
	        return i18n_1.default.fetch('wasAdded', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>',
	            contact: '<b>' + memberProcessor._targets.map(function (target) { return target.displayName; }).join('</b>, <b>') + '</b>'
	        });
	    };
	    return AddMemberProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AddMemberProcessor;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var application_1 = __webpack_require__(47);
	var MembersProcessorHelper = (function () {
	    function MembersProcessorHelper(_createMessageModel, _generateContent, resource) {
	        var _this = this;
	        this._createMessageModel = _createMessageModel;
	        this._generateContent = _generateContent;
	        this._subscribedCallbacks = {};
	        this._subscribeOnceToPersonsName = function (target) {
	            if (_this._subscribedCallbacks[target.id]) {
	                return;
	            }
	            _this._subscribedCallbacks[target.id] = _this._onDisplayNameChanged.bind(_this, target.id);
	            target.subscribe('displayName', _this._subscribedCallbacks[target.id]);
	        };
	        this._onDisplayNameChanged = function (skypename) {
	            _this._messageModel.content = _this._generateContent(_this);
	            _this._initiator.unsubscribe('displayName', _this._subscribedCallbacks[skypename]);
	        };
	        this._getInitiatorFromContent(resource.content);
	        this._getTargetsFromContent(resource.content);
	        this._messageModel = this._createMessageModel(resource, this._generateContent(this), true);
	    }
	    MembersProcessorHelper.prototype._isSelfAction = function () {
	        return this._targets.length === 1 && this._targets[0].id === this._initiator.id;
	    };
	    MembersProcessorHelper.prototype._getInitiatorFromContent = function (content) {
	        var regex = /<initiator>(\d+:.+)<\/initiator>/i;
	        var match = content.match(regex);
	        if (match) {
	            this._initiator = application_1.default.instance.StratusManager.getPerson(match[1]);
	        }
	    };
	    MembersProcessorHelper.prototype._getTargetsFromContent = function (content) {
	        var targets = /<target>.+?<\/target>/ig;
	        var regex = /(?:<target>|<id>)(\d+:.+?)(?:<\/id>|<\/target>)/i;
	        var targetMatches = content.match(targets) || [];
	        var matches = [];
	        targetMatches.forEach(function (targetMatch) {
	            var match = targetMatch.match(regex);
	            if (match) {
	                matches.push(match[1]);
	            }
	        });
	        this._targets = matches.map(function (value) { return application_1.default.instance.StratusManager.getPerson(value); });
	    };
	    return MembersProcessorHelper;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MembersProcessorHelper;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var DeleteMemberProcessor = (function (_super) {
	    __extends(DeleteMemberProcessor, _super);
	    function DeleteMemberProcessor() {
	        _super.apply(this, arguments);
	    }
	    DeleteMemberProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/DeleteMember') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent, resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        memberMessageHelper._targets.forEach(memberMessageHelper._subscribeOnceToPersonsName);
	        return memberMessageHelper._messageModel;
	    };
	    DeleteMemberProcessor.prototype._generateContent = function (memberProcessor) {
	        if (memberProcessor._isSelfAction()) {
	            return i18n_1.default.fetch('hasLeftConversation', {
	                perticipant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	            });
	        }
	        return i18n_1.default.fetch('wasRemoved', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>',
	            removedParticipant: '<b>' + memberProcessor._targets.map(function (target) { return target.displayName; }).join('</b>, <b>') + '</b>'
	        });
	    };
	    return DeleteMemberProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DeleteMemberProcessor;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var RoleUpdateProcessor = (function (_super) {
	    __extends(RoleUpdateProcessor, _super);
	    function RoleUpdateProcessor() {
	        _super.apply(this, arguments);
	    }
	    RoleUpdateProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/RoleUpdate') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent.bind(this, resource.content), resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        memberMessageHelper._targets.forEach(memberMessageHelper._subscribeOnceToPersonsName);
	        return memberMessageHelper._messageModel;
	    };
	    RoleUpdateProcessor.prototype._generateContent = function (content, memberProcessor) {
	        return i18n_1.default.fetch('roleUpdated', {
	            who: '<b>' + memberProcessor._initiator.displayName + '</b>',
	            whom: '<b>' + memberProcessor._targets[0].displayName + '</b>',
	            role: '<b>' + this._getRole(content) + '</b>'
	        });
	    };
	    RoleUpdateProcessor.prototype._getRole = function (content) {
	        var regex = /<role>(.+)<\/role>/i;
	        var match = content.match(regex);
	        if (match) {
	            return match[1];
	        }
	        return '';
	    };
	    ;
	    return RoleUpdateProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = RoleUpdateProcessor;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var TopicUpdateProcessor = (function (_super) {
	    __extends(TopicUpdateProcessor, _super);
	    function TopicUpdateProcessor() {
	        _super.apply(this, arguments);
	    }
	    TopicUpdateProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/TopicUpdate') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent.bind(this, resource.content), resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        return memberMessageHelper._messageModel;
	    };
	    TopicUpdateProcessor.prototype._generateContent = function (content, memberProcessor) {
	        return i18n_1.default.fetch('topicUpdated', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>',
	            topic: '<i>' + this._getNewTopic(content) + '</i>'
	        });
	    };
	    TopicUpdateProcessor.prototype._getNewTopic = function (content) {
	        var regex = /<value>(.+)<\/value>/i;
	        var match = content.match(regex);
	        if (match) {
	            return match[1];
	        }
	        return '';
	    };
	    ;
	    return TopicUpdateProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TopicUpdateProcessor;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var PictureUpdateProcessor = (function (_super) {
	    __extends(PictureUpdateProcessor, _super);
	    function PictureUpdateProcessor() {
	        _super.apply(this, arguments);
	    }
	    PictureUpdateProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/PictureUpdate') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent, resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        return memberMessageHelper._messageModel;
	    };
	    PictureUpdateProcessor.prototype._generateContent = function (memberProcessor) {
	        return i18n_1.default.fetch('threadPictureUpdated', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	        });
	    };
	    return PictureUpdateProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PictureUpdateProcessor;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var HistoryDisclosedProcessor = (function (_super) {
	    __extends(HistoryDisclosedProcessor, _super);
	    function HistoryDisclosedProcessor() {
	        _super.apply(this, arguments);
	    }
	    HistoryDisclosedProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/HistoryDisclosedUpdate') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent.bind(this, resource.content), resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        return memberMessageHelper._messageModel;
	    };
	    HistoryDisclosedProcessor.prototype._generateContent = function (content, memberProcessor) {
	        if (this._getUpdateValue(content) === 'false') {
	            return i18n_1.default.fetch('historyDisclosed', {
	                participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	            });
	        }
	        return i18n_1.default.fetch('historyClosed', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	        });
	    };
	    HistoryDisclosedProcessor.prototype._getUpdateValue = function (content) {
	        var regex = /<value>(.+)<\/value>/i;
	        var match = content.match(regex);
	        if (match) {
	            return match[1];
	        }
	        return '';
	    };
	    ;
	    return HistoryDisclosedProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = HistoryDisclosedProcessor;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var membersProcessorHelper_1 = __webpack_require__(209);
	var i18n_1 = __webpack_require__(112);
	var JoiningEnabledProcessor = (function (_super) {
	    __extends(JoiningEnabledProcessor, _super);
	    function JoiningEnabledProcessor() {
	        _super.apply(this, arguments);
	    }
	    JoiningEnabledProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'ThreadActivity/JoiningEnabledUpdate') {
	            return null;
	        }
	        var memberMessageHelper = new membersProcessorHelper_1.default(this._createMessageModel.bind(this), this._generateContent.bind(this, resource.content), resource);
	        memberMessageHelper._subscribeOnceToPersonsName(memberMessageHelper._initiator);
	        return memberMessageHelper._messageModel;
	    };
	    JoiningEnabledProcessor.prototype._generateContent = function (content, memberProcessor) {
	        if (this._getUpdateValue(content) === 'true') {
	            return i18n_1.default.fetch('joiningEnabled', {
	                participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	            });
	        }
	        return i18n_1.default.fetch('joiningDisabled', {
	            participant: '<b>' + memberProcessor._initiator.displayName + '</b>'
	        });
	    };
	    JoiningEnabledProcessor.prototype._getUpdateValue = function (content) {
	        var regex = /<value>(.+)<\/value>/i;
	        var match = content.match(regex);
	        if (match) {
	            return match[1];
	        }
	        return '';
	    };
	    ;
	    return JoiningEnabledProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = JoiningEnabledProcessor;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var stringUtils_1 = __webpack_require__(16);
	var base_1 = __webpack_require__(200);
	var i18n_1 = __webpack_require__(112);
	var domPurifyService_1 = __webpack_require__(131);
	var SwiftCardProcessor = (function (_super) {
	    __extends(SwiftCardProcessor, _super);
	    function SwiftCardProcessor() {
	        _super.apply(this, arguments);
	        this._getTitle = function (resource) {
	            var title;
	            var titleMatch = resource.content.match(/<Title>(.*)<\/Title>/i);
	            if (titleMatch) {
	                title = titleMatch[1];
	            }
	            else {
	                title = i18n_1.default.fetch('s_title', {
	                    mesageType: resource.messagetype
	                });
	            }
	            return title;
	        };
	    }
	    SwiftCardProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'RichText/Media_Card') {
	            return null;
	        }
	        var title = this._getTitle(resource);
	        var swiftPayload = resource.content.match(/<Swift b64="([^"]+)"\s*\/>/i);
	        try {
	            var decodedPayload = stringUtils_1.default.b64DecodeUnicode(swiftPayload[1]);
	            resource.content = '<SwiftCard Swift="' + encodeURIComponent(decodedPayload) + '">' + domPurifyService_1.default.dompurify.sanitize(title, { ALLOWED_TAGS: [] }) + '</SwiftCard>';
	        }
	        catch (err) {
	            return null;
	        }
	        var message = this._createMessageModel(resource);
	        message.type = 'SwiftCard';
	        message.content = decodeURIComponent(resource.content);
	        return message;
	    };
	    return SwiftCardProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SwiftCardProcessor;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var ImageMessageProcessor = (function (_super) {
	    __extends(ImageMessageProcessor, _super);
	    function ImageMessageProcessor() {
	        _super.apply(this, arguments);
	        this.parseRawMessage = function (rawMessage) {
	            var uriMatcher = rawMessage.match(/<URIObject[^>]*?\suri=\"([^"]+?)\"/i);
	            var xmmTypeMatcher = rawMessage.match(/<URIObject[^>]*?\stype=\"([^"]+?)\"/i);
	            var uriObjectType = rawMessage.match(/<meta[^>]*?\stype=\"([^"]+?)\"/i);
	            var filename = rawMessage.match(/<originalname[^>]*?\sv=\"([^"]+?)\"/i);
	            if (!uriMatcher) {
	                return null;
	            }
	            var parsedImageMessage = new ParsedImageMessage();
	            parsedImageMessage.filename = filename ? filename[1] : null;
	            parsedImageMessage.uri = uriMatcher[1];
	            parsedImageMessage.uriObjectType = uriObjectType ? uriObjectType[1] : null;
	            parsedImageMessage.xmmType = xmmTypeMatcher ? xmmTypeMatcher[1].split('.')[0] : null;
	            return parsedImageMessage;
	        };
	        this.isValidImageMessage = function (imageMessage) {
	            return imageMessage === null
	                || imageMessage.uri === null
	                || !(imageMessage.xmmType === 'Picture'
	                    || imageMessage.uriObjectType === 'photo');
	        };
	        this.createImageContent = function (imageMessage) {
	            return "<LwcImage url=\"" + imageMessage.uri + "\" filename=\"" + imageMessage.filename + "\" ></LwcImage>";
	        };
	    }
	    ImageMessageProcessor.prototype.process = function (resource) {
	        if (resource.messagetype !== 'RichText/UriObject') {
	            return null;
	        }
	        var parsedImageMessage = this.parseRawMessage(resource.content);
	        if (!parsedImageMessage && resource.skypeeditedid) {
	            // consider this as deleted message
	            var message_1 = this._createMessageModel(resource);
	            return message_1;
	        }
	        if (this.isValidImageMessage(parsedImageMessage)) {
	            return null;
	        }
	        var message = this._createMessageModel(resource);
	        message.type = 'LwcImage';
	        message.content = this.createImageContent(parsedImageMessage);
	        return message;
	    };
	    ImageMessageProcessor.prototype.generate = function (payload) {
	        if (payload.messagetype !== 'RichText/UriObject') {
	            return null;
	        }
	        var parsedImageMessage = this.parseRawMessage(payload.content);
	        if (this.isValidImageMessage(parsedImageMessage)) {
	            return null;
	        }
	        var message = this._generateOutgoingModel(payload);
	        message.type = 'LwcImage';
	        message.content = this.createImageContent(parsedImageMessage);
	        return message;
	    };
	    return ImageMessageProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageMessageProcessor;
	var ParsedImageMessage = (function () {
	    function ParsedImageMessage() {
	    }
	    return ParsedImageMessage;
	}());


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var base_1 = __webpack_require__(200);
	var FileMessageProcessor = (function (_super) {
	    __extends(FileMessageProcessor, _super);
	    function FileMessageProcessor() {
	        _super.apply(this, arguments);
	        this.parseRawMessage = function (rawMessage) {
	            var uriMatcher = rawMessage.match(/<URIObject[^>]*?\suri=\"([^"]+?)\"/i);
	            var xmmTypeMatcher = rawMessage.match(/<URIObject[^>]*?\stype=\"([^"]+?)\"/i);
	            var uriObjectType = rawMessage.match(/<meta[^>]*?\stype=\"([^"]+?)\"/i);
	            if (!uriMatcher) {
	                // TODO: mimat - handle removed message?
	                return null;
	            }
	            var parsedFileMessage = new ParsedFileMessage();
	            parsedFileMessage.uri = uriMatcher[1];
	            parsedFileMessage.uriObjectType = uriObjectType ? uriObjectType[1] : null;
	            parsedFileMessage.xmmType = xmmTypeMatcher ? xmmTypeMatcher[1].split('.')[0] : null;
	            return parsedFileMessage;
	        };
	        this.isValidFileMessage = function (fileMessage) {
	            return fileMessage === null
	                || fileMessage.uri === null
	                || !(fileMessage.xmmType === 'File');
	        };
	        this.createFileContent = function (fileMessage) {
	            return "<LwcFile url=\"" + fileMessage.uri + "\" size=\"" + fileMessage.size + "\" originalName=\"" + fileMessage.originalName + "\"></LwcFile>";
	        };
	    }
	    FileMessageProcessor.prototype.process = function (resource) {
	        if (['RichText/UriObject', 'RichText/Media_GenericFile', 'RichText/Media_Video',
	            'RichText/Media_AudioMsg', 'RichText/Media_Card'].indexOf(resource.messagetype) === -1) {
	            return null;
	        }
	        var rawMessage = resource.content;
	        var parsedFileMessage = this.parseRawMessage(rawMessage);
	        if (!parsedFileMessage && resource.skypeeditedid) {
	            // consider this as deleted message
	            var message_1 = this._createMessageModel(resource);
	            return message_1;
	        }
	        if (this.isValidFileMessage(parsedFileMessage)) {
	            return null;
	        }
	        var fileSize = rawMessage.match(/<FileSize[\s]+[^<]*v=\"([\d]*?)\"[^<]/i);
	        var fileNameMatch = rawMessage.match(/<OriginalName[\s]+[^<]*v=\"([\s\S]*?)\"[^<]/);
	        parsedFileMessage.size = fileSize ? fileSize[1] : '0';
	        parsedFileMessage.originalName = fileNameMatch ? fileNameMatch[1] : null;
	        var message = this._createMessageModel(resource);
	        message.type = 'LwcFile';
	        message.content = this.createFileContent(parsedFileMessage);
	        return message;
	    };
	    FileMessageProcessor.prototype.generate = function (payload) {
	        if (payload.messagetype !== 'RichText/Media_GenericFile') {
	            return null;
	        }
	        var rawMessage = payload.content;
	        var parsedFileMessage = this.parseRawMessage(rawMessage);
	        if (this.isValidFileMessage(parsedFileMessage)) {
	            return null;
	        }
	        var fileSize = rawMessage.match(/<FileSize[\s]+[^<]*v=\"([\d]*?)\"[^<]/i);
	        var fileNameMatch = rawMessage.match(/<OriginalName[\s]+[^<]*v=\"([\s\S]*?)\"[^<]/);
	        parsedFileMessage.size = fileSize ? fileSize[1] : '0';
	        parsedFileMessage.originalName = fileNameMatch ? fileNameMatch[1] : null;
	        var message = this._generateOutgoingModel(payload);
	        message.type = 'LwcFile';
	        message.content = this.createFileContent(parsedFileMessage);
	        return message;
	    };
	    return FileMessageProcessor;
	}(base_1.default));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FileMessageProcessor;
	var ParsedFileMessage = (function () {
	    function ParsedFileMessage() {
	    }
	    return ParsedFileMessage;
	}());


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var conversationDataEvent_1 = __webpack_require__(65);
	var telemetryEvent_1 = __webpack_require__(23);
	var piiType_1 = __webpack_require__(25);
	/**
	 * An event being published after a message sending
	 * completes and reports QoS and KPI factors.
	 *
	 * @export
	 * @class MessageReceivedEvent
	 * @extends {TelemetryEvent}
	 */
	var MessageReceivedEvent = (function (_super) {
	    __extends(MessageReceivedEvent, _super);
	    function MessageReceivedEvent(conversation) {
	        _super.call(this, 'kpi_message_received', conversation);
	        /**
	        * Type of message content
	        *
	        * @type {string}
	        * @memberOf MessageReceivedEvent
	        */
	        this.messageType = telemetryEvent_1.NA;
	    }
	    MessageReceivedEvent.prototype.getCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messageType', this.messageType, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return MessageReceivedEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MessageReceivedEvent;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	var conversationDataEvent_1 = __webpack_require__(65);
	/**
	 * An event being reported  every time a messages
	 * of a conversation are fetched or number of retries are depleted.
	 *
	 * @export
	 * @class MessagesFetchEvent
	 * @extends {TelemetryEvent}
	 */
	var MessagesFetchEvent = (function (_super) {
	    __extends(MessagesFetchEvent, _super);
	    function MessagesFetchEvent(conversation) {
	        _super.call(this, 'kpi_messages_fetch', conversation);
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf MessagesFetchEvent
	     */
	    MessagesFetchEvent.prototype.getCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('timeToFetch', this.timeToFetch, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('status', this.status, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messageCount', this.messageCount, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('numberOfRetries', this.getProperty(this.numberOfRetries), piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return MessagesFetchEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	exports.MessagesFetchEvent = MessagesFetchEvent;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var actionTrigger_1 = __webpack_require__(154);
	var ariaTelemetryService_1 = __webpack_require__(32);
	var Direction_1 = __webpack_require__(121);
	var errorHandler_1 = __webpack_require__(15);
	var Message_1 = __webpack_require__(176);
	var messageReceivedEvent_1 = __webpack_require__(219);
	var conversationLoadEvent_1 = __webpack_require__(89);
	var messageSentEvent_1 = __webpack_require__(196);
	var messageType_1 = __webpack_require__(197);
	var markdown_1 = __webpack_require__(222);
	var directLineV3_1 = __webpack_require__(223);
	var messagingBackend_1 = __webpack_require__(38);
	var DirectLineMessagingService = (function () {
	    function DirectLineMessagingService(conversation) {
	        var _this = this;
	        this.conversation = conversation;
	        this.enquedMessages = new Array();
	        this.sentMessages = new Array();
	        this.telemetryService = new ariaTelemetryService_1.AriaTelemetryService();
	        this.onMessageReceiveHandler = function (rawMessage) {
	            var processedText = markdown_1.default.parse(rawMessage.text);
	            if (!processedText && !rawMessage.attachments && !rawMessage.channelData) {
	                return;
	            }
	            if (processedText.length === 0 && rawMessage.attachments.length === 0 &&
	                (rawMessage.channelData && rawMessage.channelData.attachments && rawMessage.channelData.attachments.length === 0)) {
	                return;
	            }
	            if (_this.isMessageProcessed(processedText)) {
	                return;
	            }
	            if (!_this.conversation.topic) {
	                _this.conversation.topic = rawMessage.from.name || '';
	            }
	            var message = _this.parseRaw(rawMessage);
	            _this.conversation.messages.push(message);
	            var evt = new messageReceivedEvent_1.default(_this.conversation);
	            evt.messageType = message.type;
	            _this.telemetryService.sendEvent(evt);
	            _this.conversation.isTyping = false;
	        };
	        this.isMessageProcessed = function (text) {
	            if (_this.sentMessages.length === 0) {
	                return false;
	            }
	            return _this.sentMessages.some(function (message) {
	                return message.content === text;
	            });
	        };
	        if (!this.conversation) {
	            errorHandler_1.default.throwError(10501, 'conversation is missing');
	        }
	        if (!this.conversation.id) {
	            errorHandler_1.default.throwError(10011, 'Directline mode requires token');
	        }
	        this.conversation.backend = messagingBackend_1.MessagingBackend.DIRECT_LINE;
	        this.conversation.avatar = this.conversation.avatar || this.createDefaultAvatar();
	        this.directLineApi = new directLineV3_1.DirectLineV3(this.conversation.id, this.conversation.definition.BingDLApi);
	    }
	    DirectLineMessagingService.prototype.sendMessage = function (text, origin, payload) {
	        var _this = this;
	        this.conversation.isTyping = true;
	        var options = {
	            channelData: this.conversation.definition.Payload,
	            payload: payload ? payload.payload || '' : ''
	        };
	        text = text || '';
	        text = text.trim();
	        this.lastMessage = new Message_1.default(false, options);
	        this.lastMessage.content = !!text ? markdown_1.default.parse(text) : '';
	        this.lastMessage.direction = Direction_1.Direction.Outgoing;
	        this.lastMessage.type = 'UserMessage';
	        if (origin === actionTrigger_1.ActionTrigger.SUGGESTED_ACTION && payload.image_url) {
	            var img = '<img src="' + payload.image_url + '" \/>';
	            this.lastMessage.imageContent = !!img ? markdown_1.default.parse(img) : '';
	        }
	        // origin!==ActionTrigger.SUGGESTED_ACTION &&
	        if (text.length > 0) {
	            this.conversation.messages.push(this.lastMessage);
	        }
	        this.sentMessages.push(this.lastMessage);
	        var event = new messageSentEvent_1.MessageSentEvent(this.conversation);
	        event.origin = origin;
	        event.messageLength = this.lastMessage.content.length;
	        event.messageType = messageType_1.MessageType.TEXT;
	        this.enquedMessages.push({ message: this.lastMessage, event: event });
	        if (this.enquedMessages.length === 1) {
	            this.lastDequeue = new Promise(function (resolve, reject) {
	                _this.dequeueMessages(resolve);
	            });
	        }
	        return this.lastDequeue;
	    };
	    DirectLineMessagingService.prototype.sendSwift = function (payload) {
	        if (payload) {
	            return this.sendMessage(payload, actionTrigger_1.ActionTrigger.BUTTON_SWIFT_CLICKED);
	        }
	        else {
	            return Promise.reject('swift - Cannot send empty payload');
	        }
	    };
	    DirectLineMessagingService.prototype.sendDataToBot = function (payload) {
	        return Promise.resolve();
	    };
	    DirectLineMessagingService.prototype.sendFile = function (payload) { return Promise.reject('not implemented'); };
	    DirectLineMessagingService.prototype.sendImage = function (payload) { return Promise.reject('not implemented'); };
	    DirectLineMessagingService.prototype.setIsTyping = function (isTyping) { };
	    DirectLineMessagingService.prototype.loadMoreMessages = function (conversation) { return Promise.reject('not implemented'); };
	    DirectLineMessagingService.prototype.startConversation = function () {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var startDate = Date.now();
	            _this.directLineApi.createConversation().then(function (conversationId) {
	                _this.directLineApi.initPolling(conversationId, _this.onMessageReceiveHandler);
	                _this.conversation.id = conversationId; // this thing is rewriting token info in Conversation instance
	                var conLoadEvt = new conversationLoadEvent_1.ConversationLoadEvent(_this.conversation);
	                // conLoadEvt.messagesCount = messagesCount;
	                // conLoadEvt.status = status;
	                conLoadEvt.timeToLoad = Date.now() - startDate;
	                // conLoadEvt.timeToRender = Date.now() - fetchFinishedTime;
	                _this.telemetryService.sendEvent(conLoadEvt);
	                resolve();
	            }, function (reason) {
	                reject(reason);
	            });
	        });
	    };
	    DirectLineMessagingService.prototype.stopListeningConversation = function () { };
	    DirectLineMessagingService.prototype.dispose = function () { };
	    DirectLineMessagingService.prototype.sendConversationLoadTelemetry = function () {
	    };
	    DirectLineMessagingService.prototype.dequeueMessages = function (resolve) {
	        var _this = this;
	        var enqueueMessage = this.enquedMessages[0];
	        if (enqueueMessage) {
	            var message = enqueueMessage.message;
	            var event_1 = enqueueMessage.event;
	            event_1.timeToSend = Date.now();
	            // event.backend = this.conversation.backend;
	            // event.sdkMode = this.conversation.sdkMode;
	            var payload = enqueueMessage.message.payload || this.conversation.definition.Payload;
	            this.directLineApi.postMessage(message.content, this.conversation.id, payload).then(function (response) {
	                event_1.timeToSend = Date.now() - event_1.timeToSend;
	                event_1.status = response.status;
	                // event.conversationId = this.conversation.id;
	                // start polling to get the reponse asap
	                _this.directLineApi.initPolling(_this.conversation.id, _this.onMessageReceiveHandler);
	                // if (!event.conversationId) {
	                //     window.setTimeout(() => {
	                //        console.log('[DL]:delayed', this.conversation.id);
	                //         event.conversationId = this.conversation.id;
	                //         this.telemetryService.sendEvent(event);
	                //     }, 5000);
	                // } else {
	                //     this.telemetryService.sendEvent(event);
	                // }
	                _this.telemetryService.sendEvent(event_1);
	                _this.enquedMessages.splice(0, 1);
	                _this.dequeueMessages(resolve);
	            }, function (error) {
	                console.error(error);
	                // TODO: nimal, 15.10.2016 - What to do when message posting fails?
	                event_1.timeToSend = Date.now() - event_1.timeToSend;
	                event_1.status = error.status;
	                _this.telemetryService.sendEvent(event_1);
	            });
	        }
	        else {
	            resolve();
	        }
	    };
	    DirectLineMessagingService.prototype.parseRaw = function (rawMessage) {
	        var message = new Message_1.default(false), content = rawMessage.text ? markdown_1.default.parse(rawMessage.text) : '';
	        message.direction = (rawMessage.from === 'guest' || rawMessage.from.id === 'guest' || rawMessage.from === 'user' || rawMessage.from.id === 'user') ? Direction_1.Direction.Outgoing : Direction_1.Direction.Incoming; // TODO: nimal, 10/1/2016 - How is this allways received?
	        if (rawMessage.channelData && rawMessage.channelData.quick_replies && rawMessage.channelData.quick_replies.length) {
	            rawMessage.channelData.quick_replies.forEach(function (qr) {
	                message.suggestedActions.push(qr);
	            });
	        }
	        if (rawMessage.channelData && rawMessage.channelData.suggestedActions && rawMessage.channelData.suggestedActions.actions) {
	            rawMessage.channelData.suggestedActions.actions.forEach(function (qr) {
	                message.suggestedActions.push(qr);
	            });
	        }
	        if ((rawMessage.attachments && rawMessage.attachments.length > 0)
	            || (rawMessage.channelData && rawMessage.channelData.attachments && rawMessage.channelData.attachments.length > 0)) {
	            var att = void 0;
	            if (rawMessage.attachments && rawMessage.attachments.length) {
	                att = rawMessage.attachments;
	            }
	            else if (rawMessage.channelData.attachments && rawMessage.channelData.attachments.length) {
	                att = rawMessage.channelData.attachments;
	            }
	            var swiftCard = {
	                content: content,
	                summary: '',
	                attachments: att,
	                type: 'message/card'
	            };
	            message.content = '<SwiftCard Swift=\"' + JSON.stringify(swiftCard) + '\"></SwiftCard>';
	            message.type = 'SwiftCard';
	            message.senderId = rawMessage.from.id || rawMessage.from;
	        }
	        else if (rawMessage.text) {
	            message.content = content;
	        }
	        return message;
	    };
	    DirectLineMessagingService.prototype.createDefaultAvatar = function () {
	        var version = Math.floor(Math.random() * 11);
	        version = version === 0 ? 1 : version;
	        return 'https://bot-framework.azureedge.net/bot-icons-v1/bot-framework-default-' + version + '.png';
	    };
	    return DirectLineMessagingService;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DirectLineMessagingService;


/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";
	var Markdown = (function () {
	    function Markdown() {
	    }
	    /**
	     * Parses the given string searching for markdown metadata and
	     * transforms the string to appropriate html.
	     *
	     * @param {string} input
	     * @returns {string}
	     *
	     * @memberOf Markdown
	     */
	    Markdown.parse = function (input) {
	        return input
	            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
	            .replace(/__([^_]+)__/g, '<strong>$1</strong>')
	            .replace(/(^|[^\\])_([^_\s][^_]*)_/g, '$1<em>$2</em>')
	            .replace(/(^|[^\\])\*([^*\s][^*]*)\*/g, '$1<em>$2</em>')
	            .replace(/__([^_]+)__/g, '<strong>$1</strong>')
	            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
	            .replace(/~~([^~]+)~~/g, '<del>$1</del>')
	            .replace(/!\[(([^]+?))\]\((([^\s]+?)\s?"?([^"]*?)"?)\)/g, '<img src="$3" alt="$1" title="$2"/>')
	            .replace(/\[(([^]+?))\]\((([^\s]+?)\s?"?([^"]*?)"?)\)/g, '<a href="$3" title="$2">$1</a>')
	            .replace(/\n/g, '<br />');
	    };
	    return Markdown;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Markdown;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var config_1 = __webpack_require__(224);
	var errorHandler_1 = __webpack_require__(15);
	var helper_1 = __webpack_require__(225);
	var DirectLineV3 = (function () {
	    function DirectLineV3(token, bingApi) {
	        var _this = this;
	        this.watermark = '';
	        this.MAX_RETRIES = 20;
	        this.initPolling = function (conversationId, onMessageReceived) {
	            console.log('[DL]::Initializing polling');
	            var counter = 0;
	            var pollingFunction = function () {
	                counter++;
	                var url = 'conversations/' + conversationId + '/activities' + _this.watermark;
	                var params = _this.helper.createParams('GET', _this.token);
	                _this.helper.sendRequest(url, params).then(function (response) {
	                    if (_this.helper.isStatusForbidden(response)) {
	                        return;
	                    }
	                    response.json().then(function (data) {
	                        var added = false;
	                        for (var index = 0; index < data.activities.length; index++) {
	                            var rawMessage = data.activities[index];
	                            console.log('[DIRECT LINE]::Message:', rawMessage);
	                            if (!!onMessageReceived && !!rawMessage) {
	                                onMessageReceived(rawMessage);
	                            }
	                            /*
	                            {
	                              "activities": [
	                                {
	                                  "type": "message",
	                                  "id": "4ed6cc1b537a4cc78bb9b0a03fbe531f|0000005",
	                                  "timestamp": "2017-03-12T16:25:20.480375Z",
	                                  "channelId": "webchat",
	                                  "from": {
	                                    "id": "Baymax",
	                                    "name": "Baymax"
	                                  },
	                                  "conversation": {
	                                    "id": "4ed6cc1b537a4cc78bb9b0a03fbe531f"
	                                  },
	                                  "attachmentLayout": "list",
	                                  "text": "",
	                                  "attachments": [
	                                    {
	                                      "contentType": "application/vnd.microsoft.card.hero",
	                                      "content": {
	                                        "text": "Sounds good! I understand you don't need a doctor. Would you like a hug?",
	                                        "buttons": [
	                                          {
	                                            "type": "imBack",
	                                            "title": "Yes",
	                                            "value": "Yes"
	                                          },
	                                          {
	                                            "type": "imBack",
	                                            "title": "No",
	                                            "value": "No"
	                                          }
	                                        ]
	                                      }
	                                    }
	                                  ],
	                                  "entities": [],
	                                  "replyToId": "4ed6cc1b537a4cc78bb9b0a03fbe531f|0000004"
	                                }
	                              ],
	                              "watermark": "5"
	                            }
	                            */
	                            added = true;
	                        }
	                        if (data.watermark) {
	                            _this.watermark = '?watermark=' + data.watermark;
	                        }
	                        if (added) {
	                            return;
	                        }
	                        if (counter < _this.MAX_RETRIES) {
	                            setTimeout(pollingFunction, config_1.DIRECT_LINE_POLLING_INTERVAL);
	                        }
	                    }, function (error) {
	                        errorHandler_1.default.throwError(10070, error);
	                    });
	                }, function (reason) {
	                    errorHandler_1.default.throwError(10070, '[DLService] - initPolling' + JSON.stringify(reason));
	                });
	            };
	            pollingFunction();
	        };
	        this.helper = new helper_1.Helper(!!bingApi ? config_1.DIRECT_LINE_V3_BING_HOST_URL : config_1.DIRECT_LINE_V3_HOST_URL);
	        var tokenParts = token.split(':');
	        this.token = tokenParts.length > 1 ? tokenParts[1] : tokenParts[0];
	    }
	    DirectLineV3.prototype.getToken = function (secret) {
	        var params = this.helper.createParams('POST', secret);
	        return this.helper.sendRequest('tokens/generate', params).then(function (response) {
	            /*
	{
	  "conversationId": "EGKr2Hqy79k7eiOza29NOV",
	  "token": "bUNBp_gROaU.dAA.RQBHAEsAcgAyAEgAcQB5ADcAOQBrADcAZQBpAE8AegBhADIAOQBOAE8AVgA.NBfoajeb0gE.XsaCwl4-Lsc.qwwHU1aH0HCYz2ygzXDdGY9IpnUo2MnSqUz6X8MrO2w",
	  "expires_in": 1800
	}
	            */
	        });
	    };
	    DirectLineV3.prototype.createConversation = function () {
	        var _this = this;
	        var params = this.helper.createParams('POST', this.token);
	        return this.helper.sendRequest('conversations', params).then(function (response) {
	            if (_this.helper.isStatusForbidden(response)) {
	                return Promise.reject('Not authorized');
	            }
	            return response.json().then(function (data) {
	                /*
	{
	  "conversationId": "J4OAyJ1Z19MAI7eAUgdet0",
	  "token": "bUNBp_gROaU.dAA.SgA0AE8AQQB5AEoAMQBaADEAOQBNAEEASQA3AGUAQQBVAGcAZABlAHQAMAA.vj251jOb0gE.45yZYQuJTYA.TmJqK9ubmOJXKk73TVElEYc67pV4CrxhQOiCcSSBNhw",
	  "expires_in": 1800,
	  "streamUrl": "wss://directline.botframework.com/v3/directline/conversations/J4OAyJ1Z19MAI7eAUgdet0/stream?watermark=-&t=bUNBp_gROaU.dAA.SgA0AE8AQQB5AEoAMQBaADEAOQBNAEEASQA3AGUAQQBVAGcAZABlAHQAMAA.vk-ayS-b0gE.38uLQy2rl2Y.4MK5d34OH0Qp-2V_T6mD-qhjtP7SUNXySOQpnHmk89M"
	}
	                */
	                return data.conversationId;
	            }, function (reason) {
	                errorHandler_1.default.throwError(10025, '[DLService] - createConversation' + JSON.stringify(reason));
	            });
	        });
	    };
	    DirectLineV3.prototype.postMessage = function (text, conversationId, payload) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var params = _this.helper.createParams('POST', _this.token, _this.buildPostMessageBody(text, conversationId, payload));
	            var url = 'conversations/' + conversationId + '/activities';
	            _this.helper.sendRequest(url, params)
	                .then(function (response) {
	                if (_this.helper.isStatusForbidden(response)) {
	                    return _this.refreshToken().then(function () {
	                        // TODO: multiple re-tries?
	                        return _this.postMessage(text, conversationId, payload);
	                    });
	                }
	                return resolve(response);
	            }, function (reason) {
	                errorHandler_1.default.throwError(10026, 'DLService] - sendMessage' + JSON.stringify(reason));
	                reject(reason);
	            });
	        });
	    };
	    DirectLineV3.prototype.refreshToken = function () {
	        return this.helper.sendRequest('tokens/refresh', this.helper.createParams('POST', this.token));
	    };
	    DirectLineV3.prototype.buildPostMessageBody = function (text, conversationId, payload) {
	        return JSON.stringify({
	            type: 'message',
	            text: text,
	            from: {
	                id: 'user'
	            },
	            payload: payload.payload,
	            channelData: payload.channelData
	        });
	    };
	    return DirectLineV3;
	}());
	exports.DirectLineV3 = DirectLineV3;


/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";
	exports.DIRECT_LINE_HOST_URL = 'https://directline.botframework.com/api/';
	exports.DIRECT_LINE_V3_HOST_URL = 'https://directline.botframework.com/v3/directline/';
	exports.DIRECT_LINE_V3_BING_HOST_URL = 'https://bing.botframework.com/v3/directline/';
	exports.DIRECT_LINE_POLLING_INTERVAL = 500;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(fetch) {"use strict";
	var errorHandler_1 = __webpack_require__(15);
	var config_1 = __webpack_require__(224);
	var Helper = (function () {
	    function Helper(baseUrl) {
	        var _this = this;
	        this.baseUrl = baseUrl;
	        this.createParams = function (method, token, body) {
	            var authorization = _this.baseUrl === config_1.DIRECT_LINE_V3_HOST_URL || _this.baseUrl === config_1.DIRECT_LINE_V3_BING_HOST_URL ? 'Bearer' : 'BotConnector';
	            var headers = new Headers();
	            headers.append('Authorization', authorization + ' ' + token);
	            headers.append('Content-Type', 'text/json;charset=UTF-8');
	            headers.append('Accept', 'application/json');
	            var params = {};
	            params.method = method || 'POST';
	            params.headers = headers;
	            if (!!body) {
	                params.body = body;
	            }
	            return params;
	        };
	    }
	    Helper.prototype.sendRequest = function (url, parameters) {
	        return fetch(this.baseUrl + url, parameters);
	    };
	    Helper.prototype.isStatusForbidden = function (response) {
	        // 401 - The BasicAuth header is missing for this request.
	        // 403 - You are forbidden from performing this action because your token or secret is invalid.
	        // 404 - The response is an ErrorMessage response. Look at the Code field for a breakdown and message field for description of the error.
	        if (response.status === 401 || response.status === 403 || response.status === 404) {
	            errorHandler_1.default.throwError(10021, 'Unable to get conversation id, we are DONE. Probably wrong token/secret key.');
	            return true;
	        }
	        // 409 - You are trying to create an object that already exists.   
	        return false;
	    };
	    return Helper;
	}());
	exports.Helper = Helper;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var telemetryPropertyValue_1 = __webpack_require__(24);
	var piiType_1 = __webpack_require__(25);
	var conversationDataEvent_1 = __webpack_require__(65);
	/**
	 * An event being published in the moment user
	 * loaded the conversation in the chat control.
	 *
	 * @export
	 * @class ConversationLoadEvent
	 * @extends {TelemetryEvent}
	 */
	var ConversationEndEvent = (function (_super) {
	    __extends(ConversationEndEvent, _super);
	    function ConversationEndEvent(conversation) {
	        _super.call(this, 'kpi_conversation_end', conversation);
	        this._conversation = conversation;
	        this._startDate = Date.now();
	    }
	    /**
	     * Returns a coolection of properties of the event in a format
	     * which the telemetry infrastructure understands.
	     *
	     * @returns {Array<TelemeteryPropertyValue>}
	     *
	     * @memberOf SignInEvent
	     */
	    ConversationEndEvent.prototype.getCustomProperties = function () {
	        var props = _super.prototype.getCustomProperties.call(this);
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('duration', Date.now() - this._startDate, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messagesSent', this._conversation.messagesSent, piiType_1.PIIType.NotSet));
	        props.push(telemetryPropertyValue_1.TelemetryPropertyValue.Create('messagesReceived', this._conversation.messagesReceived, piiType_1.PIIType.NotSet));
	        return props;
	    };
	    return ConversationEndEvent;
	}(conversationDataEvent_1.ConversationDataEvent));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ConversationEndEvent;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=swc.js.map